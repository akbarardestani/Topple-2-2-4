using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Resources;
using AutoCAD;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using Excel = Microsoft.Office.Interop.Excel;
using System.Threading;
using CenterSpace.NMath;
using System.Configuration;


namespace Total_Slope
{
    public partial class MainForm : Form
    {
        //        private AcadCircle CADCircle = default(AcadCircle);
        //        private AcadLine CADLine = default(AcadLine);
        //        private AcadPolyline CADPolyline = default(AcadPolyline);
        private AcadLine CADLine = default(AcadLine);
        // Creating object reference to hold the reference of running AutoCAD instance.
        private AcadApplication AcadApp = default(AcadApplication);


        //just for excel debuging
        static Excel.Application app = new Excel.Application();
        static Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
        static Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;

        /*        Excel.Workbook workbook = app.Workbooks.Open("E:\\Debug\\Debug.xlsx",
                Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value,
                Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value,
                Missing.Value, Missing.Value, Missing.Value, Missing.Value);
        */
        public static double Export_FromNo = 0;
        public static double Export_ToNo = 0;
        public static bool Export_opp = false;

        public MainForm(double Result_From, double Result_To, bool ExportOrNot)
        {
            Export_FromNo = Result_From;
            Export_ToNo = Result_To;
            Export_opp = ExportOrNot;
            InitializeComponent();
        }
//        int ExcelSheetNo = 1;


//        int X_min_form_Res = 1014, Y_min_form_Res = 645;
        int X_Form_Size = 0, Y_Form_Size = 0;
//        Pnl_MainMenu


        string ModelName = "";
        int ModelId = 1;
        double Kv = 0;//Dynamic Vertical Acceleration Coefficient
        double Kv_T = 0;//Dynamic Vertical Acceleration Coefficient Deviation
        double Kh = 0;//Dynamic Horizontal Acceleration Coefficient
        double Kh_T = 0;//Dynamic Horizontal Acceleration Coefficient Deviation
        string ModelType = "";

        int SequencesNo = 0;//Slope No in the model
        string[,] SequenceList;// All Slope Model Data
        string[,] Origin_SequenceList;// Original All Slope Model Data
        string[] ModelDetail = new string[10];//general detail of model
        string[] Origin_ModelDetail = new string[10];//Original general detail of model

        string Com_Nam = System.Environment.MachineName;
        string Instal_Dir = System.Environment.CurrentDirectory;



        bool this_is_Worst_Case_Ever = false;
        bool Unstable_Found = false;

        bool Submit_Flag = false;

        bool Recalculate_FOS = false;

        string Excel_print_date = "";
        bool Excel_Work = false;
        int Excel_sheetNo = 0;

        bool fully_Stable_flag = false;


        int AnchorNo = 0;// Anchor Number
        string[,] AnchorList;//all Anchor data

        int ForceNo = 0; //Force No.
        string[,] ForceList;//All Forces Data

        double DrawingScale = 1;

        Point[] Model_Points;

        double[,] All_Slope_Points;
        int SliceNo = 0;// Sum of all Slices and Columns
        double[,] Slices;//all slices corner coordination
        int[,] Slices_FOS_Animation;//all slices corner coordination
        
        double[,] Anchor_Line;//all anchers head and point coordination
        Point[] WaterLevel;
        int RockySlopeNo = 0;//number of slopes that is from rock
        Point[] BasalPlanePoints;

        int Tention_Crack_StepsNo = 20;//steps of searching tension crack depth

        double[,] Analytical_Slice_Data;
        double[,] Temp_Analytical_Slice_Data;
        string[,] Analytical_Critical_Situation;

        bool Activated_app = true;

        List<List<double>> All_Arcs_List = new List<List<double>>();//to save circular failure plane parameters 

        List<List<List<string>>> Total_Analytical_Critical_Situation_List = new List<List<List<string>>>();//to save all critical Report of Each model that is solving in probabilistic mode

        List<List<List<string>>> Probabilistic_Analysis_Details = new List<List<List<string>>>();//to save all critical Report of Each model that is solving in probabilistic mode
        List<List<List<double>>> Probabilistic_All_Model_Details = new List<List<List<double>>>();//to save all Models detail of each run of solving in probabilistic mode
        List<List<List<string>>> Probabilistic_SequenceList = new List<List<List<string>>>();//to save all critical Report of Each model that is solving in probabilistic mode
        List<List<string>> Probabilistic_ModelDetail = new List<List<String>>();//to save all Models detail of each run of solving in probabilistic mode
        List<double> Probability_FOS = new List<double>();//for Probabilstic FoS Distribution

        List<List<List<double>>> All_Model_Details = new List<List<List<double>>>();//to save all Models detail of each run of solving in Deterministic mode
        List<double> Probability_Stability_Percent = new List<double>();//for drawing graph
        string[,,] Sorted_Critical_Situation_Charts;
        double[,,] Sorted_All_Model_Details;
        double[] Sorted_All_Slip_Surfase_FOS;

        List<List<List<double>>> Safety_Factor_List = new List<List<List<double>>>();//for drawing graph
        List<List<List<double>>> Sensitivity_Chart = new List<List<List<double>>>();//for drawing graph

        List<List<double>> FOS_List = new List<List<double>>();//for drawing graph of FOS
        double FOS_Step = 1;//Steps of Sof calculation by SRF method

        List<double> All_Slip_Surface_FOS = new List<double>();//to save SOF of all surfaces in soil slopes

        bool Exact_Slip_Surfaces_FOS_flag = false;

        bool Exact_Surfase = false;
        int Exact_from = 0;
        int Exact_to = 0;
        int Exact_arc = 0;
        int Exact_TC = 0;


        double[] Probabilistic_Report = new double[11];//over all reports off Probabilistic Analysis
        int Tension_Crack_Step = 0;
        int Circular_Arc_Angle = 0;//180=half circul and by reducing this angle center of circular failure plane go far
        double X_Arc_Center = 0, Y_Arc_Center = 0;


        double base_Rock_breakage_angle = 0;//angle of break line in a rock column ....0 = Perpendicular to Coumn
        double Gama = 98100;//unit weight of water

        //        double A_factor = 0,
        double Arc_Radius = 0;

        bool probabilistic_Running = true;

        bool SteppedSurface = false;//in rock Colums set top of colums stepped

        double FOS_Value = 0;

        bool Error = false;
        string ErrorString = "";
        string WarningString = "Material Definition Succeed\n";

        double[,] End_Prob_Calc = new double[2, 40];
        double[,] TEST_Prob_Calc = new double[4, 1000];
        int end_Reach = 0;

        int DB_Id = 0;//for edit and delete in data base

        DateTime StartTime, NowTime = new DateTime();
        TimeSpan EllapsedTime;

        int FOS_Animation_Stop = 200;
        bool First_Crown_Pick = true;//in FOS Animation Draw. in First Solved Model pick X Y of All Slice Top

        //        public static SqlConnection Connection = new SqlConnection(ConfigurationManager.ConnectionStrings["Total_Slope.Properties.Settings.SlopesDBConnectionString"].ConnectionString);
        public static SqlConnection Connection;

        
//                public static SqlConnection Connection = new SqlConnection("Data Source=(LocalDB)\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\SlopesDB.mdf;Integrated Security=True");
//        public static SqlConnection Connection = new SqlConnection("Data Source=DESKTOP-KJEOGTT\\AKBARARDESTANI;Initial "
//            + "Catalog=TotalSlopeDB;Persist Security Info=True;User ID=TotalSlopeDB_Login;Password=TotalSlope");
        public static SqlDataAdapter DataAdapter = new SqlDataAdapter();
        public static DataTable dta_tbl = new DataTable();

        private void MainForm_Load(object sender, EventArgs e)
        {
            SqlCommand Query = new SqlCommand();
            this.Size = Screen.PrimaryScreen.WorkingArea.Size;// maximize window at start up
            var PnlCorner1 = new Point(5, 55);
            var PnlCorner2 = new Point(775, 55);
            var LblCorner1 = new Point(80, Pnl_ProbabilisticDeterminidtic_Chart.Size.Height - 20);

            DGVAnalytical_Output.ColumnHeadersDefaultCellStyle.Font = new Font("Microsoft Sans Serif", 10, FontStyle.Regular);
            DGVAnalytical_Report.ColumnHeadersDefaultCellStyle.Font = new Font("Microsoft Sans Serif", 9, FontStyle.Regular);
            DGVProbabilisticResult.ColumnHeadersDefaultCellStyle.Font = new Font("Microsoft Sans Serif", 9, FontStyle.Regular);

            Lbl_ElpsTime.Location = LblCorner1;

/*            Pnl_MaterialDefinition.Location = PnlCorner1;
            Pnl_SlopeDefinition.Location = PnlCorner1;
            Pnl_ExternalForces.Location = PnlCorner1;
            Pnl_Joint.Location = PnlCorner1;
            Pnl_NewModel.Location = PnlCorner1;
            Pnl_ModelSketch.Location = PnlCorner2;
            Pnl_KinematicAnalysis.Location = PnlCorner1;
            Pnl_AnalyticalSolution.Location = PnlCorner1;
            Pnl_ProbabilisticAnalysis.Location = PnlCorner1;
            Pnl_DataBaseView.Location = PnlCorner2;
            Pnl_Refferences.Location = PnlCorner1;
*/
            Pnl_MaterialDefinition.BringToFront();
            Pnl_Sketch.BringToFront();



            //            Activation_Request(_Code_("Activated"), _Code_(Com_Nam+"y2019m12d3"), _Code_("2019"), _Code_("1"), _Code_("1"), _Code_("2019"), _Code_("1"), _Code_("5"));

            //           string jdhgfhjd = _Code_(Com_Nam+ "y0000m00d00") ;
            //           jdhgfhjd = _Code_("desktopkjeogttY2040m12d12");
            //rx7ybu8ykxuhbbqffffjffrff
            //rx7ybu8ykxuhbbqwfpfj0wr0w//Activation code
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Activation]";//read Activation information
            DataTable dt_Activation = new DataTable();
            dt_Activation.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Activation);
            Connection.Close();

            if (dt_Activation.Rows.Count == 0)//first run
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Activation] (MD, AC, FRY"
                    + ", FRM, FRD, LRY, LRM, LRD)"
                    + " VALUES (@MD_, @AC_, @FRY_, @FRM_, @FRD_"
                    + ", @LRY_, @LRM_, @LRD_)";
                Query.Parameters.Add("@MD_", SqlDbType.NVarChar).Value = _Code_("trial");
                Query.Parameters.Add("@AC_", SqlDbType.NVarChar).Value = _Code_(Com_Nam+"y0000m00d00");
                Query.Parameters.Add("@FRY_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Year));
                Query.Parameters.Add("@FRM_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Month));
                Query.Parameters.Add("@FRD_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Day));
                Query.Parameters.Add("@LRY_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Year));
                Query.Parameters.Add("@LRM_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Month));
                Query.Parameters.Add("@LRD_", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Day));

                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                Samplese_To_Database();

            }

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Activation]";//read Activation information
            dt_Activation.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Activation);
            Connection.Close();

            Activation_Request(
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[1]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[2]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[3]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[4]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[5]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[6]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[7]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[8]));


            /*
                        for (int i = 0; i < 10; i++)
                            Test_Normal_Dist();
                        for (int i = 0; i < 10; i++)
                            Test_Uniform_Dist();


                        for (int i = 0; i < 10; i++)
                            Test_LogNormal_Dist();
            */
        }

        private void Samplese_To_Database()
        {
            SqlCommand Query = new SqlCommand();
            try
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Material] ([Material Name], [Material Type], [Cohesive Strength], [Cohesive StrengthTolerance]"
                    + ", [Friction Angle], [Friction Angle_Tolerance], [Unit Weight], [Unit Weight Tolerance], [Tensile Strength]"
                    + ", [Tensile Strength Tolerance], [Young Modulus], [Young Modulus Tolerance], [Poisson Ratio], [Poisson Ratio Tolerance]"
                    + ", [Cohesive Strength Disrtibution], [Friction Angle Distribution], [Unit Weight Distribution], [Tensile Strength Distribution])"
                    + " VALUES (@MaterialName, @MaterialType, @CohesiveStrength, @CohesiveStrengthTolerance, @FrictionAngle, @FrictionAngleTolerance, @UnitWeight"
                    + ", @UnitWeightTolerance, @TensileStrength, @TensileStrengthTolerance, @YoungModulus, @YoungModulusTolerance, @PoissonRatio, @PoissonRatioTolerance"
                    + ", @CohesiveStrengthDisrtibution, @FrictionAngleDistribution, @UnitWeightDistribution, @TensileStrengthDistribution)";
                Query.Parameters.Add("@MaterialName", SqlDbType.NVarChar).Value = "Typical Material 1";
                Query.Parameters.Add("@MaterialType", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@CohesiveStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(200000);
                Query.Parameters.Add("@CohesiveStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(2000);
                Query.Parameters.Add("@FrictionAngle", SqlDbType.Decimal).Value = Convert.ToDecimal(38);
                Query.Parameters.Add("@FrictionAngleTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(3);
                Query.Parameters.Add("@UnitWeight", SqlDbType.Decimal).Value = Convert.ToDecimal(27000);
                Query.Parameters.Add("@UnitWeightTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(1000);
                Query.Parameters.Add("@TensileStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(1000000);
                Query.Parameters.Add("@TensileStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(20000);
                Query.Parameters.Add("@YoungModulus", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@YoungModulusTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@PoissonRatio", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@PoissonRatioTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@UnitWeightDistribution", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TensileStrengthDistribution", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Material] ([Material Name], [Material Type], [Cohesive Strength], [Cohesive StrengthTolerance]"
                    + ", [Friction Angle], [Friction Angle_Tolerance], [Unit Weight], [Unit Weight Tolerance], [Tensile Strength]"
                    + ", [Tensile Strength Tolerance], [Young Modulus], [Young Modulus Tolerance], [Poisson Ratio], [Poisson Ratio Tolerance]"
                    + ", [Cohesive Strength Disrtibution], [Friction Angle Distribution], [Unit Weight Distribution], [Tensile Strength Distribution])"
                    + " VALUES (@MaterialName1, @MaterialType1, @CohesiveStrength1, @CohesiveStrengthTolerance1, @FrictionAngle1, @FrictionAngleTolerance1, @UnitWeight1"
                    + ", @UnitWeightTolerance1, @TensileStrength1, @TensileStrengthTolerance1, @YoungModulus1, @YoungModulusTolerance1, @PoissonRatio1, @PoissonRatioTolerance1"
                    + ", @CohesiveStrengthDisrtibution1, @FrictionAngleDistribution1, @UnitWeightDistribution1, @TensileStrengthDistribution1)";
                Query.Parameters.Add("@MaterialName1", SqlDbType.NVarChar).Value = "Typical Material 2";
                Query.Parameters.Add("@MaterialType1", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@CohesiveStrength1", SqlDbType.Decimal).Value = Convert.ToDecimal(20000);
                Query.Parameters.Add("@CohesiveStrengthTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(500);
                Query.Parameters.Add("@FrictionAngle1", SqlDbType.Decimal).Value = Convert.ToDecimal(21);
                Query.Parameters.Add("@FrictionAngleTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(2);
                Query.Parameters.Add("@UnitWeight1", SqlDbType.Decimal).Value = Convert.ToDecimal(25000);
                Query.Parameters.Add("@UnitWeightTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(1500);
                Query.Parameters.Add("@TensileStrength1", SqlDbType.Decimal).Value = Convert.ToDecimal(1000);
                Query.Parameters.Add("@TensileStrengthTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(100);
                Query.Parameters.Add("@YoungModulus1", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@YoungModulusTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@PoissonRatio1", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@PoissonRatioTolerance1", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution1", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution1", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@UnitWeightDistribution1", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TensileStrengthDistribution1", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Material] ([Material Name], [Material Type], [Cohesive Strength], [Cohesive StrengthTolerance]"
                    + ", [Friction Angle], [Friction Angle_Tolerance], [Unit Weight], [Unit Weight Tolerance], [Tensile Strength]"
                    + ", [Tensile Strength Tolerance], [Young Modulus], [Young Modulus Tolerance], [Poisson Ratio], [Poisson Ratio Tolerance]"
                    + ", [Cohesive Strength Disrtibution], [Friction Angle Distribution], [Unit Weight Distribution], [Tensile Strength Distribution])"
                    + " VALUES (@MaterialName2, @MaterialType2, @CohesiveStrength2, @CohesiveStrengthTolerance2, @FrictionAngle2, @FrictionAngleTolerance2, @UnitWeight2"
                    + ", @UnitWeightTolerance2, @TensileStrength2, @TensileStrengthTolerance2, @YoungModulus2, @YoungModulusTolerance2, @PoissonRatio2, @PoissonRatioTolerance2"
                    + ", @CohesiveStrengthDisrtibution2, @FrictionAngleDistribution2, @UnitWeightDistribution2, @TensileStrengthDistribution2)";
                Query.Parameters.Add("@MaterialName2", SqlDbType.NVarChar).Value = "Typical Material 3";
                Query.Parameters.Add("@MaterialType2", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@CohesiveStrength2", SqlDbType.Decimal).Value = Convert.ToDecimal(800000);
                Query.Parameters.Add("@CohesiveStrengthTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@FrictionAngle2", SqlDbType.Decimal).Value = Convert.ToDecimal(38);
                Query.Parameters.Add("@FrictionAngleTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@UnitWeight2", SqlDbType.Decimal).Value = Convert.ToDecimal(27000);
                Query.Parameters.Add("@UnitWeightTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(2000);
                Query.Parameters.Add("@TensileStrength2", SqlDbType.Decimal).Value = Convert.ToDecimal(500000);
                Query.Parameters.Add("@TensileStrengthTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@YoungModulus2", SqlDbType.Decimal).Value = Convert.ToDecimal(1);
                Query.Parameters.Add("@YoungModulusTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@PoissonRatio2", SqlDbType.Decimal).Value = Convert.ToDecimal(1);
                Query.Parameters.Add("@PoissonRatioTolerance2", SqlDbType.Decimal).Value = Convert.ToDecimal(0);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution2", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution2", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@UnitWeightDistribution2", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TensileStrengthDistribution2", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();


                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName3, @CohesiveStrengt3, @CohesiveStrengtTolerance3, @FrictionAngle3, @FrictionAngleTolerance3"
                    + ", @CohesiveStrengthDisrtibution3, @FrictionAngleDistribution3)";

                Query.Parameters.Add("@JointName3", SqlDbType.NVarChar).Value = "Typical Joint 1";
                Query.Parameters.Add("@CohesiveStrengt3", SqlDbType.Decimal).Value = Convert.ToDecimal(50000);
                Query.Parameters.Add("@CohesiveStrengtTolerance3", SqlDbType.Decimal).Value = Convert.ToDecimal(5000);
                Query.Parameters.Add("@FrictionAngle3", SqlDbType.Decimal).Value = Convert.ToDecimal(37);
                Query.Parameters.Add("@FrictionAngleTolerance3", SqlDbType.Decimal).Value = Convert.ToDecimal(4);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution3", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution3", SqlDbType.NVarChar).Value = "Uniform";

                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName4, @CohesiveStrengt4, @CohesiveStrengtTolerance4, @FrictionAngle4, @FrictionAngleTolerance4"
                    + ", @CohesiveStrengthDisrtibution4, @FrictionAngleDistribution4)";

                Query.Parameters.Add("@JointName4", SqlDbType.NVarChar).Value = "Typical Joint 2";
                Query.Parameters.Add("@CohesiveStrengt4", SqlDbType.Decimal).Value = Convert.ToDecimal(100000);
                Query.Parameters.Add("@CohesiveStrengtTolerance4", SqlDbType.Decimal).Value = Convert.ToDecimal(5000);
                Query.Parameters.Add("@FrictionAngle4", SqlDbType.Decimal).Value = Convert.ToDecimal(33);
                Query.Parameters.Add("@FrictionAngleTolerance4", SqlDbType.Decimal).Value = Convert.ToDecimal(3);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution4", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution4", SqlDbType.NVarChar).Value = "Uniform";

                Query.Connection = Connection;
                Query.ExecuteNonQuery();
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName5, @CohesiveStrengt5, @CohesiveStrengtTolerance5, @FrictionAngle5, @FrictionAngleTolerance5"
                    + ", @CohesiveStrengthDisrtibution5, @FrictionAngleDistribution5)";

                Query.Parameters.Add("@JointName5", SqlDbType.NVarChar).Value = "Typical Joint 3";
                Query.Parameters.Add("@CohesiveStrengt5", SqlDbType.Decimal).Value = Convert.ToDecimal(10000);
                Query.Parameters.Add("@CohesiveStrengtTolerance5", SqlDbType.Decimal).Value = Convert.ToDecimal(2000);
                Query.Parameters.Add("@FrictionAngle5", SqlDbType.Decimal).Value = Convert.ToDecimal(30);
                Query.Parameters.Add("@FrictionAngleTolerance5", SqlDbType.Decimal).Value = Convert.ToDecimal(2);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution5", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution5", SqlDbType.NVarChar).Value = "Uniform";

                Query.Connection = Connection;
                Query.ExecuteNonQuery();
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName6, @CohesiveStrengt6, @CohesiveStrengtTolerance6, @FrictionAngle6, @FrictionAngleTolerance6"
                    + ", @CohesiveStrengthDisrtibution6, @FrictionAngleDistribution6)";

                Query.Parameters.Add("@JointName6", SqlDbType.NVarChar).Value = "Typical Joint 4";
                Query.Parameters.Add("@CohesiveStrengt6", SqlDbType.Decimal).Value = Convert.ToDecimal(10000);
                Query.Parameters.Add("@CohesiveStrengtTolerance6", SqlDbType.Decimal).Value = Convert.ToDecimal(2000);
                Query.Parameters.Add("@FrictionAngle6", SqlDbType.Decimal).Value = Convert.ToDecimal(37);
                Query.Parameters.Add("@FrictionAngleTolerance6", SqlDbType.Decimal).Value = Convert.ToDecimal(5);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution6", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution6", SqlDbType.NVarChar).Value = "Uniform";

                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName7, @CohesiveStrengt7, @CohesiveStrengtTolerance7, @FrictionAngle7, @FrictionAngleTolerance7"
                    + ", @CohesiveStrengthDisrtibution7, @FrictionAngleDistribution7)";

                Query.Parameters.Add("@JointName7", SqlDbType.NVarChar).Value = "Typical Joint 5";
                Query.Parameters.Add("@CohesiveStrengt7", SqlDbType.Decimal).Value = Convert.ToDecimal(100000);
                Query.Parameters.Add("@CohesiveStrengtTolerance7", SqlDbType.Decimal).Value = Convert.ToDecimal(5000);
                Query.Parameters.Add("@FrictionAngle7", SqlDbType.Decimal).Value = Convert.ToDecimal(33);
                Query.Parameters.Add("@FrictionAngleTolerance7", SqlDbType.Decimal).Value = Convert.ToDecimal(3);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution7", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution7", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

            Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName8, @CohesiveStrengt8, @CohesiveStrengtTolerance8, @FrictionAngle8, @FrictionAngleTolerance8"
                    + ", @CohesiveStrengthDisrtibution8, @FrictionAngleDistribution8)";

                Query.Parameters.Add("@JointName8", SqlDbType.NVarChar).Value = "Typical Joint 6";
                Query.Parameters.Add("@CohesiveStrengt8", SqlDbType.Decimal).Value = Convert.ToDecimal(50000);
                Query.Parameters.Add("@CohesiveStrengtTolerance8", SqlDbType.Decimal).Value = Convert.ToDecimal(5000);
                Query.Parameters.Add("@FrictionAngle8", SqlDbType.Decimal).Value = Convert.ToDecimal(37);
                Query.Parameters.Add("@FrictionAngleTolerance8", SqlDbType.Decimal).Value = Convert.ToDecimal(4);
                Query.Parameters.Add("@CohesiveStrengthDisrtibution8", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FrictionAngleDistribution8", SqlDbType.NVarChar).Value = "Uniform";

            Query.Connection = Connection;
            Query.ExecuteNonQuery();

            Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName9, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 1'), @FaceAngle9, @FaceHeight9, @FaceColumnNo9, @FaceColumnNoTolerance9, @ColumnAngle9, @ColumnAngleTolerance9"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 2'), @BasalPlaneAngle9, @BasalPlaneAngleTolerance9, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 1'), @TopWaterLevel9, @TopWaterLevelTolerance9, @WaterLevelAngle9, @WaterLevelAngleTolerance9, @Blockiness9, @BlockinessTolerance9, @MaterialType9"
                    + ", @FaceColumnNoDistribution9, @ColumnAngleDistribution9, @BasalPlaneAngleDistribution9, @TopWaterLevelDistribution9, @WaterLevelAngleDistribution9, @BlockinessDistribution9)";
                Query.Parameters.Add("@SlopeName9", SqlDbType.NVarChar).Value = "Typical Slope 1";
                Query.Parameters.Add("@FaceAngle9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(47.2);
                Query.Parameters.Add("@FaceHeight9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(18.73);
                Query.Parameters.Add("@FaceColumnNo9", SqlDbType.Int).Value = System.Convert.ToInt32(8);
                Query.Parameters.Add("@FaceColumnNoTolerance9", SqlDbType.Int).Value = System.Convert.ToInt32(2);
                Query.Parameters.Add("@ColumnAngle9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(75);
                Query.Parameters.Add("@ColumnAngleTolerance9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(3);
                Query.Parameters.Add("@BasalPlaneAngle9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(15);
                Query.Parameters.Add("@BasalPlaneAngleTolerance9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(2);
                Query.Parameters.Add("@TopWaterLevel9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@TopWaterLevelTolerance9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@WaterLevelAngle9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@WaterLevelAngleTolerance9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@Blockiness9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(50);
                Query.Parameters.Add("@BlockinessTolerance9", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@MaterialType9", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@FaceColumnNoDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@ColumnAngleDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BasalPlaneAngleDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TopWaterLevelDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@WaterLevelAngleDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BlockinessDistribution9", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName10, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 2'), @FaceAngle10, @FaceHeight10, @FaceColumnNo10, @FaceColumnNoTolerance10, @ColumnAngle10, @ColumnAngleTolerance10"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 3'), @BasalPlaneAngle10, @BasalPlaneAngleTolerance10, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 3'), @TopWaterLevel10, @TopWaterLevelTolerance10, @WaterLevelAngle10, @WaterLevelAngleTolerance10, @Blockiness10, @BlockinessTolerance10, @MaterialType10"
                    + ", @FaceColumnNoDistribution10, @ColumnAngleDistribution10, @BasalPlaneAngleDistribution10, @TopWaterLevelDistribution10, @WaterLevelAngleDistribution10, @BlockinessDistribution10)";
                Query.Parameters.Add("@SlopeName10", SqlDbType.NVarChar).Value = "Typical Slope 2";
                Query.Parameters.Add("@FaceAngle10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@FaceHeight10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(11.29);
                Query.Parameters.Add("@FaceColumnNo10", SqlDbType.Int).Value = System.Convert.ToInt32(10);
                Query.Parameters.Add("@FaceColumnNoTolerance10", SqlDbType.Int).Value = System.Convert.ToInt32(2);
                Query.Parameters.Add("@ColumnAngle10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(75);
                Query.Parameters.Add("@ColumnAngleTolerance10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(3.5);
                Query.Parameters.Add("@BasalPlaneAngle10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(41.62);
                Query.Parameters.Add("@BasalPlaneAngleTolerance10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@TopWaterLevel10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(28.3);
                Query.Parameters.Add("@TopWaterLevelTolerance10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@WaterLevelAngle10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@WaterLevelAngleTolerance10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@Blockiness10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(50);
                Query.Parameters.Add("@BlockinessTolerance10", SqlDbType.Decimal).Value = System.Convert.ToDecimal(12);
                Query.Parameters.Add("@MaterialType10", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@FaceColumnNoDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@ColumnAngleDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BasalPlaneAngleDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TopWaterLevelDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@WaterLevelAngleDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BlockinessDistribution10", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName11, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 3'), @FaceAngle11, @FaceHeight11, @FaceColumnNo11, @FaceColumnNoTolerance11, @ColumnAngle11, @ColumnAngleTolerance11"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 5'), @BasalPlaneAngle11, @BasalPlaneAngleTolerance11, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 6'), @TopWaterLevel11, @TopWaterLevelTolerance11, @WaterLevelAngle11, @WaterLevelAngleTolerance11, @Blockiness11, @BlockinessTolerance11, @MaterialType11"
                    + ", @FaceColumnNoDistribution11, @ColumnAngleDistribution11, @BasalPlaneAngleDistribution11, @TopWaterLevelDistribution11, @WaterLevelAngleDistribution11, @BlockinessDistribution11)";
                Query.Parameters.Add("@SlopeName11", SqlDbType.NVarChar).Value = "Typical Slope 3";
                Query.Parameters.Add("@FaceAngle11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(71.34);
                Query.Parameters.Add("@FaceHeight11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(36.4);
                Query.Parameters.Add("@FaceColumnNo11", SqlDbType.Int).Value = System.Convert.ToInt32(6);
                Query.Parameters.Add("@FaceColumnNoTolerance11", SqlDbType.Int).Value = System.Convert.ToInt32(1);
                Query.Parameters.Add("@ColumnAngle11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(70);
                Query.Parameters.Add("@ColumnAngleTolerance11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@BasalPlaneAngle11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(30);
                Query.Parameters.Add("@BasalPlaneAngleTolerance11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@TopWaterLevel11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(37);
                Query.Parameters.Add("@TopWaterLevelTolerance11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngle11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngleTolerance11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@Blockiness11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(100);
                Query.Parameters.Add("@BlockinessTolerance11", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@MaterialType11", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@FaceColumnNoDistribution11", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@ColumnAngleDistribution11", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BasalPlaneAngleDistribution11", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TopWaterLevelDistribution11", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@WaterLevelAngleDistribution11", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BlockinessDistribution11", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName12, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 3'), @FaceAngle12, @FaceHeight12, @FaceColumnNo12, @FaceColumnNoTolerance12, @ColumnAngle12, @ColumnAngleTolerance12"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 5'), @BasalPlaneAngle12, @BasalPlaneAngleTolerance12, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 6'), @TopWaterLevel12, @TopWaterLevelTolerance12, @WaterLevelAngle12, @WaterLevelAngleTolerance12, @Blockiness12, @BlockinessTolerance12, @MaterialType12"
                    + ", @FaceColumnNoDistribution12, @ColumnAngleDistribution12, @BasalPlaneAngleDistribution12, @TopWaterLevelDistribution12, @WaterLevelAngleDistribution12, @BlockinessDistribution12)";
                Query.Parameters.Add("@SlopeName12", SqlDbType.NVarChar).Value = "Typical Slope 4";
                Query.Parameters.Add("@FaceAngle12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(6);
                Query.Parameters.Add("@FaceHeight12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(6.5);
                Query.Parameters.Add("@FaceColumnNo12", SqlDbType.Int).Value = System.Convert.ToInt32(16);
                Query.Parameters.Add("@FaceColumnNoTolerance12", SqlDbType.Int).Value = System.Convert.ToInt32(3);
                Query.Parameters.Add("@ColumnAngle12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(70);
                Query.Parameters.Add("@ColumnAngleTolerance12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@BasalPlaneAngle12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(30);
                Query.Parameters.Add("@BasalPlaneAngleTolerance12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@TopWaterLevel12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(43.5);
                Query.Parameters.Add("@TopWaterLevelTolerance12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngle12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngleTolerance12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@Blockiness12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(100);
                Query.Parameters.Add("@BlockinessTolerance12", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@MaterialType12", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@FaceColumnNoDistribution12", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@ColumnAngleDistribution12", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@BasalPlaneAngleDistribution12", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@TopWaterLevelDistribution12", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@WaterLevelAngleDistribution12", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BlockinessDistribution12", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName13, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 2'), @FaceAngle13, @FaceHeight13, @FaceColumnNo13, @FaceColumnNoTolerance13, @ColumnAngle13, @ColumnAngleTolerance13"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 3'), @BasalPlaneAngle13, @BasalPlaneAngleTolerance13, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 4'), @TopWaterLevel13, @TopWaterLevelTolerance13, @WaterLevelAngle13, @WaterLevelAngleTolerance13, @Blockiness13, @BlockinessTolerance13, @MaterialType13"
                    + ", @FaceColumnNoDistribution13, @ColumnAngleDistribution13, @BasalPlaneAngleDistribution13, @TopWaterLevelDistribution13, @WaterLevelAngleDistribution13, @BlockinessDistribution13)";
                Query.Parameters.Add("@SlopeName13", SqlDbType.NVarChar).Value = "Typical Slope 5";
                Query.Parameters.Add("@FaceAngle13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(60);
                Query.Parameters.Add("@FaceHeight13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@FaceColumnNo13", SqlDbType.Int).Value = System.Convert.ToInt32(10);
                Query.Parameters.Add("@FaceColumnNoTolerance13", SqlDbType.Int).Value = System.Convert.ToInt32(0);
                Query.Parameters.Add("@ColumnAngle13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(90);
                Query.Parameters.Add("@ColumnAngleTolerance13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BasalPlaneAngle13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(30);
                Query.Parameters.Add("@BasalPlaneAngleTolerance13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@TopWaterLevel13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@TopWaterLevelTolerance13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngle13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngleTolerance13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@Blockiness13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BlockinessTolerance13", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@MaterialType13", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@FaceColumnNoDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@ColumnAngleDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BasalPlaneAngleDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@TopWaterLevelDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@WaterLevelAngleDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BlockinessDistribution13", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName14, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 2'), @FaceAngle14, @FaceHeight14, @FaceColumnNo14, @FaceColumnNoTolerance14, @ColumnAngle14, @ColumnAngleTolerance14"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 3'), @BasalPlaneAngle14, @BasalPlaneAngleTolerance14, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 4'), @TopWaterLevel14, @TopWaterLevelTolerance14, @WaterLevelAngle14, @WaterLevelAngleTolerance14, @Blockiness14, @BlockinessTolerance14, @MaterialType14"
                    + ", @FaceColumnNoDistribution14, @ColumnAngleDistribution14, @BasalPlaneAngleDistribution14, @TopWaterLevelDistribution14, @WaterLevelAngleDistribution14, @BlockinessDistribution14)";
                Query.Parameters.Add("@SlopeName14", SqlDbType.NVarChar).Value = "Typical Slope 6";
                Query.Parameters.Add("@FaceAngle14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@FaceHeight14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(8);
                Query.Parameters.Add("@FaceColumnNo14", SqlDbType.Int).Value = System.Convert.ToInt32(20);
                Query.Parameters.Add("@FaceColumnNoTolerance14", SqlDbType.Int).Value = System.Convert.ToInt32(0);
                Query.Parameters.Add("@ColumnAngle14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(90);
                Query.Parameters.Add("@ColumnAngleTolerance14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BasalPlaneAngle14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(30);
                Query.Parameters.Add("@BasalPlaneAngleTolerance14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@TopWaterLevel14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(28);
                Query.Parameters.Add("@TopWaterLevelTolerance14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngle14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngleTolerance14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@Blockiness14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BlockinessTolerance14", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@MaterialType14", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@FaceColumnNoDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@ColumnAngleDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BasalPlaneAngleDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@TopWaterLevelDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@WaterLevelAngleDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BlockinessDistribution14", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName15, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + "Typical Material 2'), @FaceAngle15, @FaceHeight15, @FaceColumnNo15, @FaceColumnNoTolerance15, @ColumnAngle15, @ColumnAngleTolerance15"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 1'), @BasalPlaneAngle15, @BasalPlaneAngleTolerance15, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + "Typical Joint 4'), @TopWaterLevel15, @TopWaterLevelTolerance15, @WaterLevelAngle15, @WaterLevelAngleTolerance15, @Blockiness15, @BlockinessTolerance15, @MaterialType15"
                    + ", @FaceColumnNoDistribution15, @ColumnAngleDistribution15, @BasalPlaneAngleDistribution15, @TopWaterLevelDistribution15, @WaterLevelAngleDistribution15, @BlockinessDistribution15)";
                Query.Parameters.Add("@SlopeName15", SqlDbType.NVarChar).Value = "Typical Slope 7";
                Query.Parameters.Add("@FaceAngle15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(35);
                Query.Parameters.Add("@FaceHeight15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(40);
                Query.Parameters.Add("@FaceColumnNo15", SqlDbType.Int).Value = System.Convert.ToInt32(10);
                Query.Parameters.Add("@FaceColumnNoTolerance15", SqlDbType.Int).Value = System.Convert.ToInt32(0);
                Query.Parameters.Add("@ColumnAngle15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(90);
                Query.Parameters.Add("@ColumnAngleTolerance15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BasalPlaneAngle15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(20);
                Query.Parameters.Add("@BasalPlaneAngleTolerance15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@TopWaterLevel15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(37);
                Query.Parameters.Add("@TopWaterLevelTolerance15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@WaterLevelAngle15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(5);
                Query.Parameters.Add("@WaterLevelAngleTolerance15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@Blockiness15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@BlockinessTolerance15", SqlDbType.Decimal).Value = System.Convert.ToDecimal(0);
                Query.Parameters.Add("@MaterialType15", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@FaceColumnNoDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@ColumnAngleDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BasalPlaneAngleDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@TopWaterLevelDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@WaterLevelAngleDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Parameters.Add("@BlockinessDistribution15", SqlDbType.NVarChar).Value = "Exact Value";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Name], [Horizontal Acceleration], [Horizontal Acceleration Tolerance]"
                    + ", [Vertical Acceleration], [Vertical Acceleration Tolerance], [Model Type], [Horizontal Acceleration Distribusion], [Vertical Acceleration Distribusion]"
                    + ") Values (@ModelName16, @HorizontalAcceleration16, @HorizontalAccelerationTolerance16, @VerticalAcceleration16, @VerticalAccelerationTolerance16"
                    + ", @ModelType_16, @HorizontalAccelerationDistribusion16, @VerticalAccelerationDistribusion16)";
                Query.Parameters.Add("@ModelName16", SqlDbType.NVarChar).Value = "Typical Model 1";
                Query.Parameters.Add("@HorizontalAcceleration16", SqlDbType.NVarChar).Value = "0.3";
                Query.Parameters.Add("@HorizontalAccelerationTolerance16", SqlDbType.NVarChar).Value = "0.05";
                Query.Parameters.Add("@VerticalAcceleration16", SqlDbType.NVarChar).Value = "0.3";
                Query.Parameters.Add("@VerticalAccelerationTolerance16", SqlDbType.NVarChar).Value = "0.05";
                Query.Parameters.Add("@ModelType_16", SqlDbType.NVarChar).Value = "Rock_Soil";
                Query.Parameters.Add("@HorizontalAccelerationDistribusion16", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@VerticalAccelerationDistribusion16", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Name], [Horizontal Acceleration], [Horizontal Acceleration Tolerance]"
                    + ", [Vertical Acceleration], [Vertical Acceleration Tolerance], [Model Type], [Horizontal Acceleration Distribusion], [Vertical Acceleration Distribusion]"
                    + ") Values (@ModelName17, @HorizontalAcceleration17, @HorizontalAccelerationTolerance17, @VerticalAcceleration17, @VerticalAccelerationTolerance17"
                    + ", @ModelType_17, @HorizontalAccelerationDistribusion17, @VerticalAccelerationDistribusion17)";
                Query.Parameters.Add("@ModelName17", SqlDbType.NVarChar).Value = "Typical Model 2";
                Query.Parameters.Add("@HorizontalAcceleration17", SqlDbType.NVarChar).Value = "0.3";
                Query.Parameters.Add("@HorizontalAccelerationTolerance17", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@VerticalAcceleration17", SqlDbType.NVarChar).Value = "0.3";
                Query.Parameters.Add("@VerticalAccelerationTolerance17", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@ModelType_17", SqlDbType.NVarChar).Value = "Rock";
                Query.Parameters.Add("@HorizontalAccelerationDistribusion17", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@VerticalAccelerationDistribusion17", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Name], [Horizontal Acceleration], [Horizontal Acceleration Tolerance]"
                    + ", [Vertical Acceleration], [Vertical Acceleration Tolerance], [Model Type], [Horizontal Acceleration Distribusion], [Vertical Acceleration Distribusion]"
                    + ") Values (@ModelName18, @HorizontalAcceleration18, @HorizontalAccelerationTolerance18, @VerticalAcceleration18, @VerticalAccelerationTolerance18"
                    + ", @ModelType_18, @HorizontalAccelerationDistribusion18, @VerticalAccelerationDistribusion18)";
                Query.Parameters.Add("@ModelName18", SqlDbType.NVarChar).Value = "Typical Model 3";
                Query.Parameters.Add("@HorizontalAcceleration18", SqlDbType.NVarChar).Value = "003";
                Query.Parameters.Add("@HorizontalAccelerationTolerance18", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@VerticalAcceleration18", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@VerticalAccelerationTolerance18", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@ModelType_18", SqlDbType.NVarChar).Value = "Soil";
                Query.Parameters.Add("@HorizontalAccelerationDistribusion18", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@VerticalAccelerationDistribusion18", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Name], [Horizontal Acceleration], [Horizontal Acceleration Tolerance]"
                    + ", [Vertical Acceleration], [Vertical Acceleration Tolerance], [Model Type], [Horizontal Acceleration Distribusion], [Vertical Acceleration Distribusion]"
                    + ") Values (@ModelName19, @HorizontalAcceleration19, @HorizontalAccelerationTolerance19, @VerticalAcceleration19, @VerticalAccelerationTolerance19"
                    + ", @ModelType_19, @HorizontalAccelerationDistribusion19, @VerticalAccelerationDistribusion19)";
                Query.Parameters.Add("@ModelName19", SqlDbType.NVarChar).Value = "Typical Model 4";
                Query.Parameters.Add("@HorizontalAcceleration19", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@HorizontalAccelerationTolerance19", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@VerticalAcceleration19", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@VerticalAccelerationTolerance19", SqlDbType.NVarChar).Value = "0";
                Query.Parameters.Add("@ModelType_19", SqlDbType.NVarChar).Value = "Soil_Rock";
                Query.Parameters.Add("@HorizontalAccelerationDistribusion19", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@VerticalAccelerationDistribusion19", SqlDbType.NVarChar).Value = "Uniform";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 1"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 1"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 2" + "'), @SequenceNo20)";
                Query.Parameters.Add("@SequenceNo20", SqlDbType.Int).Value = "1";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 1"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 2"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 3" + "'), @SequenceNo21)";
                Query.Parameters.Add("@SequenceNo21", SqlDbType.Int).Value = "2";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 2"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 3"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 5" + "'), @SequenceNo22)";
                Query.Parameters.Add("@SequenceNo22", SqlDbType.Int).Value = "1";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 2"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 4"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 5" + "'), @SequenceNo23)";
                Query.Parameters.Add("@SequenceNo23", SqlDbType.Int).Value = "2";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 3"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 5"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 3" + "'), @SequenceNo24)";
                Query.Parameters.Add("@SequenceNo24", SqlDbType.Int).Value = "1";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 3"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 6"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 3" + "'), @SequenceNo25)";
                Query.Parameters.Add("@SequenceNo25", SqlDbType.Int).Value = "2";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();


                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 4"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 7"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 5" + "'), @SequenceNo26)";
                Query.Parameters.Add("@SequenceNo26", SqlDbType.Int).Value = "1";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = 'Typical Model 4"
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = 'Typical Slope 4"
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = 'Typical Joint 5" + "'), @SequenceNo27)";
                Query.Parameters.Add("@SequenceNo27", SqlDbType.Int).Value = "2";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();
                Connection.Close();
            }
            catch
            {

            }
            RefreshModelName();
        }

        private void Activation_Request(
            string md, string ac, 
            string fry, string frm, string frd, 
            string lry, string lrm, string lrd)
        {
            bool ERR = false;
            bool trl = false;
            int day_remain = 0;
            int Com_Name_lngth = _De_Code_(_Code_(Com_Nam)).Length;
            int EXP_M_Length = 0;
            int ac_length = ac.Length;
            string EXP_Y = "", EXP_M = "", EXP_D = "";
            string Ac_Code = _De_Code_(ac);
            string A_C_Error = "";

            DateTime Now_Date = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);
            DateTime First_Run_Date = new DateTime(System.Convert.ToInt16(_De_Code_(fry)), System.Convert.ToInt16(_De_Code_(frm)), System.Convert.ToInt16(_De_Code_(frd)));
            DateTime Last_Run_Date = new DateTime(System.Convert.ToInt16(_De_Code_(lry)), System.Convert.ToInt16(_De_Code_(lrm)), System.Convert.ToInt16(_De_Code_(lrd)));
            DateTime EXP_Date = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);

            if (DateTime.Compare(Now_Date, Last_Run_Date) < 0 )
            {// system date change freek
                ERR = true;
                A_C_Error = "Activation failure (Code 112)";
            }
            else
            {
                SqlCommand Query = new SqlCommand();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Activation]";//read Activation information
                DataTable dt_Activation = new DataTable();
                dt_Activation.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Activation);

                Query.CommandText = "UPDATE [dbo].[Tbl_Activation] SET LRY = @LRY__, LRM = @LRM__, LRD = @LRD__ WHERE Id_Code = '"
                + System.Convert.ToString(dt_Activation.Rows[0].ItemArray[0]) + "'";
                Query.Parameters.Add("@LRY__", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Year));
                Query.Parameters.Add("@LRM__", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Month));
                Query.Parameters.Add("@LRD__", SqlDbType.NVarChar).Value = _Code_(System.Convert.ToString(DateTime.Now.Day));

                Query.Connection = Connection;
                Query.ExecuteNonQuery();
                Connection.Close();

            }
            if (_De_Code_(md) == "trial" && ERR == false)
            {
                day_remain = System.Convert.ToInt16(Now_Date.Subtract(First_Run_Date).TotalDays);
                if (day_remain > 14)
                {
                    ERR = true;
                    A_C_Error = "Trial period expired (Code 325)";
                }
                else
                {
                    if (14 - day_remain <= 1)
                    {
                        A_C_Error = "Only 1 day of trial period remaines. please enter valid activation code (Code 325)";
                        trl = true;
//                        MessageBox.Show(A_C_Error);
                        DialogResult msg_res = MessageBox.Show(A_C_Error, "Warning", MessageBoxButtons.OKCancel);
                        if (msg_res == DialogResult.OK)
                        {
                            ERR = true;
                            Pnl_Activation_Code.Visible = true;
                            Pnl_Activation_Code.BringToFront();
                            return;
                        }

                    }
                    else if (14 - day_remain > 1)
                    {
                        A_C_Error = "Only "+ (14 - day_remain).ToString() + " days of trial period remaines.  please enter valid activation code (Code 325)";
                        trl = true;
//                        MessageBox.Show(A_C_Error);
                        DialogResult msg_res = MessageBox.Show(A_C_Error, "Warning", MessageBoxButtons.OKCancel);
                        if (msg_res == DialogResult.OK)
                        {
                            ERR = true;
                            Pnl_Activation_Code.Visible = true;
                            Pnl_Activation_Code.BringToFront();
                            return;
                        }
                    }
                }
            }
            if(ERR == false)
            {
                if(Ac_Code.Substring(0, Com_Name_lngth) != _De_Code_(_Code_(Com_Nam)))
                {//activation code is not for this devise
                    ERR = true;
                    A_C_Error = "Activation failure (Code 726)";
                }
                else
                {
                    if(Ac_Code.Substring(Com_Name_lngth,1)!="y")
                    {
                        ERR = true;
                        A_C_Error = "Activation failure (Code 238)";
                    }
                    else
                    {
                        EXP_Y = Ac_Code.Substring(Com_Name_lngth + 1, 4);//find exp year
                        if (Ac_Code.Substring(Com_Name_lngth + 5, 1) != "m")
                        {
                            ERR = true;
                            A_C_Error = "Activation failure (Code 265)";
                        }
                        else
                        {
                            if(Ac_Code.Substring(Com_Name_lngth + 7, 1) == "d")
                            {
                                EXP_M = Ac_Code.Substring(Com_Name_lngth + 6, 1);//find exp month
                                EXP_M_Length = 1;
                            }
                            else if (Ac_Code.Substring(Com_Name_lngth + 8, 1) == "d")
                            {
                                EXP_M = Ac_Code.Substring(Com_Name_lngth + 6, 2);//find exp month
                                EXP_M_Length = 2;
                            }
                            else
                            {
                                ERR = true;
                                A_C_Error = "Activation failure (Code 429)";
                            }
                            if(ERR==false)
                            {
                                if (ac_length> Com_Name_lngth+3+4+ EXP_M_Length+2 || ac_length == Com_Name_lngth + 3 + 4 + EXP_M_Length)
                                {
                                    ERR = true;
                                    A_C_Error = "Activation failure (Code 533)";//wrong day
                                }
                                else
                                {
                                    EXP_D = Ac_Code.Substring(Com_Name_lngth + 7 + EXP_M_Length, ac_length - (Com_Name_lngth + 7 + EXP_M_Length));
                                }
                            }
                        }
                    }

                }
            }
            try
            {
                EXP_Date = new DateTime(System.Convert.ToInt16(EXP_Y), System.Convert.ToInt16(EXP_M), System.Convert.ToInt16(EXP_D));
                if (DateTime.Compare(EXP_Date, Now_Date) < 0)
                {
                    ERR = true;
                    A_C_Error = "Activation code expired (Code 153)";//wrong EXP_Date Format
                }
            }
            catch
            {
                ERR = true;
                A_C_Error = "Activation failure (Code 888)";//wrong EXP_Date Format
            }


            if (ERR == true && trl == false)
            {
                Pnl_Activation_Code.Visible = true;
                Pnl_Activation_Code.BringToFront();
                MessageBox.Show(A_C_Error);
                Activated_app = false;
            }
            else
            {
                if(Activated_app == false && trl == false)
                    MessageBox.Show("Topple2 Activated Successfully.");
                Pnl_Activation_Code.Visible = false;
            }


        }

        private string _Code_(string Input_S)
        {
            string Output_S = "";
            int input_Length = Input_S.Length;
            for(int i=0;i< input_Length;i++)
            {
                if (Input_S.Substring(i, 1) == "a" || Input_S.Substring(i, 1) == "A")
                    Output_S += "i";
                if (Input_S.Substring(i, 1) == "b" || Input_S.Substring(i, 1) == "B")
                    Output_S += "t";
                if (Input_S.Substring(i, 1) == "c" || Input_S.Substring(i, 1) == "C")
                    Output_S += "3";
                if (Input_S.Substring(i, 1) == "d" || Input_S.Substring(i, 1) == "D")
                    Output_S += "r";
                if (Input_S.Substring(i, 1) == "e" || Input_S.Substring(i, 1) == "E")
                    Output_S += "x";
                if (Input_S.Substring(i, 1) == "f" || Input_S.Substring(i, 1) == "F")
                    Output_S += "9";
                if (Input_S.Substring(i, 1) == "g" || Input_S.Substring(i, 1) == "G")
                    Output_S += "h";
                if (Input_S.Substring(i, 1) == "h" || Input_S.Substring(i, 1) == "H")
                    Output_S += "2";
                if (Input_S.Substring(i, 1) == "i" || Input_S.Substring(i, 1) == "I")
                    Output_S += "d";
                if (Input_S.Substring(i, 1) == "j" || Input_S.Substring(i, 1) == "J")
                    Output_S += "k";
                if (Input_S.Substring(i, 1) == "k" || Input_S.Substring(i, 1) == "K")
                    Output_S += "y";
                if (Input_S.Substring(i, 1) == "l" || Input_S.Substring(i, 1) == "L")
                    Output_S += "s";
                if (Input_S.Substring(i, 1) == "m" || Input_S.Substring(i, 1) == "M")
                    Output_S += "j";
                if (Input_S.Substring(i, 1) == "n" || Input_S.Substring(i, 1) == "N")
                    Output_S += "4";
                if (Input_S.Substring(i, 1) == "o" || Input_S.Substring(i, 1) == "O")
                    Output_S += "u";
                if (Input_S.Substring(i, 1) == "p" || Input_S.Substring(i, 1) == "P")
                    Output_S += "8";
                if (Input_S.Substring(i, 1) == "q" || Input_S.Substring(i, 1) == "Q")
                    Output_S += "l";
                if (Input_S.Substring(i, 1) == "r" || Input_S.Substring(i, 1) == "R")
                    Output_S += "n";
                if (Input_S.Substring(i, 1) == "s" || Input_S.Substring(i, 1) == "S")
                    Output_S += "7";
                if (Input_S.Substring(i, 1) == "t" || Input_S.Substring(i, 1) == "T")
                    Output_S += "b";
                if (Input_S.Substring(i, 1) == "u" || Input_S.Substring(i, 1) == "U")
                    Output_S += "v";
                if (Input_S.Substring(i, 1) == "v" || Input_S.Substring(i, 1) == "V")
                    Output_S += "6";
                if (Input_S.Substring(i, 1) == "w" || Input_S.Substring(i, 1) == "W")
                    Output_S += "m";
                if (Input_S.Substring(i, 1) == "x" || Input_S.Substring(i, 1) == "X")
                    Output_S += "c";
                if (Input_S.Substring(i, 1) == "y" || Input_S.Substring(i, 1) == "Y")
                    Output_S += "q";
                if (Input_S.Substring(i, 1) == "z" || Input_S.Substring(i, 1) == "Z")
                    Output_S += "e";
                if (Input_S.Substring(i, 1) == "0")
                    Output_S += "f";
                if (Input_S.Substring(i, 1) == "1")
                    Output_S += "0";
                if (Input_S.Substring(i, 1) == "2")
                    Output_S += "w";
                if (Input_S.Substring(i, 1) == "3")
                    Output_S += "a";
                if (Input_S.Substring(i, 1) == "4")
                    Output_S += "p";
                if (Input_S.Substring(i, 1) == "5")
                    Output_S += "o";
                if (Input_S.Substring(i, 1) == "6")
                    Output_S += "z";
                if (Input_S.Substring(i, 1) == "7")
                    Output_S += "1";
                if (Input_S.Substring(i, 1) == "8")
                    Output_S += "g";
                if (Input_S.Substring(i, 1) == "9")
                    Output_S += "5";
            }
            return Output_S;
        }

        private string _De_Code_(string Input_S)
        {
            string Output_S = "";
            int input_Length = Input_S.Length;
            for (int i = 0; i < input_Length; i++)
            {
                if (Input_S.Substring(i, 1) == "i")
                    Output_S += "a";
                if (Input_S.Substring(i, 1) == "t")
                    Output_S += "b";
                if (Input_S.Substring(i, 1) == "3")
                    Output_S += "c";
                if (Input_S.Substring(i, 1) == "r")
                    Output_S += "d";
                if (Input_S.Substring(i, 1) == "x")
                    Output_S += "e";
                if (Input_S.Substring(i, 1) == "9")
                    Output_S += "f";
                if (Input_S.Substring(i, 1) == "h")
                    Output_S += "g";
                if (Input_S.Substring(i, 1) == "2")
                    Output_S += "h";
                if (Input_S.Substring(i, 1) == "d")
                    Output_S += "i";
                if (Input_S.Substring(i, 1) == "k")
                    Output_S += "j";
                if (Input_S.Substring(i, 1) == "y")
                    Output_S += "k";
                if (Input_S.Substring(i, 1) == "s")
                    Output_S += "l";
                if (Input_S.Substring(i, 1) == "j")
                    Output_S += "m";
                if (Input_S.Substring(i, 1) == "4")
                    Output_S += "n";
                if (Input_S.Substring(i, 1) == "u")
                    Output_S += "o";
                if (Input_S.Substring(i, 1) == "8")
                    Output_S += "p";
                if (Input_S.Substring(i, 1) == "l")
                    Output_S += "q";
                if (Input_S.Substring(i, 1) == "n")
                    Output_S += "r";
                if (Input_S.Substring(i, 1) == "7")
                    Output_S += "s";
                if (Input_S.Substring(i, 1) == "b")
                    Output_S += "t";
                if (Input_S.Substring(i, 1) == "v")
                    Output_S += "u";
                if (Input_S.Substring(i, 1) == "6")
                    Output_S += "v";
                if (Input_S.Substring(i, 1) == "m")
                    Output_S += "w";
                if (Input_S.Substring(i, 1) == "c")
                    Output_S += "x";
                if (Input_S.Substring(i, 1) == "q")
                    Output_S += "y";
                if (Input_S.Substring(i, 1) == "e")
                    Output_S += "z";
                if (Input_S.Substring(i, 1) == "f")
                    Output_S += "0";
                if (Input_S.Substring(i, 1) == "0")
                    Output_S += "1";
                if (Input_S.Substring(i, 1) == "w")
                    Output_S += "2";
                if (Input_S.Substring(i, 1) == "a")
                    Output_S += "3";
                if (Input_S.Substring(i, 1) == "p")
                    Output_S += "4";
                if (Input_S.Substring(i, 1) == "o")
                    Output_S += "5";
                if (Input_S.Substring(i, 1) == "z")
                    Output_S += "6";
                if (Input_S.Substring(i, 1) == "1")
                    Output_S += "7";
                if (Input_S.Substring(i, 1) == "g")
                    Output_S += "8";
                if (Input_S.Substring(i, 1) == "5")
                    Output_S += "9";
            }
            return Output_S;
        }

        private void MainForm_SizeChanged(object sender, EventArgs e)
        {
            string Con_Strng = "";
            Size_set();
/*            Pnl_MaterialDefinition.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_SlopeDefinition.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_Joint.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_ExternalForces.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_NewModel.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_KinematicAnalysis.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_AnalyticalSolution.Size = new Size(this.Size.Width - 785, this.Size.Height - 100);
            Pnl_ProbabilisticAnalysis.Size = new Size(this.Size.Width - 22, this.Size.Height - 100);
            Pnl_DataBaseView.Size = new Size(this.Size.Width - 795, this.Size.Height - 100);
            Pnl_Refferences.Size = new Size(this.Size.Width - 22, this.Size.Height - 94);
            Pnl_ProbabilisticDeterminidtic_Chart.Size = new Size(this.Size.Width - 605, this.Size.Height - 105);
            Pnl_Probabilistic_Selection.Size = new Size(this.Size.Width - 978, this.Size.Height - 105);
            LstBx_Reff.Size = new Size(this.Size.Width - 25, this.Size.Height - 87);

            Pnl_Activation_Code.Size= new Size(this.Size.Width - 25, this.Size.Height - 87);


            DGVAnalytical_Output.Size = new Size(this.Size.Width - 795, this.Size.Height - 175);

            DGVProbabilisticResult.Left = Pnl_ProbabilisticDeterminidtic_Chart.Size.Width - 827;

            Pnl_ModelSketch.Size = new Size(this.Size.Width - 795, this.Size.Height - 100);

            ProgBar_ExcelExport.Size = new Size(this.Size.Width - 22, 15);
*/
            if (File.Exists(@"" + Instal_Dir + "\\Topple2_Database.mdf"))
            {
                Con_Strng = "Data Source = (LocalDB)\\MSSQLLocalDB;AttachDbFilename=" + Instal_Dir + "\\Topple2_Database.mdf" + ";Integrated Security = True";
                Connection = new SqlConnection(Con_Strng);
            }
            else
            {
                OpenFileDialog OPN_Fil_Dlg = new OpenFileDialog();
                OPN_Fil_Dlg.Title = "Select Database File";
                OPN_Fil_Dlg.Filter = "MDF files|*.mdf";
                OPN_Fil_Dlg.FileName = "Topple2_Database";
                OPN_Fil_Dlg.InitialDirectory = @"" + Instal_Dir;
                if (OPN_Fil_Dlg.ShowDialog() == DialogResult.OK)
                {
                    File.Copy(@"" + OPN_Fil_Dlg.FileName, @"" + Instal_Dir + "\\Topple2_Database.mdf", true);
                }
                Con_Strng = "Data Source = (LocalDB)\\MSSQLLocalDB;AttachDbFilename=" + Instal_Dir + "\\Topple2_Database.mdf" + ";Integrated Security = True";
                Connection = new SqlConnection(Con_Strng);
            }


            try
            {
                Connection.Open();
                Connection.Close();
            }
            catch
            {
                MessageBox.Show("Database server not found");
            }









//            Con_Strng = "Data Source = (LocalDB)\\MSSQLLocalDB;AttachDbFilename=E:\\CODE PROJECTS\\BCKUP\\TOTAL SLOPE WITH SQL DATABASE\\TOTAL SLOPE\\SLOPESDB.MDF" + ";Integrated Security = True";


//            Con_Strng = "Data Source=DESKTOP-KJEOGTT\\AKBARARDESTANI;Initial "
//            + "Catalog=TotalSlopeDB;Persist Security Info=True;User ID=TotalSlopeDB_Login;Password=TotalSlope";
//            Connection = new SqlConnection(Con_Strng);



            RefreshJointComboboxes();
            RefreshModelName();
            RefreshMaterial();
            RefreshSlope();
        }

        private void Size_set()
        {
            this.Size = Screen.PrimaryScreen.WorkingArea.Size;// maximize window at start up
            X_Form_Size = this.Size.Width - 25;//1024-->1040-->1014   1920--->1508-->1525
            Y_Form_Size = this.Size.Height - 100;//768-->744 -->645   1080--->884-->740

//////////////Set Menu sizes
            int Main_Menu_W= this.Size.Width-40;
            Pnl_MainMenu.Size = new Size(Main_Menu_W,50);
            int Menue_Left = 2;
            var Mnu_L = new Point(Menue_Left, 2);

            RadBtnMaterialDefinition.Location = Mnu_L;
            RadBtnMaterialDefinition.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.8d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.8d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnJointStudy.Location = Mnu_L;
            RadBtnJointStudy.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 8.4d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 8.4d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnSlopeDefinition.Location = Mnu_L;
            RadBtnSlopeDefinition.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnModelDefinition.Location = Mnu_L;
            RadBtnModelDefinition.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnExternalForces.Location = Mnu_L;
            RadBtnExternalForces.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnKinematicAnalysis.Location = Mnu_L;
            RadBtnKinematicAnalysis.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 10.5d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 10.5d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnAnalyticalSolution.Location = Mnu_L;
            RadBtnAnalyticalSolution.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.8d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.8d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnProbabilisticAnalysis.Location = Mnu_L;
            RadBtnProbabilisticAnalysis.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 16.8d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 16.8d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnDatabaseView.Location = Mnu_L;
            RadBtnDatabaseView.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d), 46);
            Menue_Left += 2 + System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 9.1d / 100d);
            Mnu_L = new Point(Menue_Left, 2);
            RadBtnRefferences.Location = Mnu_L;
            RadBtnRefferences.Size = new Size(System.Convert.ToInt16(System.Convert.ToDouble(Main_Menu_W) * 8.4d / 100d), 46);
            /////////////////////////////////////////////////////////////////////////////////////////////////
            var pnl_L = new Point(5, 55);
            var pnl_R = new Point(System.Convert.ToInt16((System.Convert.ToDouble(X_Form_Size) / 2d) + 2.5), 55);
            var pnl_TL = new Point(0, 0);
            int Pnl_W = System.Convert.ToInt16((System.Convert.ToDouble(X_Form_Size) / 2d) - 7.5d);
            /*            Pnl_MaterialDefinition.Location = pnl_L;
                        Pnl_MaterialDefinition.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_Joint.Location = pnl_L;
                        Pnl_Joint.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_SlopeDefinition.Location = pnl_L;
                        Pnl_SlopeDefinition.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_NewModel.Location = pnl_L;
                        Pnl_NewModel.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_ExternalForces.Location = pnl_L;
                        Pnl_ExternalForces.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_KinematicAnalysis.Location = pnl_L;
                        Pnl_KinematicAnalysis.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_AnalyticalSolution.Location = pnl_L;
                        Pnl_AnalyticalSolution.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_ProbabilisticAnalysis.Location = pnl_L;
                        Pnl_ProbabilisticAnalysis.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_ModelSketch.Location = pnl_R;
                        Pnl_ModelSketch.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_DataBaseView.Location = pnl_L;
                        Pnl_DataBaseView.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_Refferences.Location = pnl_L;
                        Pnl_Refferences.Size = new Size(Pnl_W, Y_Form_Size);
                        Pnl_Activation_Code.Location = pnl_L;
                        Pnl_Activation_Code.Size = new Size(Pnl_W, Y_Form_Size);
            */
            Pnl_MaterialDefinition.Location = pnl_L;
            Pnl_MaterialDefinition.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Sketch.Location = pnl_R;
            Pnl_Sketch.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Joint.Location = pnl_L;
            Pnl_Joint.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_SlopeDefinition.Location = pnl_L;
            Pnl_SlopeDefinition.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_ModelDefinittion.Location = pnl_L;
            Pnl_ModelDefinittion.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Kinematic.Location = pnl_L;
            Pnl_Kinematic.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_ForceDefinition.Location = pnl_L;
            Pnl_ForceDefinition.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Analys.Location = pnl_L;
            Pnl_Analys.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Activation_Code.Location = pnl_TL;
            Pnl_Activation_Code.Size = new Size(X_Form_Size+25, Y_Form_Size+100);
            Pnl_Refferences.Location = pnl_L;
            Pnl_Refferences.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_Database.Location = pnl_R;
            Pnl_Database.Size = new Size(X_Form_Size, Y_Form_Size);
            Pnl_ProbabilisticAnalysis.Location = pnl_L;
            Pnl_ProbabilisticAnalysis.Size = new Size(X_Form_Size, Y_Form_Size);
            //            Pnl_MaterialDefinition



        }

        private void ERROR_Material_DB()
        {
            double ThisV = 0, UpV = 0, DwnV = 0, ThisDev = 0, UpDev = 0, DwnDev = 0;
            SqlCommand Query = new SqlCommand();


            if (TxtBx_MaterialName.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill Material Name \n";
            }
            else if (TxtBx_MaterialName.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "Material Name Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material] Where [Material Name] = '"
                    + System.Convert.ToString(TxtBx_MaterialName.Text.Trim()) + "'";//read material information of slope
                DataTable dt_Material = new DataTable();
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();

                if (dt_Material.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Material Name' Is Repetitive \n";
                }
            }


            if (CmbBx_MaterialType.SelectedItem == null && System.Convert.ToString(CmbBx_MaterialType.Text) == "")
            {
                Error = true;
                ErrorString = ErrorString + "Please Select Material Type \n";
            }
            if (System.Convert.ToString(CmbBx_MaterialType.Text) != "Rock"
                && System.Convert.ToString(CmbBx_MaterialType.Text) != "Soil"
                && System.Convert.ToString(CmbBx_MaterialType.Text) != "BIM"
                && System.Convert.ToString(CmbBx_MaterialType.Text) != "")
            {
                Error = true;
                ErrorString = ErrorString + "Material Type is not Valid \n";
            }
            try
            {
                if (TxtBx_CohesiveStrength.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Cohesive Strength' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_CohesiveStrength.Text.Trim());
                UpV = 1000000000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Cohesive Strength' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Cohesive Strength' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_CohesiveStrength.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_CohesiveStrength_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Positive \n";
                        }
                        TxtBx_CohesiveStrength_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_CohesiveStrength_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Cohesive Strength' Must Be Numeric \n";
            }


            try
            {
                if (TxtBx_FrictionAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Friction Angle' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_FrictionAngle.Text.Trim());
                UpV = 90;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Friction Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Friction Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_FrictionAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_FrictionAngle_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_FrictionAngle_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_FrictionAngle_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Friction Angle' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_UnitWeight.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill Unit Weight \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_UnitWeight.Text.Trim());
                UpV = 10000000;
                DwnV = 1;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Unit Weight Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Unit Weight Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_UnitWeight.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_UnitWeight_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Unit Weight Deviation Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Unit Weight Deviation Must Be Positive \n";
                        }
                        else
                            TxtBx_UnitWeight_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_UnitWeight_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Unit Weight Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "Unit Weight Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_TensileStrength.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill Tensile Strength \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_TensileStrength.Text.Trim());
                UpV = 10000000000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Tensile Strength Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Tensile Strength Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_TensileStrength.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_TensileStrength_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Tensile Strength Deviation Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Tensile Strength Deviation Must Be Positive \n";
                        }
                        else
                            TxtBx_TensileStrength_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_TensileStrength_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Tensile Strength Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "Tensile Strength Must Be Numeric \n";
            }

            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_YoungModulus.Text.Trim());
                UpV = 10000000000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Young Modulus Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Young Modulus Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_YoungModulus.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_YoungModulus_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Young Modulus Deviation Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Young Modulus Deviation Must Be Positive \n";
                        }
                        else
                            TxtBx_YoungModulus_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_YoungModulus_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Young Modulus Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_YoungModulus.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Young Modulus Must Be Numeric \n";
                }
            }


            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_PoissonRatio.Text.Trim());
                UpV = 1;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Poisson Ratio Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Poisson Ratio Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_PoissonRatio.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_PoissonRatio_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Poisson Ratio Deviation Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Poisson Ratio Deviation Must Be Positive \n";
                        }
                        else
                            TxtBx_PoissonRatio_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_PoissonRatio_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Poisson Ratio Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_PoissonRatio.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Poisson Ratio Must Be Numeric \n";
                }
            }



            if (TxtBx_CohesiveStrength_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_CohesiveStrength_Dev.Text = "0";
                WarningString = WarningString + "\n'Cohesive Strength Deviation' Set to Zero ";
            }
            if (TxtBx_FrictionAngle_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_FrictionAngle_Dev.Text = "0";
                WarningString = WarningString + "\n'Friction Angle Deviation' Set to Zero ";
            }
            if (TxtBx_UnitWeight_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_UnitWeight_Dev.Text = "0";
                WarningString = WarningString + "\nUnit Weight Deviation Set to Zero ";
            }
            if (TxtBx_TensileStrength_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_TensileStrength_Dev.Text = "0";
                WarningString = WarningString + "\nTensile Strength Deviation Set to Zero ";
            }
            if (TxtBx_YoungModulus.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_YoungModulus.Text = "0";
                WarningString = WarningString + "\nYoung Modulus Set to Zero ";
            }
            if (TxtBx_YoungModulus_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_YoungModulus_Dev.Text = "0";
                WarningString = WarningString + "\nYoung Modulus Deviation Set to Zero ";
            }
            if (TxtBx_PoissonRatio.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_PoissonRatio.Text = "0";
                WarningString = WarningString + " \nPoisson Ratio Set to Zero";
            }
            if (TxtBx_PoissonRatio_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_PoissonRatio_Dev.Text = "0";
                WarningString = WarningString + " \nPoisson Ratio Deviation Set to Zero";
            }

            if (ComBx_CohesiveStrength_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "K"))
                ComBx_CohesiveStrength_Dist.SelectedItem = "Exact Value";
            if (ComBx_FrictionAngle_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "K"))
                ComBx_FrictionAngle_Dist.SelectedItem = "Exact Value";
            if (ComBx_UnitWeight_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "K"))
                ComBx_UnitWeight_Dist.SelectedItem = "Exact Value";
            if (ComBx_TensileStrength_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "K"))
                ComBx_TensileStrength_Dist.SelectedItem = "Exact Value";
        }

        private void Btn_AddMaterial_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Material Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_Material_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Material] ([Material Name], [Material Type], [Cohesive Strength], [Cohesive StrengthTolerance]"
                    + ", [Friction Angle], [Friction Angle_Tolerance], [Unit Weight], [Unit Weight Tolerance], [Tensile Strength]"
                    + ", [Tensile Strength Tolerance], [Young Modulus], [Young Modulus Tolerance], [Poisson Ratio], [Poisson Ratio Tolerance]"
                    + ", [Cohesive Strength Disrtibution], [Friction Angle Distribution], [Unit Weight Distribution], [Tensile Strength Distribution])"
                    + " VALUES (@MaterialName, @MaterialType, @CohesiveStrength, @CohesiveStrengthTolerance, @FrictionAngle, @FrictionAngleTolerance, @UnitWeight"
                    + ", @UnitWeightTolerance, @TensileStrength, @TensileStrengthTolerance, @YoungModulus, @YoungModulusTolerance, @PoissonRatio, @PoissonRatioTolerance"
                    + ", @CohesiveStrengthDisrtibution, @FrictionAngleDistribution, @UnitWeightDistribution, @TensileStrengthDistribution)";
                Query.Parameters.Add("@MaterialName", SqlDbType.NVarChar).Value = TxtBx_MaterialName.Text.Trim();
                Query.Parameters.Add("@MaterialType", SqlDbType.NVarChar).Value = CmbBx_MaterialType.SelectedItem;
                Query.Parameters.Add("@CohesiveStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_CohesiveStrength.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_CohesiveStrength_Dev.Text.Trim());
                Query.Parameters.Add("@FrictionAngle", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FrictionAngle.Text.Trim());
                Query.Parameters.Add("@FrictionAngleTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FrictionAngle_Dev.Text.Trim());
                Query.Parameters.Add("@UnitWeight", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_UnitWeight.Text.Trim());
                Query.Parameters.Add("@UnitWeightTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_UnitWeight_Dev.Text.Trim());
                Query.Parameters.Add("@TensileStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_TensileStrength.Text.Trim());
                Query.Parameters.Add("@TensileStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_TensileStrength_Dev.Text.Trim());
                Query.Parameters.Add("@YoungModulus", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_YoungModulus.Text.Trim());
                Query.Parameters.Add("@YoungModulusTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_YoungModulus_Dev.Text.Trim());
                Query.Parameters.Add("@PoissonRatio", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_PoissonRatio.Text.Trim());
                Query.Parameters.Add("@PoissonRatioTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_PoissonRatio_Dev.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthDisrtibution", SqlDbType.NVarChar).Value = ComBx_CohesiveStrength_Dist.SelectedItem;
                Query.Parameters.Add("@FrictionAngleDistribution", SqlDbType.NVarChar).Value = ComBx_FrictionAngle_Dist.SelectedItem;
                Query.Parameters.Add("@UnitWeightDistribution", SqlDbType.NVarChar).Value = ComBx_UnitWeight_Dist.SelectedItem;
                Query.Parameters.Add("@TensileStrengthDistribution", SqlDbType.NVarChar).Value = ComBx_TensileStrength_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshMaterial();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void ERROR_Model_DB()
        {
            double ThisV = 0, UpV = 0, DwnV = 0, ThisDev = 0, UpDev = 0, DwnDev = 0;
            SqlCommand Query = new SqlCommand();

            if (TxtBx_NewModelName.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill Model Name \n";
            }
            else if (TxtBx_NewModelName.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "Model Name Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '"
                    + System.Convert.ToString(TxtBx_NewModelName.Text.Trim()) + "'";//read model data and copy them to datatable
                DataTable dt_Model = new DataTable();
                dt_Model.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Model);
                Connection.Close();

                if (dt_Model.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Model Name' Is Repetitive \n";
                }
            }

            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_HorizontalAcceleration.Text.Trim());
                UpV = 200;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Horizontal Acceleration Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Horizontal Acceleration Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_HorizontalAcceleration.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_HorizontalAcceleration_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Horizontal Acceleration Deviation Must Be Less Than "
                                    + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Horizontal Acceleration Deviation Must Be Positive \n";
                        }
                        TxtBx_HorizontalAcceleration_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_HorizontalAcceleration_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Horizontal Acceleration Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_HorizontalAcceleration.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Horizontal Acceleratio Must Be Numeric \n";
                }
            }

            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_VerticalAcceleration.Text.Trim());
                UpV = 200;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Vertical Acceleration Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "Vertical Acceleration Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_VerticalAcceleration.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_VerticalAcceleration_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Vertical Acceleration Deviation Must Be Less Than "
                                    + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Vertical Acceleration Deviation Must Be Positive \n";
                        }
                        else
                            TxtBx_VerticalAcceleration_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_VerticalAcceleration_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "Vertical Acceleration Deviation Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_VerticalAcceleration.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Vertical Acceleration Must Be Numeric \n";
                }
            }

            if (TxtBx_HorizontalAcceleration.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_HorizontalAcceleration.Text = "0";
                WarningString = WarningString + "Horizontal Acceleration Set to Zero \n";
            }
            if (TxtBx_HorizontalAcceleration_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_HorizontalAcceleration_Dev.Text = "0";
                WarningString = WarningString + "Horizontal Acceleration Deviation Set to Zero \n";
            }
            if (TxtBx_VerticalAcceleration.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_VerticalAcceleration.Text = "0";
                WarningString = WarningString + "Vertical Acceleration Set to Zero \n";
            }
            if (TxtBx_VerticalAcceleration_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_VerticalAcceleration_Dev.Text = "0";
                WarningString = WarningString + "Vertical Acceleration Deviation Set to Zero \n";
            }
            if (ComBx_HorizontalAcceleration_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "K"))
                ComBx_HorizontalAcceleration_Dist.SelectedItem = "Exact Value";
            if (ComBx_VerticalAcceleration_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "K"))
                ComBx_VerticalAcceleration_Dist.SelectedItem = "Exact Value";
        }

        private void Btn_CreatModel_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Model Definition Succeed \n";
            SqlCommand Query = new SqlCommand();

            ERROR_Model_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Name], [Horizontal Acceleration], [Horizontal Acceleration Tolerance]"
                    + ", [Vertical Acceleration], [Vertical Acceleration Tolerance], [Horizontal Acceleration Distribusion], [Vertical Acceleration Distribusion]"
                    + ") Values (@ModelName, @HorizontalAcceleration, @HorizontalAccelerationTolerance, @VerticalAcceleration, @VerticalAccelerationTolerance"
                    + ", @HorizontalAccelerationDistribusion, @VerticalAccelerationDistribusion )";
                Query.Parameters.Add("@ModelName", SqlDbType.NVarChar).Value = TxtBx_NewModelName.Text;
                Query.Parameters.Add("@HorizontalAcceleration", SqlDbType.NVarChar).Value = TxtBx_HorizontalAcceleration.Text;
                Query.Parameters.Add("@HorizontalAccelerationTolerance", SqlDbType.NVarChar).Value = TxtBx_HorizontalAcceleration_Dev.Text;
                Query.Parameters.Add("@VerticalAcceleration", SqlDbType.NVarChar).Value = TxtBx_VerticalAcceleration.Text;
                Query.Parameters.Add("@VerticalAccelerationTolerance", SqlDbType.NVarChar).Value = TxtBx_VerticalAcceleration_Dev.Text;
                Query.Parameters.Add("@HorizontalAccelerationDistribusion", SqlDbType.NVarChar).Value = ComBx_HorizontalAcceleration_Dist.SelectedItem;
                Query.Parameters.Add("@VerticalAccelerationDistribusion", SqlDbType.NVarChar).Value = ComBx_VerticalAcceleration_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshModelName();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }

        }

        private void RadBtnSlopeDefinition_Click(object sender, EventArgs e)
        {
            if (SequenceList != null)
                Draw_Model();
        }

        private void RadBtnMaterialDefinition_CheckedChanged(object sender, EventArgs e)
        {
            if(Activated_app==false)
            {
                Pnl_MaterialDefinition.Visible = true;
                Pnl_Sketch.Visible = true;
                Pnl_Joint.Visible = false;
                Pnl_SlopeDefinition.Visible = false;
                Pnl_ModelDefinittion.Visible = false;
                Pnl_Kinematic.Visible = false;
                Pnl_ForceDefinition.Visible = false;
                Pnl_Analys.Visible = false;
                Pnl_Activation_Code.Visible = false;
                Pnl_Refferences.Visible = false;
                Pnl_Database.Visible = false;
                Pnl_ProbabilisticAnalysis.Visible = false;
                Pnl_MaterialDefinition.BringToFront();
                Pnl_Sketch.BringToFront();

                Btn_AddMaterial.Visible = true;

            }


            TxtBx_MaterialName.Text = "";
            CmbBx_MaterialType.Text = "";
            TxtBx_CohesiveStrength.Text = "";
            TxtBx_CohesiveStrength_Dev.Text = "";
            TxtBx_FrictionAngle.Text = "";
            TxtBx_FrictionAngle_Dev.Text = "";
            TxtBx_UnitWeight.Text = "";
            TxtBx_UnitWeight_Dev.Text = "";
            TxtBx_TensileStrength.Text = "";
            TxtBx_TensileStrength_Dev.Text = "";
            TxtBx_YoungModulus.Text = "";
            TxtBx_YoungModulus_Dev.Text = "";
            TxtBx_PoissonRatio.Text = "";
            TxtBx_PoissonRatio_Dev.Text = "";
            ComBx_CohesiveStrength_Dist.Text = "Exact Value";
            ComBx_FrictionAngle_Dist.Text = "Exact Value";
            ComBx_UnitWeight_Dist.Text = "Exact Value";
            ComBx_TensileStrength_Dist.Text = "Exact Value";
        }

        private void RadBtnSlopeDefinition_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = true;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_SlopeDefinition.BringToFront();
            Pnl_Sketch.BringToFront();

            Btn_DefineSlope.Visible = true;


            TxtBx_SlopeName.Text = "";
            TxtBx_FaceAngle.Text = "";
            TxtBx_FaceHeight.Text = "";
            TxtBx_FaceColumnNo.Text = "";
            TxtBx_FaceColumnNo_Dev.Text = "";
            TxtBx_ColumnAngle.Text = "";
            TxtBx_ColumnAngle_Dev.Text = "";
            TxtBx_BasalPlaneAngle.Text = "";
            TxtBx_BasalPlaneAngle_Dev.Text = "";
            TxtBx_TopWaterLevel.Text = "";
            TxtBx_TopWaterLevel_Dev.Text = "";
            TxtBx_WaterLevelAngle.Text = "";
            TxtBx_WaterLevelAngle_Dev.Text = "";
            TxtBx_ColumnBlockyness.Text = "";
            TxtBx_ColumnBlockyness_Dev.Text = "";
            ComBx_FaceColumnNo_Dist.Text = "Exact Value";
            ComBx_ColumnAngle_Dist.Text = "Exact Value";
            ComBx_BasalPlaneAngle_Dist.Text = "Exact Value";
            ComBx_TopWaterLevel_Dist.Text = "Exact Value";
            ComBx_WaterLevelAngle_Dist.Text = "Exact Value";
            ComBx_ColumnBlockyness_Dist.Text = "Exact Value";


        }

        private void RadBtnJointStudy_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = true;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_Joint.BringToFront();
            Pnl_Sketch.BringToFront();

            Btn_DefineJoint.Visible = true;

            TxtBx_JointName.Text = "";
            TxtBx_JointCohesiveStrength.Text = "";
            TxtBx_JointCohesiveStrength_Dev.Text = "";
            TxtBx_JointFrictionAngle.Text = "";
            TxtBx_JointFrictionAngle_Dev.Text = "";
            ComBx_JointCohesiveStrength_Dist.Text = "Exact Value";
            ComBx_JointFrictionAngle_Dist.Text = "Exact Value";


        }

        private void RadBtnExternalForces_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = true;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_ForceDefinition.BringToFront();
            Pnl_Sketch.BringToFront();


            Pnl_PointLoad.Visible = true;
            Pnl_UniformLoad.Visible = true;

            Btn_UniformLoad.Visible = true;
            Btn_PointLoad.Visible = true;


            TxtBx_ForceName_PointLoad.Text = "";
            TxtBx_HeighinFace_PointLoad.Text = "";
            TxtBx_Force_PointLoad.Text = "";
            TxtBx_ForceName_UniFormLoad.Text = "";
            TxtBx_FromHeighinFace_UniFormLoad.Text = "";
            TxtBx_ToHeighinFace_UniFormLoad.Text = "";
            TxtBx_Force_UniFormLoad.Text = "";



            RefreshSlope();
        }

        private void RadBtnModelDefinition_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = true;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_ModelDefinittion.BringToFront();
            Pnl_Sketch.BringToFront();

            Btn_AddSequence.Visible = true;
            Btn_CreatModel.Visible = true;
            Btn_DefineAnchor.Visible = true;

            Pnl_NewModelInput.Visible = true;
            Pnl_ModelSequenceInput.Visible = true;
            Pnl_AnchorInput.Visible = true;


            TxtBx_MdlNam.Visible = false;
            NumUpDwn_SeqNo.Visible = false;

            TxtBx_AnchorName.Text = "";
            TxtBx_AnchorHeight.Text = "";
            TxtBx_AnchorAngle.Text = "";
            TxtBx_AnchorLength.Text = "";
            TxtBx_AnchorForce.Text = "";
            TxtBx_AnchorYeild.Text = "";
            TxtBx_NewModelName.Text = "";
            TxtBx_HorizontalAcceleration.Text = "";
            TxtBx_HorizontalAcceleration_Dev.Text = "";
            TxtBx_VerticalAcceleration.Text = "";
            TxtBx_VerticalAcceleration_Dev.Text = "";
            ComBx_HorizontalAcceleration_Dist.Text = "Exact Value";
            ComBx_VerticalAcceleration_Dist.Text = "Exact Value";

            Refresh_ComBx_SequenceNo();
            RefreshSlope();

        }

        private void RadBtnKinematicAnalysis_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = true;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_Kinematic.BringToFront();
            Pnl_Sketch.BringToFront();
        }

        private void RadBtnAnalyticalSolution_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = true;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_Analys.BringToFront();
            Pnl_Sketch.BringToFront();

            DGVAnalytical_Output.Rows.Clear();
            DGVAnalytical_Output.DataSource = null;
            DGVAnalytical_Report.Rows.Clear();
            DGVAnalytical_Report.DataSource = null;



        }

        private void RadBtnAnalyticalSolution_Click(object sender, EventArgs e)
        {
            Pnl_Analys.Enabled = true;
            Pnl_AnalyticalSolution.Enabled = true;
            Pnl_Analys.Visible = true;
            Pnl_AnalyticalSolution.Visible = true;

            Excel_sheetNo = 0;
            Excel_Work = false;

            DGVAnalytical_Output.Rows.Clear();//reset master output grid
            DGVAnalytical_Output.DataSource = null;
            DGVAnalytical_Report.Rows.Clear();// reset report grid
            DGVAnalytical_Report.DataSource = null;
            DGVAnalytical_Report.Rows.Add();
            if (Submit_Flag == true)
            {
                Pnl_ModelDraw.Refresh();
                Total_Analytical_Critical_Situation_List.Clear();//Reset critical situation
                All_Model_Details.Clear();//reset saved details of models that have at least one column or slice unstable
                All_Arcs_List.Clear();

                Analytical_Calculation_General_Preparation();//find top coordination of all slices and columns and save all other definition detail of each
                Analytical_Solve();//find bottom of each column or slice and solve the model
                Draw_Model();
                Submit_Flag = false;
            }
            else
            {
                    Draw_Model();
            }
            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {
                Update_Result_DGV(0);
                Result_Visualizing(0);
            }

            Chk_Bx_Arcs.Enabled = true;
            Chk_Bx_Arcs.Visible = true;

            ///1            EXCEL_SequenceList_ModelDetail();
        }

        private void RadBtnProbabilisticAnalysis_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = false;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = true;
            Pnl_ProbabilisticAnalysis.BringToFront();

            Chk_Bx_Arcs.Checked = false;
            Chk_Bx_Arcs.Enabled = false;
            Chk_Bx_Arcs.Visible = false;

            DGVProbabilisticResult.Rows.Clear();
            DGVProbabilisticResult.Rows.Add();
        }

        private void RadBtnDatabaseView_CheckedChanged(object sender, EventArgs e)
        {
            if (RadBtnDatabaseView.Checked == true)
            {
                Pnl_MaterialDefinition.Visible = false;
                Pnl_Sketch.Visible = false;
                Pnl_Joint.Visible = false;
                Pnl_SlopeDefinition.Visible = false;
                Pnl_ModelDefinittion.Visible = false;
                Pnl_Kinematic.Visible = false;
                Pnl_ForceDefinition.Visible = false;
                Pnl_Analys.Visible = false;
                Pnl_Activation_Code.Visible = false;
                Pnl_Refferences.Visible = false;
                Pnl_Database.Visible = true;
                Pnl_ProbabilisticAnalysis.Visible = false;
                Pnl_Database.BringToFront();

                Btn_AddMaterial.Visible = false;

                Rad_Btn_DB_Material.Checked = true;

                Retrieve_Material_Data();
            }

        }

        private void RadBtnRefferences_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_Sketch.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ModelDefinittion.Visible = false;
            Pnl_Kinematic.Visible = false;
            Pnl_ForceDefinition.Visible = false;
            Pnl_Analys.Visible = false;
            Pnl_Activation_Code.Visible = false;
            Pnl_Refferences.Visible = true;
            Pnl_Database.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_Refferences.BringToFront();
        }

        private void Analytical_Calculation_General_Preparation()// first step in analytical calculation
        {
            int k = 0;//counters

            double Seq_Part_Bottom_Length = 0;
            double Seq_Part_Thickness = 0;

            int Column_Number = 0;

            double M_Column = 0;
            double M_Water = 0;

            double Seq_TopWater_X = 0;
            double Seq_TopWater_Y = 0;

            double M_c_p = 0, M_c = 0, X_A = 0, X_B = 0, Y_A = 0, Y_B = 0;

            if(Exact_Slip_Surfaces_FOS_flag == false || Analytical_Slice_Data.GetLength(0) != SliceNo)
            {
                Analytical_Slice_Data = new double[SliceNo, 80];
                Temp_Analytical_Slice_Data = new double[SliceNo, 80];
                Array.Clear(Temp_Analytical_Slice_Data, 0, Temp_Analytical_Slice_Data.Length);//clear previous data
                Array.Clear(Analytical_Slice_Data, 0, Analytical_Slice_Data.Length);//clear previous data
           }

            bool flag1 = true;

            for (int Seq_Counter = 1; Seq_Counter <= SequencesNo; Seq_Counter++)//in each slope from toe to crest (Rock and soil) calculate top of each and water level of each and top force of each and anchor of each
            {
                flag1 = true;
                if (Seq_Counter < SequencesNo)//for Soil_Rock Model
                    if (SequenceList[Seq_Counter - 1, 6] == "Soil" && SequenceList[Seq_Counter, 6] == "Rock")//in last soil slope in Soil_Rock model
                    {
                        Column_Number = System.Convert.ToInt32(SequenceList[Seq_Counter - 1, 21]) - 1;
                        flag1 = false;
                    }
                if (flag1 == true)
                    Column_Number = System.Convert.ToInt32(SequenceList[Seq_Counter - 1, 21]);

                flag1 = true;

                Seq_Part_Bottom_Length = (System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20]) / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) * Math.PI / 180d)
                    + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20]) / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23]) * Math.PI / 180d))
                    / System.Convert.ToDouble(Column_Number);//bottom length of each column or slice



                Seq_Part_Thickness = Seq_Part_Bottom_Length * Math.Sin(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23]) * Math.PI / 180d);//tickness of each block or slice

                M_Column = Math.Tan((180d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23])) * Math.PI / 180d);// dip of columns or Slices
                M_Water = Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 41]) * Math.PI / 180d);// dip of water level

                ///////////////////////////////////////////////////////////////////////////////to find coordinations of top of each slice/column
                for (int Slice_Counter = 1; Slice_Counter <= System.Convert.ToInt16(SequenceList[Seq_Counter - 1, 21]); Slice_Counter++)//each slice or block of this slope .... in rock or soil both
                {
                    flag1 = true;
                    if (k == 0)//set zero x y to toe of model
                    {
                        Analytical_Slice_Data[k, 0] = 0;//X of top left of slice
                        Analytical_Slice_Data[k, 1] = 0;//y of top left of slice
                    }
                    else if(k<=SliceNo)
                    {
                        Analytical_Slice_Data[k, 0] = Analytical_Slice_Data[k - 1, 4];//X of top left of slice
                        Analytical_Slice_Data[k, 1] = Analytical_Slice_Data[k - 1, 5];//y of top left of slice
                    }
                    if (Slice_Counter == 1)//calculate top right level of water at first slice or column of each slope
                    {
                        Seq_TopWater_Y = Analytical_Slice_Data[k, 1] + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20]);//top of this slope Y
                        Seq_TopWater_X = Analytical_Slice_Data[k, 0] + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20])
                            / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) * Math.PI / 180d);// top of this slope x

                        Seq_TopWater_X += System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 39])
                            / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23]) * Math.PI / 180d);//top of water level in this slope X
                        Seq_TopWater_Y -= System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 39]);//top of water level in this slope Y
                        if (Seq_Counter < SequencesNo)//for Soil_Rock Model
                            if (SequenceList[Seq_Counter - 1, 6] == "Soil" && SequenceList[Seq_Counter, 6] == "Rock")//in last soil slope
                            {
                                Seq_TopWater_X = (Analytical_Slice_Data[k, 0] + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20])
                                    / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) * Math.PI / 180d)) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 39])
                                    / Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter, 23]) * Math.PI / 180d);//top of water level in this slope X
                            }
                    }

                    if (Seq_Counter < SequencesNo)//for Soil_Rock Model
                        if (SequenceList[Seq_Counter - 1, 6] == "Soil" && SequenceList[Seq_Counter, 6] == "Rock" && Slice_Counter == System.Convert.ToInt16(SequenceList[Seq_Counter - 1, 21]))//in the case af adding triangular element
                        {
                            flag1 = false;
                            for (int i = 0; i < 80; i++)
                                Analytical_Slice_Data[k, i] = Analytical_Slice_Data[k - 1, i];

                            Analytical_Slice_Data[k, 0] = Analytical_Slice_Data[k, 4];
                            Analytical_Slice_Data[k, 1] = Analytical_Slice_Data[k, 5];

                            Analytical_Slice_Data[k, 12] = Analytical_Slice_Data[k - 1, 16];// X of top left of water line in slice
                            Analytical_Slice_Data[k, 13] = Analytical_Slice_Data[k - 1, 17];// y of top left of water line in slice

                            Analytical_Slice_Data[k, 16] = Seq_TopWater_X;// X of top right of water line in slice
                            Analytical_Slice_Data[k, 17] = Seq_TopWater_Y;// y of top right of water line in slice

                            Analytical_Slice_Data[k, 14] = (Analytical_Slice_Data[k, 12] + Analytical_Slice_Data[k, 16]) / 2;// X of middle of water line in slice
                            Analytical_Slice_Data[k, 15] = (Analytical_Slice_Data[k, 13] + Analytical_Slice_Data[k, 17]) / 2;// y of middle of water line in slice

                            if (Analytical_Slice_Data[k, 13] > Analytical_Slice_Data[k, 1])//water level correction if surface line is under water line
                            {
                                Analytical_Slice_Data[k, 12] = Analytical_Slice_Data[k, 0];// X of top left of water line in slice
                                Analytical_Slice_Data[k, 13] = Analytical_Slice_Data[k, 1];// y of top left of water line in slice
                            }
                            if (Analytical_Slice_Data[k, 17] > Analytical_Slice_Data[k, 5])//water level correction if surface line is under water line
                            {
                                Analytical_Slice_Data[k, 16] = Analytical_Slice_Data[k, 4];// X of top left of water line in slice
                                Analytical_Slice_Data[k, 17] = Analytical_Slice_Data[k, 5];// y of top left of water line in slice
                            }


                            Analytical_Slice_Data[k, 43] = 0;//thichness
                            Analytical_Slice_Data[k, 46]++;//this column no in this slope from 1 to column no or slice no
                            Analytical_Slice_Data[k, 47]++;//column or slice No from toe  in all model from 1 to all column and slices no
                        }

                    if (flag1 == true)
                    {
                        Analytical_Slice_Data[k, 4] = Analytical_Slice_Data[k, 0] + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20])
                            / (System.Convert.ToDouble(Column_Number) * Math.Tan(System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) * Math.PI / 180d));//X of top right of slice
                        Analytical_Slice_Data[k, 5] = Analytical_Slice_Data[k, 1] + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20])
                            / (System.Convert.ToDouble(Column_Number));//Y of top right of slice

                        Analytical_Slice_Data[k, 2] = (Analytical_Slice_Data[k, 0] + Analytical_Slice_Data[k, 4]) / 2d;//X of middle of top of slice
                        Analytical_Slice_Data[k, 3] = (Analytical_Slice_Data[k, 1] + Analytical_Slice_Data[k, 5]) / 2d;//Y of middle of top of slice
                        if (System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23]) == 90)
                        {
                            Analytical_Slice_Data[k, 12] = Analytical_Slice_Data[k, 0];// X of top left of water line in slice
                            Analytical_Slice_Data[k, 13] = M_Water * (Analytical_Slice_Data[k, 12] - Seq_TopWater_X) + Seq_TopWater_Y;// y of top left of water line in slice

                            Analytical_Slice_Data[k, 16] = Analytical_Slice_Data[k, 4];// X of top left of water line in slice
                            Analytical_Slice_Data[k, 17] = M_Water * (Analytical_Slice_Data[k, 12] - Seq_TopWater_X) + Seq_TopWater_Y;// y of top left of water line in slice
                        }
                        else
                        {
                            Analytical_Slice_Data[k, 12] = (M_Column * Analytical_Slice_Data[k, 0] - M_Water * Seq_TopWater_X
                                + Seq_TopWater_Y - Analytical_Slice_Data[k, 1]) / (M_Column - M_Water);// X of top left of water line in slice
                            Analytical_Slice_Data[k, 13] = M_Column * (Analytical_Slice_Data[k, 12] - Analytical_Slice_Data[k, 0])
                                + Analytical_Slice_Data[k, 1];// y of top left of water line in slice

                            Analytical_Slice_Data[k, 16] = (M_Column * Analytical_Slice_Data[k, 4] - M_Water * Seq_TopWater_X
                                + Seq_TopWater_Y - Analytical_Slice_Data[k, 5]) / (M_Column - M_Water);// X of top right of water line in slice
                            Analytical_Slice_Data[k, 17] = M_Column * (Analytical_Slice_Data[k, 16] - Analytical_Slice_Data[k, 4]) + Analytical_Slice_Data[k, 5];// y of top right of water line in slice
                        }
                        Analytical_Slice_Data[k, 14] = (Analytical_Slice_Data[k, 12] + Analytical_Slice_Data[k, 16]) / 2;// X of middle of water line in slice
                        Analytical_Slice_Data[k, 15] = (Analytical_Slice_Data[k, 13] + Analytical_Slice_Data[k, 17]) / 2;// y of middle of water line in slice

                        if (Analytical_Slice_Data[k, 13] > Analytical_Slice_Data[k, 1])//water level correction if surface line is under water line
                        {
                            Analytical_Slice_Data[k, 12] = Analytical_Slice_Data[k, 0];// X of top left of water line in slice
                            Analytical_Slice_Data[k, 13] = Analytical_Slice_Data[k, 1];// y of top left of water line in slice
                        }
                        if (Analytical_Slice_Data[k, 17] > Analytical_Slice_Data[k, 5])//water level correction if surface line is under water line
                        {
                            Analytical_Slice_Data[k, 16] = Analytical_Slice_Data[k, 4];// X of top left of water line in slice
                            Analytical_Slice_Data[k, 17] = Analytical_Slice_Data[k, 5];// y of top left of water line in slice
                        }
                        ///////////////////////////////////////////////////////////////////////
                        if (SequenceList[Seq_Counter - 1, 6] == "Rock")
                            Analytical_Slice_Data[k, 29] = 1;//1 means rock
                        if (SequenceList[Seq_Counter - 1, 6] == "Soil")
                            Analytical_Slice_Data[k, 29] = 2;//2 means Soil
                        if (SequenceList[Seq_Counter - 1, 6] == "BIM")
                            Analytical_Slice_Data[k, 29] = 3;// 3 means BIM
                        Analytical_Slice_Data[k, 30] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 7]);//material c
                        Analytical_Slice_Data[k, 31] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 8]);//material c Deviation
                        Analytical_Slice_Data[k, 32] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 9]);//material phi
                        Analytical_Slice_Data[k, 33] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 10]);//material phi Deviation
                        Analytical_Slice_Data[k, 34] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 11]);//material Unit weight
                        Analytical_Slice_Data[k, 35] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 12]);//material Unit weight Deviation
                        Analytical_Slice_Data[k, 36] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 13]);//material tensile strength
                        Analytical_Slice_Data[k, 37] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 14]);//material tensile strength Deviation
                        Analytical_Slice_Data[k, 38] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 15]);//material E
                        Analytical_Slice_Data[k, 39] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 16]);//material E Deviation
                        Analytical_Slice_Data[k, 40] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 17]);//material nuw
                        Analytical_Slice_Data[k, 41] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 18]);//material nuw Deviation
                        Analytical_Slice_Data[k, 42] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]);//face Angle
                        Analytical_Slice_Data[k, 43] = Seq_Part_Thickness;//thichness
                        Analytical_Slice_Data[k, 44] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 21]);//slope column No or slice No
                        Analytical_Slice_Data[k, 45] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 22]);//slope column No or slice No Deviation
                        Analytical_Slice_Data[k, 46] = Slice_Counter;//this column no in this slope from 1 to column no or slice no
                        Analytical_Slice_Data[k, 47] = k + 1;//column or slice No from toe  in all model from 1 to all column and slices no
                        Analytical_Slice_Data[k, 48] = Seq_Counter;//sequence no from 1
                        Analytical_Slice_Data[k, 49] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23]);//column angle
                        Analytical_Slice_Data[k, 50] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 24]);//column angle Deviation
                        Analytical_Slice_Data[k, 51] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 27]);//column joint c
                        Analytical_Slice_Data[k, 52] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 28]);//column joint c Deviation
                        Analytical_Slice_Data[k, 53] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29]);//column joint phi
                        Analytical_Slice_Data[k, 54] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 30]);//column joint phi Deviation
                        Analytical_Slice_Data[k, 55] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 31]);//basal angle
                        Analytical_Slice_Data[k, 56] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 32]);//basal angle Deviation
                        Analytical_Slice_Data[k, 57] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 35]);//basal joint c
                        Analytical_Slice_Data[k, 58] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 36]);//basal joint c Deviation
                        Analytical_Slice_Data[k, 59] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 37]);//basal joint phi
                        Analytical_Slice_Data[k, 60] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 38]);//basal joint phi Deviation
                        Analytical_Slice_Data[k, 61] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 45]);//right sequence interaction joint c
                        Analytical_Slice_Data[k, 62] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 46]);//right sequence interaction joint c Deviation
                        Analytical_Slice_Data[k, 63] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 47]);//right sequense interaction joint phi
                        Analytical_Slice_Data[k, 64] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 48]);//right sequense interaction joint phi Deviation
                        Analytical_Slice_Data[k, 65] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 49]);//Slope Blockiness
                        Analytical_Slice_Data[k, 66] = System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 50]);//Slope Blockiness Deviation

                        if (ModelDetail[7] == "Rock")
                            Analytical_Slice_Data[k, 68] = 1;//Model Type = rock (main)
                        if (ModelDetail[7] == "Soil")
                            Analytical_Slice_Data[k, 68] = 2;//Model Type = Soil
                        if (ModelDetail[7] == "Rock_Soil")
                            Analytical_Slice_Data[k, 68] = 3;//Model Type = Rock Soil (Secondary)
                        if (ModelDetail[7] == "Soil_Rock")
                            Analytical_Slice_Data[k, 68] = 4;//Model Type = Soil Rock
                        if (ModelDetail[7] == "BIM")
                            Analytical_Slice_Data[k, 68] = 5;//Model Type = BIM

                        Analytical_Slice_Data[k, 69] = 0;//right force
                        Analytical_Slice_Data[k, 70] = 0;//left force
                        Analytical_Slice_Data[k, 71] = 0;//right force Angle
                        Analytical_Slice_Data[k, 72] = 0;//left force Angle
                        Analytical_Slice_Data[k, 73] = 0;//right force height
                        Analytical_Slice_Data[k, 74] = 0;//left force height
                        Analytical_Slice_Data[k, 79] = 0;//failure mode( 0 = stable, 1= slide, 2= Topple, 3=flexure, 4= shear , 5= unstable soil, 6= out of range)
                    }

                    if (Analytical_Slice_Data[k, 29] == 1 && SteppedSurface == true)
                    {
                        M_c = Math.Tan((180d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 23])) * Math.PI / 180d);
                        M_c_p = -1d / M_c;
                        X_A = Analytical_Slice_Data[k, 0];
                        Y_A = Analytical_Slice_Data[k, 1];
                        X_B = Analytical_Slice_Data[k, 4];
                        Y_B = Analytical_Slice_Data[k, 5];
                        Analytical_Slice_Data[k, 0] = (Y_B - Y_A + M_c * X_A - M_c_p * X_B) / (M_c - M_c_p);
                        Analytical_Slice_Data[k, 1] = Y_B + M_c_p * (Analytical_Slice_Data[k, 0] - X_B);
                    }


                    k++;//slice or block counter
                }
                ///////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////forces
                Apply_External_forces(Seq_Counter, k, System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20]), System.Convert.ToDouble(Column_Number));//apply dead loads on top of slices or columns
                //////////////////////////////////////Anchors
                Apply_Anchors(Seq_Counter, k, System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 20]), System.Convert.ToDouble(Column_Number));//apply all anchors force to right blocks or columns
            }
            //            Excelcheck(0, SliceNo - 1, 0, 79, 1, 1, 1, 1000);
        }

        private void Analytical_Calculation_Bottom_Rock_Data_Preparation(int FromNo, int ToNo)// first step in analytical calculation
        {
            int k = 0;//counters
            int blocky_counter = 0;
            int k0 = 0;//number of block that calculationg of blockyness at that slope start from

            double X1 = 0, X2 = 0, X3 = 0, Y1 = 0, Y2 = 0, Y3 = 0, M_B = 0, M_c = 0, M_b = 0;

            //            for (int i = 0; i < SliceNo; i++)
            //                Analytical_Slice_Data[i, 67] = 0;
            Reset_Analytical_Data_Array(FromNo, ToNo);

            if (ToNo > FromNo)//for rock model or Rock soil model
            {

                if (SteppedSurface == true)
                {
                    M_c = Math.Tan((180d - Analytical_Slice_Data[FromNo, 49]) * Math.PI / 180d);
                    M_B = Math.Tan(Analytical_Slice_Data[FromNo, 42] * Math.PI / 180d);
                    X1 = Analytical_Slice_Data[FromNo, 0];
                    Y1 = Analytical_Slice_Data[FromNo, 1];
                    X2 = Analytical_Slice_Data[FromNo, 4];
                    Y2 = Analytical_Slice_Data[FromNo, 5];
                    X1 = (Y2 - Y1 + M_c * X1 - M_B * X2) / (M_c - M_B);
                    Y1 = Y2 + M_B * (X1 - X2);
                }
                else
                {
                    X1 = Analytical_Slice_Data[FromNo, 0];//X coordination of start of basal plain 
                    Y1 = Analytical_Slice_Data[FromNo, 1];//Y coordination of start of basal plain 
                }

                M_B = Math.Tan(Analytical_Slice_Data[FromNo, 55] * Math.PI / 180d);//dip of basal plane
                M_b = Math.Tan((90d - Analytical_Slice_Data[FromNo, 49] + base_Rock_breakage_angle) * Math.PI / 180d);//dip of crack angle at bottom of each column

                for (int Slice_Counter = 0; Slice_Counter < SliceNo; Slice_Counter++)
                {
                    if ((Slice_Counter < FromNo || Slice_Counter >= ToNo) && Analytical_Slice_Data[Slice_Counter, 29] == 1)
                    {
                        Analytical_Slice_Data[k, 6] = Analytical_Slice_Data[k, 0];
                        Analytical_Slice_Data[k, 7] = Analytical_Slice_Data[k, 1];
                        Analytical_Slice_Data[k, 8] = Analytical_Slice_Data[k, 2];
                        Analytical_Slice_Data[k, 9] = Analytical_Slice_Data[k, 3];
                        Analytical_Slice_Data[k, 10] = Analytical_Slice_Data[k, 4];
                        Analytical_Slice_Data[k, 11] = Analytical_Slice_Data[k, 5];
                        Analytical_Slice_Data[k, 18] = 0;//Block right height
                        Analytical_Slice_Data[k, 19] = 0;//block middle height
                        Analytical_Slice_Data[k, 20] = 0;//block left height
                        Analytical_Slice_Data[k, 21] = 0;//WR height
                        Analytical_Slice_Data[k, 22] = 0;//WM height
                        Analytical_Slice_Data[k, 23] = 0;//WL Height
                        Analytical_Slice_Data[k, 24] = 0;//Block Weight
                        Analytical_Slice_Data[k, 55] = 0;//Basal angle
                        Analytical_Slice_Data[k, 67] = 0;//Blocky

                    }
                    else if (Analytical_Slice_Data[Slice_Counter, 29] == 1)
                    {
                        X2 = Analytical_Slice_Data[k, 0];//XTL
                        Y2 = Analytical_Slice_Data[k, 1];//YTL
                        M_c = Math.Tan((180d - System.Convert.ToDouble(Analytical_Slice_Data[k, 49])) * Math.PI / 180d);
                        Analytical_Slice_Data[k, 6] = (Y1 - Y2 + M_c * X2 - M_B * X1) / (M_c - M_B);//XBL
                        Analytical_Slice_Data[k, 7] = M_B * (Analytical_Slice_Data[k, 6] - X1) + Y1;//YBL
                        if (Analytical_Slice_Data[k, 7] > Analytical_Slice_Data[k, 1])
                        {
                            Analytical_Slice_Data[k, 6] = Analytical_Slice_Data[k, 0];
                            Analytical_Slice_Data[k, 7] = Analytical_Slice_Data[k, 1];
                        }


                        if (k > 0)
                            if (Analytical_Slice_Data[k, 48] != Analytical_Slice_Data[k - 1, 48])
                            {
                                X1 = Analytical_Slice_Data[k, 6];//X coordination of start of basal plain
                                Y1 = Analytical_Slice_Data[k, 7];//Y coordination of start of basal plain
                                M_B = Math.Tan(Analytical_Slice_Data[k, 55] * Math.PI / 180d);//dip of basal plane
                                M_b = Math.Tan((90d - Analytical_Slice_Data[k, 49] + base_Rock_breakage_angle) * Math.PI / 180d);//dip of crack angle at bottom of each column
                            }
                        X2 = Analytical_Slice_Data[k, 4];
                        Y2 = Analytical_Slice_Data[k, 5];
                        X3 = Analytical_Slice_Data[k, 6];
                        Y3 = Analytical_Slice_Data[k, 7];


                        Analytical_Slice_Data[k, 10] = (Y2 - Y3 + M_b * X3 - M_c * X2) / (M_b - M_c);//XBR
                        Analytical_Slice_Data[k, 11] = M_c * (Analytical_Slice_Data[k, 10] - X2) + Y2;//YBR
                        if (Analytical_Slice_Data[k, 11] > Analytical_Slice_Data[k, 5])
                        {
                            Analytical_Slice_Data[k, 10] = Analytical_Slice_Data[k, 4];
                            Analytical_Slice_Data[k, 11] = Analytical_Slice_Data[k, 5];
                        }
                        Analytical_Slice_Data[k, 8] = (Analytical_Slice_Data[k, 6] + Analytical_Slice_Data[k, 10]) / 2d;//X of middle of base of slice
                        Analytical_Slice_Data[k, 9] = (Analytical_Slice_Data[k, 7] + Analytical_Slice_Data[k, 11]) / 2d;//Y of middle of base of slice

                        Analytical_Slice_Data[k, 18] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 4] - Analytical_Slice_Data[k, 10], 2)
                            + Math.Pow(Analytical_Slice_Data[k, 5] - Analytical_Slice_Data[k, 11], 2));//block right height
                        Analytical_Slice_Data[k, 20] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 0] - Analytical_Slice_Data[k, 6], 2)
                            + Math.Pow(Analytical_Slice_Data[k, 1] - Analytical_Slice_Data[k, 7], 2));//block left height
                        Analytical_Slice_Data[k, 19] = (Analytical_Slice_Data[k, 18] + Analytical_Slice_Data[k, 20]) / 2;//block mean height

                        Analytical_Slice_Data[k, 21] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 16] - Analytical_Slice_Data[k, 10], 2)
                            + Math.Pow(Analytical_Slice_Data[k, 17] - Analytical_Slice_Data[k, 11], 2));//water right height
                        Analytical_Slice_Data[k, 23] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 12] - Analytical_Slice_Data[k, 6], 2)
                            + Math.Pow(Analytical_Slice_Data[k, 13] - Analytical_Slice_Data[k, 7], 2));//water left height

                        if (Analytical_Slice_Data[k, 17] < Analytical_Slice_Data[k, 11])//if water level is under basal plane
                            Analytical_Slice_Data[k, 21] = 0;
                        if (Analytical_Slice_Data[k, 13] < Analytical_Slice_Data[k, 7])//if water level is under basal plane
                            Analytical_Slice_Data[k, 23] = 0;

                        Analytical_Slice_Data[k, 22] = (Analytical_Slice_Data[k, 21] + Analytical_Slice_Data[k, 23]) / 2;//water mean height

                        Analytical_Slice_Data[k, 24] = Analytical_Slice_Data[k, 43] * Analytical_Slice_Data[k, 19] * Analytical_Slice_Data[k, 34];//block weight (newton)

                        if (Analytical_Slice_Data[k, 46] == 1 || k == FromNo)
                        {
                            blocky_counter = 0;
                            k0 = k;
                        }

                        if ((System.Convert.ToDouble(k - k0 + 1) * Analytical_Slice_Data[k, 65] / 100d) - System.Convert.ToDouble(blocky_counter) >= 1)
                        {
                            Analytical_Slice_Data[k, 67] = 1;//0=Flexural and 1 = Blocky
                            blocky_counter++;
                        }
                        else
                        {
                            Analytical_Slice_Data[k, 67] = 0;//0=Flexural and 1 = Blocky
                        }
                    }

                    k++;
                }
            }
            else if (ToNo < FromNo)// in Soil_Rock Model
            {
                k = SliceNo - 1;

                X1 = Analytical_Slice_Data[FromNo - 1, 4];//X coordination of start of basal plain 
                Y1 = Analytical_Slice_Data[FromNo - 1, 5];//Y coordination of start of basal plain 
                M_B = Math.Tan(Analytical_Slice_Data[FromNo - 1, 55] * Math.PI / 180d);//dip of basal plane
                M_b = Math.Tan((90d - Analytical_Slice_Data[FromNo - 1, 49] + base_Rock_breakage_angle) * Math.PI / 180d);//dip of crack angle at bottom of each column
                blocky_counter = 0;
                k0 = FromNo - 1;


                for (int Slice_Counter = SliceNo; Slice_Counter > ToNo; Slice_Counter--)//find Bottom of each rocky column from top to intersection of soil and Rock
                {
                    if (Slice_Counter > FromNo)//Out of range column at top of model
                    {
                        Analytical_Slice_Data[k, 6] = Analytical_Slice_Data[k, 0];
                        Analytical_Slice_Data[k, 7] = Analytical_Slice_Data[k, 1];
                        Analytical_Slice_Data[k, 10] = Analytical_Slice_Data[k, 4];
                        Analytical_Slice_Data[k, 11] = Analytical_Slice_Data[k, 5];
                        //                        Analytical_Slice_Data[k, 67] = 0;
                    }//set height of this columns to 0
                    else
                    {
                        if (k < SliceNo - 1)
                            if (Analytical_Slice_Data[k, 48] != Analytical_Slice_Data[k + 1, 48])
                            {//to change direction of travelling throw bottom of Blocks By change of Slope
                                X1 = Analytical_Slice_Data[k + 1, 6];//X coordination of start of basal plain 
                                Y1 = Analytical_Slice_Data[k + 1, 7];//Y coordination of start of basal plain 
                                M_B = Math.Tan(Analytical_Slice_Data[k, 55] * Math.PI / 180d);//dip of basal plane
                                M_b = Math.Tan((90d - Analytical_Slice_Data[k, 49] + base_Rock_breakage_angle) * Math.PI / 180d);//dip of crack angle at bottom of each column
                                blocky_counter = 0;
                                k0 = k;
                            }
                        X2 = Analytical_Slice_Data[k, 0];//XTL
                        Y2 = Analytical_Slice_Data[k, 1];//YTL
                        M_c = Math.Tan((180d - System.Convert.ToDouble(Analytical_Slice_Data[k, 49])) * Math.PI / 180d);

                        Analytical_Slice_Data[k, 6] = (Y1 - Y2 + M_c * X2 - M_B * X1) / (M_c - M_B);//XBL
                        Analytical_Slice_Data[k, 7] = M_B * (Analytical_Slice_Data[k, 6] - X1) + Y1;//YBL
                        if (Analytical_Slice_Data[k, 7] > Analytical_Slice_Data[k, 1])// if basal plane is upper tham top of column
                        {
                            Analytical_Slice_Data[k, 6] = Analytical_Slice_Data[k, 0];
                            Analytical_Slice_Data[k, 7] = Analytical_Slice_Data[k, 1];
                        }

                        X2 = Analytical_Slice_Data[k, 4];//XTL
                        Y2 = Analytical_Slice_Data[k, 5];//YTL


                        X3 = Analytical_Slice_Data[k, 6];//XBL
                        Y3 = Analytical_Slice_Data[k, 7];//YBL

                        Analytical_Slice_Data[k, 10] = (Y2 - Y3 + M_b * X3 - M_c * X2) / (M_b - M_c);//XBR
                        Analytical_Slice_Data[k, 11] = M_c * (Analytical_Slice_Data[k, 10] - X2) + Y2;//YBR
                        if (Analytical_Slice_Data[k, 11] > Analytical_Slice_Data[k, 5])// if basal plane is upper tham top of column
                        {
                            Analytical_Slice_Data[k, 10] = Analytical_Slice_Data[k, 4];
                            Analytical_Slice_Data[k, 11] = Analytical_Slice_Data[k, 5];
                        }

                        if ((System.Convert.ToDouble(k0 - k + 1) * Analytical_Slice_Data[k, 65] / 100d) - System.Convert.ToDouble(blocky_counter) > 0)
                        {
                            Analytical_Slice_Data[k, 67] = 1;//0=Flexural and 1 = Blocky
                            blocky_counter++;
                        }
                        else
                            Analytical_Slice_Data[k, 67] = 0;//0=Flexural and 1 = Blocky
                    }

                    Analytical_Slice_Data[k, 8] = (Analytical_Slice_Data[k, 6] + Analytical_Slice_Data[k, 10]) / 2d;//X of middle of base of slice
                    Analytical_Slice_Data[k, 9] = (Analytical_Slice_Data[k, 7] + Analytical_Slice_Data[k, 11]) / 2d;//Y of middle of base of slice

                    Analytical_Slice_Data[k, 18] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 4] - Analytical_Slice_Data[k, 10], 2)
                        + Math.Pow(Analytical_Slice_Data[k, 5] - Analytical_Slice_Data[k, 11], 2));//block right height
                    Analytical_Slice_Data[k, 20] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 0] - Analytical_Slice_Data[k, 6], 2)
                        + Math.Pow(Analytical_Slice_Data[k, 1] - Analytical_Slice_Data[k, 7], 2));//block left height
                    Analytical_Slice_Data[k, 19] = (Analytical_Slice_Data[k, 18] + Analytical_Slice_Data[k, 20]) / 2;//block mean height

                    Analytical_Slice_Data[k, 21] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 16] - Analytical_Slice_Data[k, 10], 2)
                        + Math.Pow(Analytical_Slice_Data[k, 17] - Analytical_Slice_Data[k, 11], 2));//water right height
                    Analytical_Slice_Data[k, 23] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[k, 12] - Analytical_Slice_Data[k, 6], 2)
                        + Math.Pow(Analytical_Slice_Data[k, 13] - Analytical_Slice_Data[k, 7], 2));//water left height

                    if (Analytical_Slice_Data[k, 17] < Analytical_Slice_Data[k, 11])//if water level is under basal plane
                        Analytical_Slice_Data[k, 21] = 0;
                    if (Analytical_Slice_Data[k, 13] < Analytical_Slice_Data[k, 7])//if water level is under basal plane
                        Analytical_Slice_Data[k, 23] = 0;

                    Analytical_Slice_Data[k, 22] = (Analytical_Slice_Data[k, 21] + Analytical_Slice_Data[k, 23]) / 2;//water mean height

                    Analytical_Slice_Data[k, 24] = Analytical_Slice_Data[k, 43] * Analytical_Slice_Data[k, 19] * Analytical_Slice_Data[k, 34];//block weight (newton)
                    k--;
                }
            }
        }

        private void Reset_Analytical_Data_Array(int FromNo, int ToNo)
        {
            for (int i = FromNo; i < ToNo; i++)
            {
                Analytical_Slice_Data[i, 6] = 0;
                Analytical_Slice_Data[i, 7] = 0;
                Analytical_Slice_Data[i, 8] = 0;
                Analytical_Slice_Data[i, 9] = 0;
                Analytical_Slice_Data[i, 10] = 0;
                Analytical_Slice_Data[i, 11] = 0;
                Analytical_Slice_Data[i, 18] = 0;
                Analytical_Slice_Data[i, 19] = 0;
                Analytical_Slice_Data[i, 20] = 0;
                Analytical_Slice_Data[i, 21] = 0;
                Analytical_Slice_Data[i, 22] = 0;
                Analytical_Slice_Data[i, 23] = 0;
                Analytical_Slice_Data[i, 24] = 0;
                Analytical_Slice_Data[i, 67] = 0;
                Analytical_Slice_Data[i, 69] = 0;
                Analytical_Slice_Data[i, 70] = 0;
                Analytical_Slice_Data[i, 71] = 0;
                Analytical_Slice_Data[i, 72] = 0;
                Analytical_Slice_Data[i, 73] = 0;
                Analytical_Slice_Data[i, 74] = 0;
                Analytical_Slice_Data[i, 75] = 0;
                Analytical_Slice_Data[i, 76] = 0;
                Analytical_Slice_Data[i, 77] = 0;
                Analytical_Slice_Data[i, 78] = 0;
                Analytical_Slice_Data[i, 79] = 0;
            }
        }

        private void Reset_Critical_Data_Array(int FromNo, int ToNo)
        {
            for (int i = FromNo; i < ToNo; i++)
            {
                for (int j = 0; j < 19; j++)
                    Analytical_Critical_Situation[i, j] = null;
            }
        }

        private void Analytical_Solve()
        {
            string msg_bx = "";
            //            Excel_sheetNo = 0;
            try
            {
                Num_UpDwn_CriticalNo.Enabled = false;
            }
            catch
            {

            }
            Analytical_Critical_Situation = new string[SliceNo + 1, 19];
            Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data

            Analytical_Critical_Situation[0, 0] = "0";//why?
            ///////////////////////////////////////////////////////////////////////////////////////
            if (Analytical_Slice_Data[0, 68] == 1)//Rock model
            {
                if (Exact_Surfase == false)
                    All_Slip_Surface_FOS.Clear();
                Solve_Rock_Model();
            }
            //////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (Analytical_Slice_Data[0, 68] == 3)//Rock_Soil model
                Solve_Rock_Soil_Model();
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (Analytical_Slice_Data[0, 68] == 2)//Soil model
            {
                if (Exact_Surfase == false)
                    All_Slip_Surface_FOS.Clear();
                Solve_Soil_Model();
            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (Analytical_Slice_Data[0, 68] == 4)//Soil_Rock model
                Solve_Soil_Rock_Model();

            if (RadBtnProbabilisticAnalysis.Checked == false)
            {
                if (Total_Analytical_Critical_Situation_List.Count == 0)
                {
                    msg_bx = "No Unstable Plain Detected.";
                    Num_UpDwn_CriticalNo.Maximum = 0;
                    Num_UpDwn_CriticalNo.Minimum = 0;
                    Num_UpDwn_CriticalNo.Value = 0;
                    if (ModelDetail[7] == "Rock")
                        fill_DGW_Result_for_Fully_Stabled_RockSlopes();
                }
                if (Total_Analytical_Critical_Situation_List.Count == 1 && fully_Stable_flag == false)
                {
                    msg_bx = System.Convert.ToString(Total_Analytical_Critical_Situation_List.Count) + " Plain Has Detected With at Least One Unstable Column";
                    Num_UpDwn_CriticalNo.Maximum = 1;
                    Num_UpDwn_CriticalNo.Minimum = 1;
                    Num_UpDwn_CriticalNo.Value = 1;
                }
                if (Total_Analytical_Critical_Situation_List.Count > 1 && fully_Stable_flag == false)
                {
                    msg_bx = System.Convert.ToString(Total_Analytical_Critical_Situation_List.Count) + " Plains Has Detected With at Least One Unstable Column";
                    Num_UpDwn_CriticalNo.Maximum = Total_Analytical_Critical_Situation_List.Count;
                    Num_UpDwn_CriticalNo.Minimum = 1;
                    Num_UpDwn_CriticalNo.Value = 1;
                }
                MessageBox.Show(msg_bx);
                Num_UpDwn_CriticalNo.Enabled = true;
            }
            if (((ModelDetail[7] == "Soil" || ModelDetail[7] == "Rock") && RadBtnAnalyticalSolution.Checked == true && fully_Stable_flag == false) || (ModelDetail[7] == "Soil" && Rad_Btn_Start_Probabilistic.Checked == true) )
                Sort_Critical_Situations_InSoilModelAndRockModel();
            else
                Sort_Critical_Situations();

        }

        private void fill_DGW_Result_for_Fully_Stabled_RockSlopes()
        {
            int FromNo = SliceNo;
            int ToNo = 0;
            int UpNo = 0;
            int DwnNo = 0;

            Analytical_Calculation_General_Preparation();//find top coordination of all slices and columns and save all other definition detail of each
            Analytical_Calculation_Bottom_Rock_Data_Preparation(0, SliceNo);//from toe to crest
            Rock_Analytical_Solve(SliceNo, 0);//from crest to toe


            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
            {
                Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 1)
                    Analytical_Critical_Situation[Slice_Counter, 1] = "Rock";
                if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)
                    Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";
                if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 3)
                    Analytical_Critical_Situation[Slice_Counter, 1] = "BIM";
                //                        Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 72]);//Left Force Angle
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 0)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Stable";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 1)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Slide";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 2)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Topple";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 3)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Flexur";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 4)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Shear";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 5)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Unstable";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 6)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                if (Slice_Counter <= FromNo && Slice_Counter > ToNo)
                {
                    Analytical_Critical_Situation[Slice_Counter, 2] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 19]);//column Height
                    Analytical_Critical_Situation[Slice_Counter, 3] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 24]);//column Weight
                    if (Analytical_Critical_Situation[Slice_Counter, 1] == "Rock")
                    {
                        Analytical_Critical_Situation[Slice_Counter, 4] = System.Convert.ToString(90 - Analytical_Slice_Data[Slice_Counter - 1, 49] + base_Rock_breakage_angle);//Basal Angle
                        Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(0);//Left Force Angle
                    }
                    else if (Analytical_Critical_Situation[Slice_Counter, 1] == "Soil")
                    {
                        Analytical_Critical_Situation[Slice_Counter, 4] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 55]);//Basal Angle
                        Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 72]);//Left Force Angle
                    }

                    Analytical_Critical_Situation[Slice_Counter, 5] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 75]);//Sliding force
                    Analytical_Critical_Situation[Slice_Counter, 6] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 76]);//Toppling Force
                    Analytical_Critical_Situation[Slice_Counter, 7] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 77]);//Flrxur force
                    Analytical_Critical_Situation[Slice_Counter, 8] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 78]);//shear force
                    Analytical_Critical_Situation[Slice_Counter, 9] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 70]);//Left Force
                    Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 74]);//Left Force Height
                    if (Slice_Counter == 1 && System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)
                        Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d);


                    Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                }
                else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == Analytical_Slice_Data[FromNo - 1, 29])
                {
                    Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 1)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "Rock";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 3)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "BIM";

                    Analytical_Critical_Situation[Slice_Counter, 2] = "-----";//column Height
                    Analytical_Critical_Situation[Slice_Counter, 3] = "-----";//column Weight
                    Analytical_Critical_Situation[Slice_Counter, 4] = "-----";//Basal Angle
                    Analytical_Critical_Situation[Slice_Counter, 11] = "-----";//Left Force Angle

                    Analytical_Critical_Situation[Slice_Counter, 5] = "-----";//Sliding force
                    Analytical_Critical_Situation[Slice_Counter, 6] = "-----";//Toppling Force
                    Analytical_Critical_Situation[Slice_Counter, 7] = "-----";//Flrxur force
                    Analytical_Critical_Situation[Slice_Counter, 8] = "-----";//shear force
                    Analytical_Critical_Situation[Slice_Counter, 9] = "-----";//Left Force
                    Analytical_Critical_Situation[Slice_Counter, 10] = "-----";//Left Force Height

                    Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                    Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                }
            }


            if (Analytical_Slice_Data[ToNo, 70] > 0)
                Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
            else
                Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
            {
                if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                {
                    if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                    {
                        Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                        Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                        Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                        Slice_Counter = 0;//to exit loop
                    }
                    else if (Slice_Counter == 1)
                    {
                        Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                        Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                        Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                    }
                }
            }
            Analytical_Critical_Situation[0, 4] = "-----";//Circular failure plain Radius
            Analytical_Critical_Situation[0, 5] = "-----";
            Analytical_Critical_Situation[0, 6] = "-----";
            Analytical_Critical_Situation[0, 7] = "-----";
            Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
            Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
            Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);
            Analytical_Critical_Situation[0, 11] = "-----";//Tension Crack Step



            Total_Analytical_Critical_Situation_List.Add(Save_Critical_Table_List());//save all critical situation
            All_Model_Details.Add(Save_Table_All_Model_Detai());//save all information of this situation to list


            fully_Stable_flag = true;

        }

        private void Solve_Soil_Rock_Model()
        {
            int Total_Soil_Slice = 0;
            int jj = 0;
            Total_Soil_Slice = 0;

            for (int Seq_Counter = 1; Seq_Counter <= SequencesNo; Seq_Counter++)//to Count total Soil Slice
            {
                if (SequenceList[Seq_Counter - 1, 6] == "Soil")
                    Total_Soil_Slice += System.Convert.ToInt32(SequenceList[Seq_Counter - 1, 21]);//count Rock column No
            }


            for (int FromNo = SliceNo; FromNo > Total_Soil_Slice; FromNo--)//to change tension crack point 
            {
                Analytical_Calculation_Bottom_Rock_Data_Preparation(FromNo, Total_Soil_Slice);//from toe to crest
                Rock_Analytical_Solve(FromNo, Total_Soil_Slice);//from crest to toe
                Critical_Situation_Registration(FromNo, Total_Soil_Slice, FromNo, Total_Soil_Slice);
                if (RadBtnProbabilisticAnalysis.Checked == true)//for FOS Calculation
                    jj = 1;
                else
                    jj = Total_Soil_Slice - 1;

                for (int j = 0; j < jj; j++)//to move toe situation
                {
                    Soil_Analytical_Solve(Total_Soil_Slice, j, Analytical_Slice_Data[0, 49], FromNo, j, 0, Tention_Crack_StepsNo, 360, 0);

                    for (int i = 1; i <= SliceNo; i++)
                    {
                        if (Analytical_Critical_Situation[i, 9] != "-----")
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[i, 9]) > 0)
                            {
                                Total_Analytical_Critical_Situation_List.Add(Save_Critical_Table_List());//save all critical situation
                                All_Model_Details.Add(Save_Table_All_Model_Detai());//save all information of this situation to list
                                Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data
                                i = SliceNo + 1;
                            }
                    }
                }
            }
        }

        private void Solve_Soil_Model()
        {
//            int jj = 0;
            int from_limit1 = 0;
            int from_limit2 = 0;
            int to_limit1 = 0;
            int to_limit2 = 0;
            int from_arc = 0;
            int to_arc = 0;
            int T_C_from = 0;
            int T_C_to = 0;
            string[,] temp_SequenceList = new string[SequenceList.GetLength(0), SequenceList.GetLength(1)];

            if (Exact_Surfase == true)
            {
                from_limit1 = Exact_from;
                from_limit2 = Exact_from - 1;
                to_limit1 = Exact_to - 1;
                to_limit2 = Exact_to;
                from_arc = Exact_arc;
                to_arc = Exact_arc - 1;
                T_C_from = Exact_TC;
                T_C_to = Exact_TC;
            }
            else
            {
                from_limit1 = SliceNo;
                from_limit2 = 2;
                to_limit1 = 0;
                to_limit2 = 0;
                from_arc = 360;
                to_arc = 0;
                T_C_from = 0;
                T_C_to = Tention_Crack_StepsNo;
            }


            for (int FromNo = from_limit1; FromNo > from_limit2; FromNo--)//to move tension crack situation
            {
                if (Exact_Surfase == false)
                    to_limit2 = FromNo - 2;

                for (int ToNo = to_limit1; ToNo < to_limit2; ToNo++)//to move toe situation
                {
                    Soil_Analytical_Solve(FromNo, ToNo, Analytical_Slice_Data[0, 49], FromNo, ToNo, T_C_from, T_C_to, from_arc, to_arc);

                    for (int i = 1; i <= SliceNo; i++)
                    {
                        if (Analytical_Critical_Situation[i, 9] != "-----")
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[i, 9]) > 0)
                            {
                                Total_Analytical_Critical_Situation_List.Add(Save_Critical_Table_List());//save all critical situation
                                All_Model_Details.Add(Save_Table_All_Model_Detai());//save all information of this situation to list
                                if (Exact_Surfase == false && (RadBtnAnalyticalSolution.Checked == true || Rad_Btn_Start_Probabilistic.Checked == true || Rad_Btn_Sensitivity_Analysis.Checked == true))
                                {
                                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                            temp_SequenceList[RowCounter, ClmCounter] = SequenceList[RowCounter, ClmCounter];
                                    for (int RowCounter = 0; RowCounter < Analytical_Slice_Data.GetLength(0); RowCounter++)
                                        for (int ClmCounter = 0; ClmCounter < Analytical_Slice_Data.GetLength(1); ClmCounter++)
                                            Temp_Analytical_Slice_Data[RowCounter, ClmCounter] = Analytical_Slice_Data[RowCounter, ClmCounter];

                                    FOS_Value = 1;
                                    Exact_Slip_Surfaces_FOS_flag = true;
                                    Find_FOS_on_All_Slip_Surfaces_in_Soli(temp_SequenceList,ToNo + 1);
                                }
                                Exact_Slip_Surfaces_FOS_flag = false;
                                Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data
                                i = SliceNo + 1;
//                                    this_is_Worst_Case_Ever = false;
                            }
                    }
                }
            }
        }

        private void Find_FOS_on_All_Slip_Surfaces_in_Soli(string[,] temp_SequenceList, int ToNmbr)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";

            Exact_from = System.Convert.ToInt32(Analytical_Critical_Situation[0, 9]);
            Exact_to = System.Convert.ToInt32(Analytical_Critical_Situation[0, 10]);
            Exact_arc = System.Convert.ToInt32(Analytical_Critical_Situation[0, 5]);
            Exact_TC = System.Convert.ToInt32(Analytical_Critical_Situation[0, 11]);
            Exact_Surfase = true;

            if (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0)//stable
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                is_Stable = false;
                FOS_Step = -0.1;
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Analytical_Critical_Situation [ToNmbr, 12] == "Stable")//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 9]) * Math.PI / 180d) / FOS_Value) * 180d / Math.PI);
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 7]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) <= 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) <= 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        Analytical_Calculation_General_Preparation();//find top coordination of all slices and columns and save all other definition detail of each
                        Solve_Soli_on_Exact_Slip_Surface();
                    }
                }
            }

            All_Slip_Surface_FOS.Add(Math.Round(FOS_Value,3));

            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                    SequenceList[RowCounter, ClmCounter] = temp_SequenceList[RowCounter, ClmCounter];
            for (int RowCounter = 0; RowCounter < Analytical_Slice_Data.GetLength(0); RowCounter++)
                for (int ClmCounter = 0; ClmCounter < Analytical_Slice_Data.GetLength(1); ClmCounter++)
                    Analytical_Slice_Data[RowCounter, ClmCounter] = Temp_Analytical_Slice_Data[RowCounter, ClmCounter];
            Exact_Surfase = false;
        }

        private void Solve_Soli_on_Exact_Slip_Surface()
        {
            //            int jj = 0;
            int from_limit1 = 0;
            int from_limit2 = 0;
            int to_limit1 = 0;
            int to_limit2 = 0;
            int from_arc = 0;
            int to_arc = 0;
            int T_C_from = 0;
            int T_C_to = 0;

            from_limit1 = Exact_from;
            from_limit2 = Exact_from - 1;
            to_limit1 = Exact_to - 1;
            to_limit2 = Exact_to;
            from_arc = Exact_arc;
            to_arc = Exact_arc - 1;
            T_C_from = Exact_TC;
            T_C_to = Exact_TC;

            for (int FromNo = from_limit1; FromNo > from_limit2; FromNo--)//to move tension crack situation
                for (int ToNo = to_limit1; ToNo < to_limit2; ToNo++)//to move toe situation
                    Soil_Analytical_Solve(FromNo, ToNo, Analytical_Slice_Data[0, 49], FromNo, ToNo, T_C_from, T_C_to, from_arc, to_arc);
        }

        private void Solve_Rock_Soil_Model()
        {
            int Total_Rock_Slice = 0;
            int jj = 0;
            Total_Rock_Slice = 0;
            for (int Seq_Counter = 1; Seq_Counter <= SequencesNo; Seq_Counter++)//to Count total Rock Slice
            {
                if (SequenceList[Seq_Counter - 1, 6] == "Rock")
                    Total_Rock_Slice += System.Convert.ToInt32(SequenceList[Seq_Counter - 1, 21]);//count Rock column No
            }
            if (RadBtnProbabilisticAnalysis.Checked == true)//for FOS Calculation
                jj = 1;
            else
                jj = Total_Rock_Slice;

            for (int RockTo = 0; RockTo < jj; RockTo++)//to change toe point from toe to interaction of rock and soil
            {
                Unstable_Found = false;
                Reset_Critical_Data_Array(0, SliceNo);
                Reset_Analytical_Data_Array(0, Total_Rock_Slice);


                Analytical_Calculation_Bottom_Rock_Data_Preparation(RockTo, Total_Rock_Slice);//from toe to crest of rock slope --> calculate bottom of slices and other related data
                for (int j = SliceNo; j > Total_Rock_Slice + 1; j--)//to move tension crack situation
                {
                    Reset_Analytical_Data_Array(Total_Rock_Slice, SliceNo);//to set all bottom slice data and height and weight , ... , force to zero
                    Soil_Analytical_Solve(j, Total_Rock_Slice, Analytical_Slice_Data[0, 49], j, RockTo, 0, Tention_Crack_StepsNo, 360, 0);
                    Rock_Analytical_Solve(Total_Rock_Slice, RockTo);
                    Critical_Situation_Registration(j, RockTo, j, RockTo);
                    for (int i = 1; i <= SliceNo; i++)
                    {
                        if (Unstable_Found == true)
                        {
                            if (Analytical_Critical_Situation[i, 9] != "-----" && Analytical_Critical_Situation[i, 9] != null)
                                if (System.Convert.ToDouble(Analytical_Critical_Situation[i, 9]) > 0)
                                {
                                    Total_Analytical_Critical_Situation_List.Add(Save_Critical_Table_List());//save all critical situation
                                    All_Model_Details.Add(Save_Table_All_Model_Detai());//save all information of this situation to list
/*                                    if(Rad_Btn_Sensitivity_Analysis.Checked==true)
                                        EXCEL_Analytical_Critical_Situation();
*/
                                    Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data
                                                                                                                        //                                    Excelcheck(Total_Analytical_Critical_Situation_List.Count);
                                    i = SliceNo + 1;
                                }
                        }
                    }
                }
            }
        }

        private void Solve_Rock_Model()
        {
            string[,] temp_SequenceList = new string[SequenceList.GetLength(0), SequenceList.GetLength(1)];
            int jj = 0;
            if (RadBtnProbabilisticAnalysis.Checked == true)//for FOS Calculation
                jj = 1;
            else
                jj = SliceNo - 1;

            for (int i = 0; i < jj; i++)//to change toe
            {
                Analytical_Calculation_Bottom_Rock_Data_Preparation(i, SliceNo);//from toe to crest
                Rock_Analytical_Solve(SliceNo, i);//from crest to toe
                Critical_Situation_Registration(SliceNo, i, i, i);

                if (this_is_Worst_Case_Ever == true)
                {
                    Total_Analytical_Critical_Situation_List.Add(Save_Critical_Table_List());//save all critical situation
                    All_Model_Details.Add(Save_Table_All_Model_Detai());//save all information of this situation to list

                    if (Exact_Surfase == false)
                    {
                        for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                            for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                temp_SequenceList[RowCounter, ClmCounter] = SequenceList[RowCounter, ClmCounter];
                        for (int RowCounter = 0; RowCounter < Analytical_Slice_Data.GetLength(0); RowCounter++)
                            for (int ClmCounter = 0; ClmCounter < Analytical_Slice_Data.GetLength(1); ClmCounter++)
                                Temp_Analytical_Slice_Data[RowCounter, ClmCounter] = Analytical_Slice_Data[RowCounter, ClmCounter];

                        FOS_Value = 1;
                        Exact_Slip_Surfaces_FOS_flag = true;
                        Find_FOS_on_All_Slip_Surfaces_in_Rock(temp_SequenceList, i + 1);
                    }
                    Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data
                    this_is_Worst_Case_Ever = false;
                }
            }
        }

        private void Find_FOS_on_All_Slip_Surfaces_in_Rock(string[,] temp_SequenceList, int ToNmbr)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";

            if (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0)//stable
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                is_Stable = false;
                FOS_Step = -0.1;
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Analytical_Critical_Situation[ToNmbr, 12] == "Stable")//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Analytical_Critical_Situation[ToNmbr, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);

                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 90 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }

                    }
                    if (FOS_Text != "Error")
                    {
                        Analytical_Calculation_General_Preparation();//find top coordination of all slices and columns and save all other definition detail of each
                        Rock_Analytical_Solve(SliceNo, ToNmbr - 1);//from crest to toe
                        Array.Clear(Analytical_Critical_Situation, 0, Analytical_Critical_Situation.Length);//clear previous data
                        this_is_Worst_Case_Ever = false;
                        Critical_Situation_Registration(SliceNo, ToNmbr - 1, ToNmbr - 1, ToNmbr - 1);
                    }
                }
            }

            All_Slip_Surface_FOS.Add(Math.Round(FOS_Value, 3));

            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                    SequenceList[RowCounter, ClmCounter] = temp_SequenceList[RowCounter, ClmCounter];
            for (int RowCounter = 0; RowCounter < Analytical_Slice_Data.GetLength(0); RowCounter++)
                for (int ClmCounter = 0; ClmCounter < Analytical_Slice_Data.GetLength(1); ClmCounter++)
                    Analytical_Slice_Data[RowCounter, ClmCounter] = Temp_Analytical_Slice_Data[RowCounter, ClmCounter];
            Exact_Surfase = false;
        }

        private void Sort_Critical_Situations_InSoilModelAndRockModel()
        {
            int SortedNo = 0;

            double Min_FOS = 0;
            int Min_FOS_No = 0;
            int Slip_Surface_No;

            Slip_Surface_No = All_Model_Details.Count;

            if (Slip_Surface_No > 1000)
                SortedNo = 1000;
            else
                SortedNo = All_Model_Details.Count;

            Sorted_Critical_Situation_Charts = new string[SortedNo, SliceNo + 1, 19];
            Sorted_All_Model_Details = new double[SortedNo, SliceNo, 80];
            Sorted_All_Slip_Surfase_FOS = new double[SortedNo];


            for (int i = 0; i < SortedNo; i++)
            {
                Min_FOS = All_Slip_Surface_FOS[0];
                Min_FOS_No = 0;
                for (int j = 0; j < All_Slip_Surface_FOS.Count; j++)
                {
                    if (All_Slip_Surface_FOS[j] < Min_FOS)
                    {
                        Min_FOS = All_Slip_Surface_FOS[j];
                        Min_FOS_No = j;
                    }
                }


                for (int k = 0; k < SliceNo + 1; k++)
                    for (int l = 0; l < 19; l++)
                        Sorted_Critical_Situation_Charts[i, k, l] = Total_Analytical_Critical_Situation_List[Min_FOS_No][k][l];//copy maximum chart to array
                for (int k = 0; k < SliceNo; k++)
                    for (int l = 0; l < 80; l++)
                        Sorted_All_Model_Details[i, k, l] = All_Model_Details[Min_FOS_No][k][l];//copy maximum chart tio array
                Sorted_All_Slip_Surfase_FOS[i] = Min_FOS;

                Total_Analytical_Critical_Situation_List.Remove(Total_Analytical_Critical_Situation_List[Min_FOS_No]);
                All_Model_Details.Remove(All_Model_Details[Min_FOS_No]);
                All_Slip_Surface_FOS.Remove(All_Slip_Surface_FOS[Min_FOS_No]);
            }
        }

        private void Sort_Critical_Situations()
        {
            int Max_index = 0;
            double Max_Force = 0;
            int SortedNo = 0;
            bool Chart_Find = false;
            int k = 0;


            if (All_Model_Details.Count > 1000)
                SortedNo = 1000;
            else
                SortedNo = All_Model_Details.Count;
            Sorted_Critical_Situation_Charts = new string[Total_Analytical_Critical_Situation_List.Count, SliceNo + 1, 19];
            Sorted_All_Model_Details = new double[SortedNo, SliceNo, 80];

            for (int FrmNo = 1; FrmNo < SliceNo && Total_Analytical_Critical_Situation_List.Count > 0; FrmNo++)
            {
                for (int Slice_Counter = FrmNo; Slice_Counter <= SliceNo;)
                {
                    for (int Chart_Counter = 0; Chart_Counter < Total_Analytical_Critical_Situation_List.Count; Chart_Counter++)
                    {
                        if (Total_Analytical_Critical_Situation_List[Chart_Counter][Slice_Counter][9] != "-----"
                            && Total_Analytical_Critical_Situation_List[Chart_Counter][Slice_Counter][9] != null
                            && Total_Analytical_Critical_Situation_List[Chart_Counter][0][10] != "-----"
                            && Total_Analytical_Critical_Situation_List[Chart_Counter][0][10] != null)
                        {
                            if ((System.Convert.ToInt32(Total_Analytical_Critical_Situation_List[Chart_Counter][0][10]) == FrmNo
                                && System.Convert.ToDouble(Total_Analytical_Critical_Situation_List[Chart_Counter][Slice_Counter][9]) > Max_Force) 
                                || fully_Stable_flag == true)//find all results thats model ended to FrmNo
                            {
                                Max_Force = System.Convert.ToDouble(Total_Analytical_Critical_Situation_List[Chart_Counter][Slice_Counter][9]);
                                Max_index = Chart_Counter;
                                Chart_Find = true;
                            }
                        }
                    }
                    if (Chart_Find == true)
                    {
                        for (int i = 0; i < SliceNo + 1; i++)
                            for (int j = 0; j < 19; j++)
                                Sorted_Critical_Situation_Charts[k, i, j] = Total_Analytical_Critical_Situation_List[Max_index][i][j];//copy maximum chart to array
                        for (int i = 0; i < SliceNo; i++)
                            for (int j = 0; j < 80; j++)
                                Sorted_All_Model_Details[k, i, j] = All_Model_Details[Max_index][i][j];//copy maximum chart tio array
                        Total_Analytical_Critical_Situation_List.Remove(Total_Analytical_Critical_Situation_List[Max_index]);
                        All_Model_Details.Remove(All_Model_Details[Max_index]);
                        Max_Force = 0;
                        Max_index = 0;
                        Chart_Find = false;
                        k++;
                    }
                    else
                    {
                        Slice_Counter++;
                    }
                }
            }
        }

        private double To_Double(string input_String)
        {
            if (input_String == "-----")
                return (0);
            else
                return System.Convert.ToDouble(input_String);
        }

        private void Result_Visualizing(int Critical_Situ_No)
        {
            int X_DrawWindow = Pnl_ModelDraw.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ModelDraw.Size.Height;//the height of drawing area
            int X_margine = 10;
            int Y_margine = 10;
            double[,] MaxMin_Column = new double[2, 10];

            Point[] Each_Slice_Color = new Point[4];
            Pen WaterLine = new Pen(Color.FromArgb(255, 0, 0, 255), 5);// thick pen for drawing water line
            Pen Blockies = new Pen(Color.FromArgb(255, 255, 0, 0), 5);// thick pen for drawing water line
            Pen AnchorPen = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing anchors
            Font LegFont = new Font("Arial", 15);

            try
            {
                using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {
                        Each_Slice_Color[0].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 4] * DrawingScale);//TR
                        Each_Slice_Color[0].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 5] * DrawingScale);//TR
                        Each_Slice_Color[1].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 0] * DrawingScale);//TL
                        Each_Slice_Color[1].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 1] * DrawingScale);//TL
                        Each_Slice_Color[2].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6] * DrawingScale);//BL
                        Each_Slice_Color[2].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7] * DrawingScale);//BL
                        Each_Slice_Color[3].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 10] * DrawingScale);//BR
                        Each_Slice_Color[3].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 11] * DrawingScale);//BR
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 0)//Stable
                        {
                            g.FillPolygon(Brushes.Green, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.Green;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 1)//Slide
                        {
                            g.FillPolygon(Brushes.RoyalBlue, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.RoyalBlue;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 2)//Topple
                        {
                            g.FillPolygon(Brushes.OrangeRed, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.OrangeRed;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 3)//Flexure
                        {
                            g.FillPolygon(Brushes.Violet, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.Violet;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 4)//Shear
                        {
                            g.FillPolygon(Brushes.Salmon, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.Salmon;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 5)//Unstable
                        {
                            g.FillPolygon(Brushes.Yellow, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.Yellow;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 6)//Out of range
                        {
                            g.FillPolygon(Brushes.LightGray, Each_Slice_Color);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[12].Style.BackColor = Color.LightGray;
                        }

                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 1)//Rock
                        {
                            g.DrawLine(Pens.Black, Each_Slice_Color[0].X, Each_Slice_Color[0].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[1].Style.BackColor = Color.LightGray;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 2)//Soil
                        {
                            g.DrawLine(Pens.Salmon, Each_Slice_Color[0].X, Each_Slice_Color[0].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                            DGVAnalytical_Output.Rows[SliceNo - Slice_Counter].Cells[1].Style.BackColor = Color.Bisque;
                        }
                        g.DrawLines(WaterLine, WaterLevel);
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 1 && Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 67] == 1)
                            g.DrawLine(Blockies, Each_Slice_Color[2].X, Each_Slice_Color[2].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                    }

                    for (int i = 0; i < SliceNo; i++)//find max of each column
                    {
                        if (i == 0)
                        {
                            MaxMin_Column[0, 0] = Sorted_All_Model_Details[Critical_Situ_No, i, 19];//max
                            MaxMin_Column[0, 1] = Sorted_All_Model_Details[Critical_Situ_No, i, 24];//max
                            MaxMin_Column[0, 2] = Sorted_All_Model_Details[Critical_Situ_No, i, 55];//max
                            MaxMin_Column[0, 3] = Sorted_All_Model_Details[Critical_Situ_No, i, 75];//max
                            MaxMin_Column[0, 4] = Sorted_All_Model_Details[Critical_Situ_No, i, 76];//max
                            MaxMin_Column[0, 5] = Sorted_All_Model_Details[Critical_Situ_No, i, 77];//max
                            MaxMin_Column[0, 6] = Sorted_All_Model_Details[Critical_Situ_No, i, 78];//max
                            MaxMin_Column[0, 7] = Sorted_All_Model_Details[Critical_Situ_No, i, 70];//max
                            MaxMin_Column[0, 8] = Sorted_All_Model_Details[Critical_Situ_No, i, 74];//max
                            MaxMin_Column[0, 9] = Sorted_All_Model_Details[Critical_Situ_No, i, 72];//max
                        }
                        else
                        {
                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 19] > MaxMin_Column[0, 0])
                                MaxMin_Column[0, 0] = Sorted_All_Model_Details[Critical_Situ_No, i, 19];//save maximum height

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 24] > MaxMin_Column[0, 1])
                                MaxMin_Column[0, 1] = Sorted_All_Model_Details[Critical_Situ_No, i, 24];//save maximum weight

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 55] > MaxMin_Column[0, 2])
                                MaxMin_Column[0, 2] = Sorted_All_Model_Details[Critical_Situ_No, i, 55];//save maximum base angle

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 75] > MaxMin_Column[0, 3])
                                MaxMin_Column[0, 3] = Sorted_All_Model_Details[Critical_Situ_No, i, 75];//save maximum slide force

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 76] > MaxMin_Column[0, 4])
                                MaxMin_Column[0, 4] = Sorted_All_Model_Details[Critical_Situ_No, i, 76];//save maximum topple force

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 77] > MaxMin_Column[0, 5])
                                MaxMin_Column[0, 5] = Sorted_All_Model_Details[Critical_Situ_No, i, 77];//save maximum flexur force

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 78] > MaxMin_Column[0, 6])
                                MaxMin_Column[0, 6] = Sorted_All_Model_Details[Critical_Situ_No, i, 78];//save maximum shear force

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 70] > MaxMin_Column[0, 7])
                                MaxMin_Column[0, 7] = Sorted_All_Model_Details[Critical_Situ_No, i, 70];//save maximum left force

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 74] > MaxMin_Column[0, 8])
                                MaxMin_Column[0, 8] = Sorted_All_Model_Details[Critical_Situ_No, i, 74];//save maximum left force height

                            if (Sorted_All_Model_Details[Critical_Situ_No, i, 72] > MaxMin_Column[0, 9])
                                MaxMin_Column[0, 9] = Sorted_All_Model_Details[Critical_Situ_No, i, 72];//save maximum left force angle

                            if (i == SliceNo - 1)
                            {
                                MaxMin_Column[1, 0] = MaxMin_Column[0, 0];//min
                                MaxMin_Column[1, 1] = MaxMin_Column[0, 1];//min
                                MaxMin_Column[1, 2] = MaxMin_Column[0, 2];//min
                                MaxMin_Column[1, 3] = MaxMin_Column[0, 3];//min
                                MaxMin_Column[1, 4] = MaxMin_Column[0, 4];//min
                                MaxMin_Column[1, 5] = MaxMin_Column[0, 5];//min
                                MaxMin_Column[1, 6] = MaxMin_Column[0, 6];//min
                                MaxMin_Column[1, 7] = MaxMin_Column[0, 7];//min
                                MaxMin_Column[1, 8] = MaxMin_Column[0, 8];//min
                                MaxMin_Column[1, 9] = MaxMin_Column[0, 9];//min
                            }
                        }
                    }//detect max of each column


                    for (int i = 0; i < SliceNo; i++)//find Min of each column
                    {
                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 19] < MaxMin_Column[1, 0] && Sorted_All_Model_Details[Critical_Situ_No, i, 19] != 0)
                            MaxMin_Column[1, 0] = Sorted_All_Model_Details[Critical_Situ_No, i, 19];//save minimum height

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 24] < MaxMin_Column[1, 1] && Sorted_All_Model_Details[Critical_Situ_No, i, 24] != 0)
                            MaxMin_Column[1, 1] = Sorted_All_Model_Details[Critical_Situ_No, i, 24];//save minimum weight

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 55] < MaxMin_Column[1, 2] && Sorted_All_Model_Details[Critical_Situ_No, i, 55] != 0)
                            MaxMin_Column[1, 2] = Sorted_All_Model_Details[Critical_Situ_No, i, 55];//save minimum base angle

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 75] < MaxMin_Column[1, 3] && Sorted_All_Model_Details[Critical_Situ_No, i, 75] != 0)
                            MaxMin_Column[1, 3] = Sorted_All_Model_Details[Critical_Situ_No, i, 75];//save minimum slide force

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 76] < MaxMin_Column[1, 4] && Sorted_All_Model_Details[Critical_Situ_No, i, 76] != 0)
                            MaxMin_Column[1, 4] = Sorted_All_Model_Details[Critical_Situ_No, i, 76];//save minimum topple force

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 77] < MaxMin_Column[1, 5] && Sorted_All_Model_Details[Critical_Situ_No, i, 77] != 0)
                            MaxMin_Column[1, 5] = Sorted_All_Model_Details[Critical_Situ_No, i, 77];//save minimum flexur force

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 78] < MaxMin_Column[1, 6] && Sorted_All_Model_Details[Critical_Situ_No, i, 78] != 0)
                            MaxMin_Column[1, 6] = Sorted_All_Model_Details[Critical_Situ_No, i, 78];//save minimum shear force

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 70] < MaxMin_Column[1, 7] && Sorted_All_Model_Details[Critical_Situ_No, i, 70] != 0)
                            MaxMin_Column[1, 7] = Sorted_All_Model_Details[Critical_Situ_No, i, 70];//save minimum left force

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 74] < MaxMin_Column[1, 8] && Sorted_All_Model_Details[Critical_Situ_No, i, 74] != 0)
                            MaxMin_Column[1, 8] = Sorted_All_Model_Details[Critical_Situ_No, i, 74];//save minimum left force height

                        if (Sorted_All_Model_Details[Critical_Situ_No, i, 72] < MaxMin_Column[1, 9] && Sorted_All_Model_Details[Critical_Situ_No, i, 72] != 0)
                            MaxMin_Column[1, 9] = Sorted_All_Model_Details[Critical_Situ_No, i, 72];//save minimum left force angle
                    }

                    for (int i = 0; i < 10; i++)//omit ziros from min and cases that has equal max and min
                    {
                        if (MaxMin_Column[0, i] == 0 || MaxMin_Column[0, i] == MaxMin_Column[1, i])
                            MaxMin_Column[0, i]++;
                    }


                    for (int R = 0; R < SliceNo; R++)//creat color related to amount of each cell of a column
                    {
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 19] != 0)
                        {
                            Color FillColor = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 19]
                                - MaxMin_Column[1, 0]) * 155d / (MaxMin_Column[0, 0] - MaxMin_Column[1, 0])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[2].Style.BackColor = FillColor;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 24] != 0)
                        {
                            Color FillColor1 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 24]
                                - MaxMin_Column[1, 1]) * 155d / (MaxMin_Column[0, 1] - MaxMin_Column[1, 1])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[3].Style.BackColor = FillColor1;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 55] != 0)
                        {
                            Color FillColor2 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 55]
                                - MaxMin_Column[1, 2]) * 155d / (MaxMin_Column[0, 2] - MaxMin_Column[1, 2])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[4].Style.BackColor = FillColor2;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 75] != 0)
                        {
                            Color FillColor3 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 75]
                                - MaxMin_Column[1, 3]) * 155d / (MaxMin_Column[0, 3] - MaxMin_Column[1, 3])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[5].Style.BackColor = FillColor3;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 76] != 0)
                        {
                            Color FillColor4 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 76]
                                - MaxMin_Column[1, 4]) * 155d / (MaxMin_Column[0, 4] - MaxMin_Column[1, 4])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[6].Style.BackColor = FillColor4;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 77] != 0)
                        {
                            Color FillColor5 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 77]
                                - MaxMin_Column[1, 5]) * 155d / (MaxMin_Column[0, 5] - MaxMin_Column[1, 5])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[7].Style.BackColor = FillColor5;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 78] != 0)
                        {
                            Color FillColor6 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 78]
                                - MaxMin_Column[1, 6]) * 155d / (MaxMin_Column[0, 6] - MaxMin_Column[1, 6])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[8].Style.BackColor = FillColor6;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 70] != 0)
                        {
                            Color FillColor7 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 70]
                                - MaxMin_Column[1, 7]) * 155d / (MaxMin_Column[0, 7] - MaxMin_Column[1, 7])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[9].Style.BackColor = FillColor7;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 74] != 0)
                        {
                            Color FillColor8 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 74]
                                - MaxMin_Column[1, 8]) * 155d / (MaxMin_Column[0, 8] - MaxMin_Column[1, 8])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[10].Style.BackColor = FillColor8;
                        }
                        if (Sorted_All_Model_Details[Critical_Situ_No, R, 72] != 0)
                        {
                            Color FillColor9 = Color.FromArgb(255, 100 + System.Convert.ToInt16((Sorted_All_Model_Details[Critical_Situ_No, R, 72]
                                - MaxMin_Column[1, 9]) * 155d / (MaxMin_Column[0, 9] - MaxMin_Column[1, 9])), 150, 20);
                            DGVAnalytical_Output.Rows[SliceNo - R - 1].Cells[11].Style.BackColor = FillColor9;
                        }
                    }


                    for (int i = 1; i <= AnchorNo; i++)//draw anchors
                    {
                        g.DrawLine(AnchorPen,// to draw anchor cable
                            System.Convert.ToInt32(Anchor_Line[i - 1, 1]),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 2]),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 3]),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 4]));
                        g.DrawLine(AnchorPen,//to draw anchor Head
                            System.Convert.ToInt32(Anchor_Line[i - 1, 1] + 10),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 2] - 10
                            * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 1] - 10),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 2] + 10
                            * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)));
                        g.FillEllipse(Brushes.Black,// to draw anchor point
                            System.Convert.ToInt32(Anchor_Line[i - 1, 3] - 6),
                            System.Convert.ToInt32(Anchor_Line[i - 1, 4] - 7),
                            12, 14);
                    }

                    int X_Force_Height_Center = 0, Y_Force_Height_Center = 0;
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)//mark force hgeights
                    {
                        if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20] > 0)
                        {
                            X_Force_Height_Center = System.Convert.ToInt32(All_Slope_Points[0, 4] + DrawingScale * (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6]
                                - (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 74] / Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20]) *
                                (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 0])));
                            Y_Force_Height_Center = System.Convert.ToInt32(All_Slope_Points[0, 5] - DrawingScale * (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7]
                                - (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 74] / Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20]) *
                                (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 1])));
                            g.FillEllipse(Brushes.Black, X_Force_Height_Center - 2, Y_Force_Height_Center - 2, 4, 4);
                        }
                    }



                    g.FillRectangle(Brushes.LightGray, -6, 35 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillRectangle(Brushes.Bisque, -6, 55 + X_margine - Y_DrawWindow, 15, 15);

                    g.FillEllipse(Brushes.Yellow, -6, 75 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillEllipse(Brushes.Green, -6, 95 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillEllipse(Brushes.OrangeRed, -6, 115 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillEllipse(Brushes.RoyalBlue, -6, 135 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillEllipse(Brushes.Violet, -6, 155 + X_margine - Y_DrawWindow, 15, 15);
                    g.FillEllipse(Brushes.Salmon, -6, 175 + X_margine - Y_DrawWindow, 15, 15);

                    g.DrawString("Rock", LegFont, Brushes.Black, 15, 30 + X_margine - Y_DrawWindow);
                    g.DrawString("Soil", LegFont, Brushes.Black, 15, 50 + X_margine - Y_DrawWindow);
                    g.DrawString("Unstable Soil", LegFont, Brushes.Black, 15, 70 + X_margine - Y_DrawWindow);
                    g.DrawString("Stable", LegFont, Brushes.Black, 15, 90 + X_margine - Y_DrawWindow);
                    g.DrawString("Block Toppling", LegFont, Brushes.Black, 15, 110 + X_margine - Y_DrawWindow);
                    g.DrawString("Sliding", LegFont, Brushes.Black, 15, 130 + X_margine - Y_DrawWindow);
                    g.DrawString("Flexural Toppling", LegFont, Brushes.Black, 15, 150 + X_margine - Y_DrawWindow);
                    g.DrawString("Shearing", LegFont, Brushes.Black, 15, 170 + X_margine - Y_DrawWindow);
                }
            }
            catch
            {

            }
        }

        private void Draw_Failure_Plain_Scanned()
        {
            int X_DrawWindow = Pnl_ModelDraw.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ModelDraw.Size.Height;//the height of drawing area
            int X_margine = 10;
            int Y_margine = 10;
            using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine + System.Convert.ToInt16(All_Slope_Points[0, 4])
                    , Y_DrawWindow - Y_margine + System.Convert.ToInt16(All_Slope_Points[0, 5])); // to Move center of coordination System
                for (int i = 0; i < All_Arcs_List.Count; i += 1)
                {
                    try
                    {
                        g.DrawArc(Pens.Black, System.Convert.ToInt16(DrawingScale * (All_Arcs_List[i][0] - All_Arcs_List[i][2])),
                            System.Convert.ToInt16(DrawingScale * (-All_Arcs_List[i][1] - All_Arcs_List[i][2])),
                            System.Convert.ToInt16(2 * DrawingScale * All_Arcs_List[i][2]),
                            System.Convert.ToInt16(2 * DrawingScale * All_Arcs_List[i][2]),
                            System.Convert.ToInt16(All_Arcs_List[i][3]),
                            System.Convert.ToInt16(All_Arcs_List[i][4]));
                    }
                    catch
                    {
                    }
                }
            }
        }

        private void Chk_Bx_Arcs_Click(object sender, EventArgs e)
        {
            if (Chk_Bx_Arcs.Checked == true)
            {
                Draw_Failure_Plain_Scanned();
                MessageBox.Show(System.Convert.ToString(All_Arcs_List.Count) + " Probable Failure Plains Analyzed by Total Slope ");
            }
            else
            {
                    Pnl_ModelDraw.Refresh();
                    Draw_Model();
                    Result_Visualizing(0);
            }

        }

        private void Save_Failure_Plain_Arc(
            double X_Arc_Center,
            double Y_Arc_Center,
            double Arc_Radius,
            double Arc_Start_Angle,
            double Arc_End_Angle)
        {
            List<double> New_Arc = new List<double>();
            New_Arc.Add(X_Arc_Center);
            New_Arc.Add(Y_Arc_Center);
            New_Arc.Add(Arc_Radius);
            New_Arc.Add(Arc_Start_Angle);
            New_Arc.Add(Arc_End_Angle);

            All_Arcs_List.Add(New_Arc);

        }

        private void Rock_Analytical_Solve(int FromNo, int ToNo)
        {
            double Sin_Saay_b = 0;
            double Cos_Saay_b = 0;
            double Tan_Saay_b = 0;
            double Sin_Saay_C = 0;
            double Cos_Saay_C = 0;
            double Sin_Saay_Anch = 0;
            double Cos_Saay_Anch = 0;
            double Tan_Phi_R = 0;
            double Tan_Phi_L = 0;
            double Tan_Phi_b = 0;
            double Tan_Phi_Material = 0;
            double C_R = 0;
            double C_L = 0;
            double C_b = 0;
            double C_Material = 0;
            double Sigma_Tensile_Material = 0;
            double h_c = 0;
            double h_Anch = 0;
            double l_w_R = 0;
            double l_w_L = 0;
            double h_f_R = 0;
            double h_f_L = 0;
            double l_R = 0;
            double l_L = 0;
            double L = 0;
            double W = 0;
            double f_R = 0;
            double f_Anch = 0;
            double t = 0;


            Kh = System.Convert.ToDouble(ModelDetail[3]);
            Kv = System.Convert.ToDouble(ModelDetail[5]);


            for (int i = ToNo; i < FromNo; i++)
            {
                Analytical_Slice_Data[i, 75] = 0;
                Analytical_Slice_Data[i, 76] = 0;
                Analytical_Slice_Data[i, 77] = 0;
                Analytical_Slice_Data[i, 78] = 0;
                Analytical_Slice_Data[i, 79] = 0;
            }

            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)//calculate each column stability from last cloumn to toe
            {
                if (Slice_Counter <= FromNo && Slice_Counter > ToNo && (Analytical_Slice_Data[Slice_Counter - 1, 19] > 0))//in blocks that is in bond we must calculate stability
                {
                    Sin_Saay_b = Math.Sin(base_Rock_breakage_angle * Math.PI / 180);
                    Cos_Saay_b = Math.Cos(base_Rock_breakage_angle * Math.PI / 180);
                    Tan_Saay_b = Math.Tan(base_Rock_breakage_angle * Math.PI / 180);
                    Sin_Saay_C = Math.Sin(Analytical_Slice_Data[Slice_Counter - 1, 49] * Math.PI / 180);
                    Cos_Saay_C = Math.Cos(Analytical_Slice_Data[Slice_Counter - 1, 49] * Math.PI / 180);
                    Sin_Saay_Anch = Math.Sin((90 - Analytical_Slice_Data[Slice_Counter - 1, 27] - Analytical_Slice_Data[Slice_Counter - 1, 49]) * Math.PI / 180);
                    Cos_Saay_Anch = Math.Cos((90 - Analytical_Slice_Data[Slice_Counter - 1, 27] - Analytical_Slice_Data[Slice_Counter - 1, 49]) * Math.PI / 180);

                    if (Analytical_Slice_Data[Slice_Counter - 1, 46] == Analytical_Slice_Data[Slice_Counter - 1, 44])//first coloumn in right of slope
                    {//to use C and phi of right and left  of the slice at this Slope
                        Tan_Phi_R = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 63] * Math.PI / 180);
                        Tan_Phi_L = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 53] * Math.PI / 180);
                        C_R = Analytical_Slice_Data[Slice_Counter - 1, 61];
                        C_L = Analytical_Slice_Data[Slice_Counter - 1, 51];
                    }
                    else if (Analytical_Slice_Data[Slice_Counter - 1, 46] == 1)//first column in left of slope
                    {//to use C and phi of right and left  of the slice at this Slope
                        Tan_Phi_R = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 53] * Math.PI / 180);
                        C_R = Analytical_Slice_Data[Slice_Counter - 1, 51];
                        if (Slice_Counter == 1)
                        {
                            Tan_Phi_L = 0;
                            C_L = 0;
                        }
                        else
                        {
                            Tan_Phi_L = Math.Tan(Analytical_Slice_Data[Slice_Counter - 2, 63] * Math.PI / 180);
                            C_L = Analytical_Slice_Data[Slice_Counter - 2, 61];
                        }
                    }
                    else//column in middle of slope
                    {//to use C and phi of right and left  of the slice at this Slope
                        Tan_Phi_R = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 53] * Math.PI / 180);
                        Tan_Phi_L = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 53] * Math.PI / 180);
                        C_R = Analytical_Slice_Data[Slice_Counter - 1, 51];
                        C_L = Analytical_Slice_Data[Slice_Counter - 1, 51];
                    }

                    Tan_Phi_b = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 59] * Math.PI / 180);
                    Tan_Phi_Material = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 32] * Math.PI / 180);
                    C_b = Analytical_Slice_Data[Slice_Counter - 1, 57];
                    C_Material = Analytical_Slice_Data[Slice_Counter - 1, 30];
                    Sigma_Tensile_Material = Analytical_Slice_Data[Slice_Counter - 1, 36];
                    h_c = Analytical_Slice_Data[Slice_Counter - 1, 19];
                    h_Anch = Analytical_Slice_Data[Slice_Counter - 1, 20];
                    l_w_R = Analytical_Slice_Data[Slice_Counter - 1, 21];
                    l_w_L = Analytical_Slice_Data[Slice_Counter - 1, 23];
                    h_f_R = Analytical_Slice_Data[Slice_Counter - 1, 73];
                    h_f_L = Analytical_Slice_Data[Slice_Counter - 1, 74];
                    l_R = Analytical_Slice_Data[Slice_Counter - 1, 18];
                    l_L = Analytical_Slice_Data[Slice_Counter - 1, 20];
                    L = Analytical_Slice_Data[Slice_Counter - 1, 25];
                    W = Analytical_Slice_Data[Slice_Counter - 1, 24];
                    f_R = Analytical_Slice_Data[Slice_Counter - 1, 69];
                    f_Anch = Analytical_Slice_Data[Slice_Counter - 1, 26];
                    t = Analytical_Slice_Data[Slice_Counter - 1, 43];

                    if (Analytical_Slice_Data[Slice_Counter - 1, 67] == 1)//Blocky situation in rock column failure
                    {
                        Analytical_Slice_Data[Slice_Counter - 1, 75] = Slide_Force
                                                    (Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                    , Sin_Saay_C, Cos_Saay_C
                                                    , Sin_Saay_Anch, Cos_Saay_Anch
                                                    , Tan_Phi_R
                                                    , Tan_Phi_L
                                                    , Tan_Phi_b
                                                    , C_R
                                                    , C_L
                                                    , C_b
                                                    , l_w_R, l_w_L
                                                    , h_c
                                                    , l_R
                                                    , l_L
                                                    , L, W
                                                    , f_R
                                                    , f_Anch
                                                    , t);//Sliding force

                        if (Slice_Counter > 1)
                        {
                            if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                            {
                                h_f_L = l_L;
                            }
                            else
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                {
                                    h_f_L = l_L;
                                }
                                else
                                {
                                    if (Slice_Counter - 1 == ToNo)
                                        h_f_L = 0.5 * l_R;
                                    else
                                        h_f_L = l_L - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                            Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d));
                                }

                            }
                        }
                        else
                            h_f_L = 0.5 * l_R;

                        /*
                                                h_f_L = l_L;
                                                if (Slice_Counter == 1)
                                                    h_f_L = 0.5 * l_R;
                        */
                        Analytical_Slice_Data[Slice_Counter - 1, 76] = Toppling_Force
                                                    (Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                    , Sin_Saay_C, Cos_Saay_C
                                                    , Cos_Saay_Anch
                                                    , Tan_Phi_R
                                                    , Tan_Phi_b
                                                    , C_R
                                                    , l_w_R, l_w_L
                                                    , h_c
                                                    , h_Anch
                                                    , l_R
                                                    , L, W
                                                    , f_R
                                                    , h_f_R
                                                    , h_f_L
                                                    , f_Anch
                                                    , t);//Toppling force

                        if (Analytical_Slice_Data[Slice_Counter - 1, 75] < 0d)
                            Analytical_Slice_Data[Slice_Counter - 1, 75] = 0d;
                        if (Analytical_Slice_Data[Slice_Counter - 1, 76] < 0d)
                            Analytical_Slice_Data[Slice_Counter - 1, 76] = 0d;
                        if (Analytical_Slice_Data[Slice_Counter - 1, 76] < Analytical_Slice_Data[Slice_Counter - 1, 75])//sliding
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 1;//failure mode = sliding
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = Analytical_Slice_Data[Slice_Counter - 1, 75];//left force
                                                                                                                        //                            Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;//left force height

                            if (Slice_Counter > 1)
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                                {
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;
                                }
                                else
                                {
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;
                                    }
                                    else
                                    {
                                        if (Slice_Counter - 1 == ToNo)
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0.5 * Analytical_Slice_Data[Slice_Counter - 1, 18];
                                        else
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = (Analytical_Slice_Data[Slice_Counter - 1, 20] - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                            Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d))) / 2d;
                                    }

                                }
                            }


                            if (Slice_Counter == 1)
                                Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d;
                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force of next column
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 43] * Math.Tan((Analytical_Slice_Data[Slice_Counter - 1, 55]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 49] - 90d) * Math.PI / 180d);//right force height of next column
                                                                                                            //         Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74]
                                                                                                            //             + (Analytical_Slice_Data[Slice_Counter - 2, 18] - Analytical_Slice_Data[Slice_Counter - 1, 20]);//right force height of next column
                            }
                        }
                        else if (Analytical_Slice_Data[Slice_Counter - 1, 76] > 0)//Toppling
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 2;//failure mode = Toppling
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = Analytical_Slice_Data[Slice_Counter - 1, 76];//left force
                                                                                                                        //                            Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20];//left force height

                            if (Slice_Counter > 1)
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                                {
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20];
                                }
                                else
                                {
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20];
                                    }
                                    else
                                    {
                                        if (Slice_Counter - 1 == ToNo)
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0.5 * Analytical_Slice_Data[Slice_Counter - 1, 18];
                                        else
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                            Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d));
                                    }

                                }
                            }



                            if (Slice_Counter == 1)
                                Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d;

                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force of next column
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 43] * Math.Tan((Analytical_Slice_Data[Slice_Counter - 1, 55]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 49] - 90d) * Math.PI / 180d);//right force height of next column
                                                                                                            //                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74] 
                                                                                                            //                                    + (Analytical_Slice_Data[Slice_Counter - 2, 18] - Analytical_Slice_Data[Slice_Counter - 1, 20]);//right force height of next column
                            }
                        }
                        else//stable
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 0;//failure mode = stable
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;//left force
                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;//left force height
                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = 0;//right force
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = 0;//right force height
                            }
                        }
                    }
                    if (Analytical_Slice_Data[Slice_Counter - 1, 67] == 0)//Flexure situation in rock column failure
                    {



                        if (Slice_Counter > 1)
                        {
                            if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                            {
                                h_f_L = 3d * l_L / 4d;
                            }
                            else
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                {
                                    h_f_L = 3d * l_L / 4d;
                                }
                                else
                                {
                                    if (Slice_Counter - 1 == ToNo)
                                        h_f_L = 0.5 * l_R;
                                    else
                                        h_f_L = 3d * (l_L - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                        Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d))) / 4d;
                                }

                            }
                        }
                        else
                            h_f_L = 0.5 * l_R;

                        /*
                                                h_f_L = 3d * l_L / 4d;
                                                if (Slice_Counter == 1)
                                                    h_f_L = 0.5 * l_R;
                        */

                        Analytical_Slice_Data[Slice_Counter - 1, 77] = Flexure_Force
                                                    (Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                    , Sin_Saay_C, Cos_Saay_C
                                                    , Sin_Saay_Anch, Cos_Saay_Anch
                                                    , Tan_Phi_R
                                                    , Tan_Phi_L
                                                    , Tan_Phi_Material
                                                    , C_R
                                                    , C_L
                                                    , C_Material
                                                    , Sigma_Tensile_Material
                                                    , l_w_R, l_w_L
                                                    , h_c
                                                    , h_Anch
                                                    , l_R
                                                    , l_L
                                                    , L, W
                                                    , f_R
                                                    , h_f_R
                                                    , h_f_L
                                                    , f_Anch
                                                    , t);//flexure force

                        Analytical_Slice_Data[Slice_Counter - 1, 78] = Shear_Force
                                                    (Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                    , Sin_Saay_C, Cos_Saay_C
                                                    , Sin_Saay_Anch, Cos_Saay_Anch
                                                    , Tan_Phi_R
                                                    , Tan_Phi_L
                                                    , Tan_Phi_Material
                                                    , C_R
                                                    , C_L
                                                    , C_Material
                                                    , l_w_R, l_w_L
                                                    , h_c
                                                    , l_R
                                                    , l_L
                                                    , L, W
                                                    , f_R
                                                    , f_Anch
                                                    , t);//Shear force

                        if (Analytical_Slice_Data[Slice_Counter - 1, 77] < 0d)
                            Analytical_Slice_Data[Slice_Counter - 1, 77] = 0d;
                        if (Analytical_Slice_Data[Slice_Counter - 1, 78] < 0d)
                            Analytical_Slice_Data[Slice_Counter - 1, 78] = 0d;
                        if (Analytical_Slice_Data[Slice_Counter - 1, 78] < Analytical_Slice_Data[Slice_Counter - 1, 77])//Flexure
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 3;//failure mode = Flexure
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = Analytical_Slice_Data[Slice_Counter - 1, 77];//left force
                                                                                                                        //                            Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] * 3d / 4d;//left force height

                            if (Slice_Counter > 1)
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                                {
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = 3d * Analytical_Slice_Data[Slice_Counter - 1, 20] / 4d;
                                }
                                else
                                {
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 74] = 3d * Analytical_Slice_Data[Slice_Counter - 1, 20] / 4d;
                                    }
                                    else
                                    {
                                        if (Slice_Counter - 1 == ToNo)
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0.5 * Analytical_Slice_Data[Slice_Counter - 1, 18];
                                        else
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 3d * (Analytical_Slice_Data[Slice_Counter - 1, 20] - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                            Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d))) / 4d;
                                    }

                                }
                            }

                            if (Slice_Counter == 1)
                                Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d;

                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 43] * Math.Tan((Analytical_Slice_Data[Slice_Counter - 1, 55]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 49] - 90d) * Math.PI / 180d);//right force height of next column
                                                                                                            //                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74] 
                                                                                                            //                                    + (Analytical_Slice_Data[Slice_Counter - 2, 18] - Analytical_Slice_Data[Slice_Counter - 1, 20]);//right force height
                            }
                        }
                        else if (Analytical_Slice_Data[Slice_Counter - 1, 78] > 0)//Shear
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 4;//failure mode = Shear
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = Analytical_Slice_Data[Slice_Counter - 1, 78];//left force
                                                                                                                        //                            Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;//left force height

                            if (Slice_Counter > 1)
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 1] == Analytical_Slice_Data[Slice_Counter - 2, 5])//in the case of Steppsurfase false
                                {
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;
                                }
                                else
                                {
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 1] < Analytical_Slice_Data[Slice_Counter - 2, 5])
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20] / 2d;
                                    }
                                    else
                                    {
                                        if (Slice_Counter - 1 == ToNo)
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0.5 * Analytical_Slice_Data[Slice_Counter - 1, 18];
                                        else
                                            Analytical_Slice_Data[Slice_Counter - 1, 74] = (Analytical_Slice_Data[Slice_Counter - 1, 20] - (Analytical_Slice_Data[Slice_Counter - 1, 43] /
                                            Math.Tan((180 - Analytical_Slice_Data[Slice_Counter - 1, 49] - Analytical_Slice_Data[Slice_Counter - 1, 42]) * Math.PI / 180d))) / 2d;
                                    }

                                }
                            }

                            if (Slice_Counter == 1)
                                Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d;

                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 43] * Math.Tan((Analytical_Slice_Data[Slice_Counter - 1, 55]
                                    + Analytical_Slice_Data[Slice_Counter - 1, 49] - 90d) * Math.PI / 180d);//right force height of next column
                                                                                                            //                                Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74] 
                                                                                                            //                                    + (Analytical_Slice_Data[Slice_Counter - 2, 18] - Analytical_Slice_Data[Slice_Counter - 1, 20]);//right force height
                            }
                        }
                        else//stable
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 0;//failure mode = stable
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;//left force
                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;//left force height
                            if (Slice_Counter > 1)
                            {
                                Analytical_Slice_Data[Slice_Counter - 2, 69] = 0;//right force
                                Analytical_Slice_Data[Slice_Counter - 2, 73] = 0;//right force height
                            }
                        }
                    }
                    Analytical_Slice_Data[Slice_Counter - 1, 71] = 90d - Analytical_Slice_Data[Slice_Counter - 1, 49];//right force Angle
                    Analytical_Slice_Data[Slice_Counter - 1, 72] = 90d - Analytical_Slice_Data[Slice_Counter - 1, 49];//Left force angle

                }

                else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 1)//out of band Rockcolumn
                {
                    Analytical_Slice_Data[Slice_Counter - 1, 79] = 6;//failure mode = out of range
                    Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;//left force
                    Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;//left force height
                    if (Slice_Counter > 1)
                    {
                        Analytical_Slice_Data[Slice_Counter - 2, 69] = 0;//right force
                        Analytical_Slice_Data[Slice_Counter - 2, 73] = 0;//right force height
                    }
                }
            }
        }

        private void Soil_Analytical_Solve(
            int FromNo,
            int ToNo,
            double Slice_Angle,
            int UpNo,
            int DwnNo,
            int TC_From,
            int TC_To,
            int Arc_Ang_From,
            int Arc_Ang_To)
        {
            double X_Max_TentionCrack_Depth = 0, Y_Max_TentionCrack_Depth = 0;//maximum desireable depth of tention carack
            double M_C = 0, M_B = 0, X1 = 0, Y1 = 0, X2 = 0, Y2 = 0;
            double X_Cord_Center = 0, Y_Cord_Center = 0, Cord_Length = 0, Cord_Angle = 0;
            double Arc_Center_Distance = 0;
            //            double K_factor = 0;//factor of non linear distribution of internal force angle
            double Sin_Saay_C_Int = 0;
            double Cos_Saay_C_Int = 0;
            double Sin_Saay_R = 0;
            double Cos_Saay_R = 0;
            double Sin_Saay_L = 0;
            double Cos_Saay_L = 0;
            double Sin_Saay_b = 0;
            double Cos_Saay_b = 0;
            double Tan_Saay_b = 0;
            double Sin_Saay_C = 0;
            double Cos_Saay_C = 0;
            double Sin_Saay_Anch = 0;
            double Cos_Saay_Anch = 0;
            double Tan_Phi_Material = 0;
            double Cos_Phi_Int = 0;
            double C_Material = 0;
            double l_w_R = 0;
            double l_w_L = 0;
            double l_R = 0;
            double h_c = 0;
            double h_Anch = 0;
            double h_f_R = 0;
            double L = 0;
            double W = 0;
            double f_R = 0;
            double f_L = 0;
            double f_Anch = 0;
            double t = 0;

            double FromPhi = 0;
            double ToPhi = 0;
            double ThisSlopeSliceNo = 0;
            double ThisSliceNo = 0;

            int Start_Search_Angle = 0;//angle of circular failure arc plain

            M_C = Math.Tan((180d - Slice_Angle) * Math.PI / 180d);//column angle of just Rocky column after last soil slice
            if (ModelDetail[7] == "Rock_Soil")//in Rock_Soil Model or in soil models that the lower corner of failure plaine is not at toe
            {
                M_C = Math.Tan((180d - Slice_Angle) * Math.PI / 180d);//column angle of just Rocky column after last soil slice
                X1 = Analytical_Slice_Data[ToNo - 1, 4];//XTR of first rocky column just after last soil slice
                Y1 = Analytical_Slice_Data[ToNo - 1, 5];//YTR of first rocky column just after last soil slice
                M_B = Math.Tan((Analytical_Slice_Data[ToNo - 1, 55]) * Math.PI / 180);//base angle of just Rocky column after last soil slice
                X2 = Analytical_Slice_Data[ToNo - 1, 6];//XBL of first rocky column just after last soil slice
                Y2 = Analytical_Slice_Data[ToNo - 1, 7];//YBL of first rocky column just after last soil slice

                Analytical_Slice_Data[ToNo, 6] = (Y2 - Y1 + M_C * X1 - M_B * X2) / (M_C - M_B);//X of left corner of chord
                Analytical_Slice_Data[ToNo, 7] = Y1 + M_C * (Analytical_Slice_Data[ToNo, 6] - X1);//Y of left corner of chord


                X1 = Analytical_Slice_Data[ToNo, 6];//XBL of last soil slice near roc and soil intersection
                Y1 = Analytical_Slice_Data[ToNo, 7];//YBL of last soil slice near roc and soil intersection
                X2 = Analytical_Slice_Data[FromNo - 1, 4];//XTR of Slice just after Tention crack
                Y2 = Analytical_Slice_Data[FromNo - 1, 5];//YTR of Slice just after Tention crack
                X_Max_TentionCrack_Depth = (Y2 - Y1 + M_B * X1 - M_C * X2) / (M_B - M_C);//X of maximum desireable depth of tention carack
                Y_Max_TentionCrack_Depth = Y1 + M_B * (X_Max_TentionCrack_Depth - X1);//Y of maximum desireable depth of tention carack
            }
            else if (ModelDetail[7] == "Soil")//in soil models 
            {
                Y_Max_TentionCrack_Depth = Analytical_Slice_Data[FromNo - 1, 5] / 2d;//Y of maximum desireable depth of tention carack
                X_Max_TentionCrack_Depth = Analytical_Slice_Data[FromNo - 1, 4] + (Y_Max_TentionCrack_Depth - Analytical_Slice_Data[FromNo - 1, 5]) /
                    Math.Tan((180d - Analytical_Slice_Data[FromNo - 1, 49]) * Math.PI / 180d);//X of maximum desireable depth of tention carack
            }

            else if (ModelDetail[7] == "Soil_Rock")//in Rock_Soil Model or in soil models that the lower corner of failure plaine is not at toe
            {
                Y_Max_TentionCrack_Depth = Analytical_Slice_Data[FromNo, 7];//Y of maximum desireable depth of tention carack
                X_Max_TentionCrack_Depth = Analytical_Slice_Data[FromNo, 6];//X of maximum desireable depth of tention carack
            }

            ////////////////////////////////////////////////////////////////////////////////////////////////
            for (Tension_Crack_Step = TC_From; Tension_Crack_Step <= TC_To; Tension_Crack_Step++)
            {//tenstion crack depth search start
                Analytical_Slice_Data[FromNo - 1, 10] = Analytical_Slice_Data[FromNo - 1, 4] +
                    (X_Max_TentionCrack_Depth - Analytical_Slice_Data[FromNo - 1, 4]) * Tension_Crack_Step / Tention_Crack_StepsNo;//X of desired tensioc crack depth
                Analytical_Slice_Data[FromNo - 1, 11] = Analytical_Slice_Data[FromNo - 1, 5] +
                    (Y_Max_TentionCrack_Depth - Analytical_Slice_Data[FromNo - 1, 5]) * Tension_Crack_Step / Tention_Crack_StepsNo;//Y of desired tensioc crack depth

                if (ModelDetail[7] == "Rock_Soil")//in Rock_Soil Model or in soil models that the lower corner of failure plaine is not at toe
                {
                    X_Cord_Center = (Analytical_Slice_Data[ToNo, 6] + Analytical_Slice_Data[FromNo - 1, 10]) / 2d;//X of cord center
                    Y_Cord_Center = (Analytical_Slice_Data[ToNo, 7] + Analytical_Slice_Data[FromNo - 1, 11]) / 2d;// Y of Cord Center
                    Cord_Length = Math.Sqrt(Math.Pow(Analytical_Slice_Data[FromNo - 1, 10] - Analytical_Slice_Data[ToNo - 1, 10], 2)
                        + Math.Pow(Analytical_Slice_Data[FromNo - 1, 11] - Analytical_Slice_Data[ToNo - 1, 11], 2));
                    Cord_Angle = Math.Atan((Analytical_Slice_Data[FromNo - 1, 11] - Analytical_Slice_Data[ToNo - 1, 11])
                        / (Analytical_Slice_Data[FromNo - 1, 10] - Analytical_Slice_Data[ToNo - 1, 10])) * 180 / Math.PI;//cord angle
                    Start_Search_Angle = System.Convert.ToInt16(Cord_Angle - Analytical_Slice_Data[ToNo - 1, 55]);
                }
                else if (ModelDetail[7] == "Soil" || ModelDetail[7] == "Soil_Rock")//in Soil_Rock Model or in soil models
                {
                    X_Cord_Center = (Analytical_Slice_Data[ToNo, 0] + Analytical_Slice_Data[FromNo - 1, 10]) / 2d;//X of cord center
                    Y_Cord_Center = (Analytical_Slice_Data[ToNo, 1] + Analytical_Slice_Data[FromNo - 1, 11]) / 2d;// Y of Cord Center
                    Cord_Length = Math.Sqrt(Math.Pow(Analytical_Slice_Data[FromNo - 1, 10] - Analytical_Slice_Data[ToNo, 0], 2)
                        + Math.Pow(Analytical_Slice_Data[FromNo - 1, 11] - Analytical_Slice_Data[ToNo, 1], 2));
                    Cord_Angle = Math.Atan((Analytical_Slice_Data[FromNo - 1, 11] - Analytical_Slice_Data[ToNo, 1])
                        / (Analytical_Slice_Data[FromNo - 1, 10] - Analytical_Slice_Data[ToNo, 0])) * 180 / Math.PI;//cord angle
                    Start_Search_Angle = System.Convert.ToInt16(Cord_Angle);
                }

                if (Start_Search_Angle < 0)
                {
                    Start_Search_Angle = 0;
                    Tension_Crack_Step = Tention_Crack_StepsNo;
                }
                if (Arc_Ang_From != 360)
                    Start_Search_Angle = Arc_Ang_From;//for Safety factor calculation that we need analyse spesific arc

                for (Circular_Arc_Angle = Start_Search_Angle; Circular_Arc_Angle > Arc_Ang_To; Circular_Arc_Angle--)//start angle is angle of circule that is tangent to slices on left
                {//circular failure plane search start
                    Arc_Radius = (Cord_Length / 2d) / Math.Sin((Circular_Arc_Angle) * Math.PI / 180);//Radius of failure plane
                    Arc_Center_Distance = (Cord_Length / 2d) / Math.Tan((Circular_Arc_Angle) * Math.PI / 180);// distance between cord center and circular failure plain center
                    X_Arc_Center = X_Cord_Center - Arc_Center_Distance * Math.Sin(Cord_Angle * Math.PI / 180);//X Center of failure plane
                    Y_Arc_Center = Y_Cord_Center + Arc_Center_Distance * Math.Cos(Cord_Angle * Math.PI / 180);//Y Center of failure plane

                    if (Exact_Slip_Surfaces_FOS_flag == false)
                        Save_Failure_Plain_Arc(X_Arc_Center, Y_Arc_Center, Arc_Radius,
                            Math.Atan((Y_Arc_Center - Analytical_Slice_Data[FromNo - 1, 11])
                            / (Analytical_Slice_Data[FromNo - 1, 10] - X_Arc_Center)) * 180d / Math.PI,
                            2 * Circular_Arc_Angle);

                    Apply_Circular_Failure_plain(M_C, X_Arc_Center, Y_Arc_Center, Arc_Radius, Slice_Angle, FromNo, ToNo);//calculate bottom of each slice in soil and heigh and weight and water level

                    //                        for (A_factor = 0.5d; A_factor <= 0.99d; A_factor += 0.05d)
                    //                        {//critical a factor search start



                    //                    Excelcheck(0, SliceNo - 1, 0, 79, 1, FromNo, ToNo, 1000);

                    Kh = System.Convert.ToDouble(ModelDetail[3]);
                    Kv = System.Convert.ToDouble(ModelDetail[5]);

                    for (int i = 0; i < SliceNo; i++)
                    {
                        if (Analytical_Slice_Data[i, 29] == 2)//if soil
                        {
                            Analytical_Slice_Data[i, 70] = 0;
                            Analytical_Slice_Data[i, 72] = 0;
                            Analytical_Slice_Data[i, 74] = 0;
                            Analytical_Slice_Data[i, 75] = 0;
                            Analytical_Slice_Data[i, 76] = 0;
                            Analytical_Slice_Data[i, 77] = 0;
                            Analytical_Slice_Data[i, 78] = 0;
                            Analytical_Slice_Data[i, 79] = 0;
                            if (ModelDetail[7] == "Rock_Soil" || ModelDetail[7] == "Soil_Rock")
                            {//right forces
                                Analytical_Slice_Data[i, 69] = 0;
                                Analytical_Slice_Data[i, 71] = 0;
                                Analytical_Slice_Data[i, 73] = 0;
                            }
                        }
                    }
                    //                    Excelcheck(0, SliceNo - 1, 0, 79, 1, FromNo, ToNo, 1000);

                    if (ModelDetail[7] == "Soil_Rock")//to calculate right force and right force height of triangular Element
                    {
                        Analytical_Slice_Data[FromNo - 1, 69] = Analytical_Slice_Data[FromNo, 70] * (1 - Math.Pow((Analytical_Slice_Data[FromNo, 20]
                            - Analytical_Slice_Data[FromNo - 1, 18]) / (Analytical_Slice_Data[FromNo, 20]), 2));//right force using triangular distribution
                        Analytical_Slice_Data[FromNo - 1, 73] = (Analytical_Slice_Data[FromNo - 1, 18] / 6d)
                            * (3 + Analytical_Slice_Data[FromNo - 1, 18] / (2 * Analytical_Slice_Data[FromNo, 20] - Analytical_Slice_Data[FromNo - 1, 18]));//right force height
                    }

                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {//analytical calculation of all soil slices Start
                        if (Slice_Counter <= FromNo && Slice_Counter > ToNo)
                        {
                            //                                    K_factor = Analytical_Slice_Data[Slice_Counter - 1, 32] / Math.Sin(A_factor * Math.PI);
                            //                                    Analytical_Slice_Data[Slice_Counter - 1, 71] = K_factor * Math.Sin(((1 - A_factor)
                            //                                        * (System.Convert.ToDouble(Slice_Counter - ToNo)
                            //                                        / System.Convert.ToDouble(FromNo - ToNo)) + A_factor) * Math.PI);//Right Force angle
                            //                                    Analytical_Slice_Data[Slice_Counter - 1, 72] = K_factor * Math.Sin(((1 - A_factor)
                            //                                        * (System.Convert.ToDouble(Slice_Counter - ToNo - 1)
                            //                                        / System.Convert.ToDouble(FromNo - ToNo)) + A_factor) * Math.PI);//Left Force angle


                            if (ModelDetail[7] == "Soil")
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[FromNo - 1, 48])//in Slope that is the first at right
                                {
                                    FromPhi = 0;
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                                else
                                {
                                    FromPhi = Analytical_Slice_Data[Slice_Counter - 1, 63];
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                            }



                            if (ModelDetail[7] == "Rock_Soil")
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[FromNo - 1, 48])//in Slope that is the first at right
                                {
                                    FromPhi = 0;
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        if (Analytical_Slice_Data[ToNo - 1, 29] == 1)//rock intersection
                                        {
                                            ToPhi = Analytical_Slice_Data[ToNo - 1, 63];
                                        }
                                        else
                                            ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                                else
                                {
                                    FromPhi = Analytical_Slice_Data[Slice_Counter - 1, 63];
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        if (Analytical_Slice_Data[ToNo - 1, 29] == 1)//rock intersection
                                        {
                                            ToPhi = Analytical_Slice_Data[ToNo - 1, 63];
                                        }
                                        else
                                            ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                            }


                            if (ModelDetail[7] == "Soil_Rock")
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[FromNo - 1, 48])//in Slope that is the first at right
                                {
                                    if (Analytical_Slice_Data[FromNo, 29] == 1)//rock intersection
                                    {
                                        FromPhi = Analytical_Slice_Data[FromNo - 1, 63];
                                    }
                                    else
                                        FromPhi = 0;

                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[FromNo - 1, 46];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                                else
                                {
                                    FromPhi = Analytical_Slice_Data[Slice_Counter - 1, 63];
                                    if (Analytical_Slice_Data[Slice_Counter - 1, 48] == Analytical_Slice_Data[ToNo, 48])
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46] - Analytical_Slice_Data[ToNo, 46] + 1;
                                        ToPhi = 0;
                                    }
                                    else
                                    {
                                        ThisSlopeSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 44];
                                        ThisSliceNo = Analytical_Slice_Data[Slice_Counter - 1, 46];
                                        ToPhi = Analytical_Slice_Data[Slice_Counter - System.Convert.ToInt32(Analytical_Slice_Data[Slice_Counter - 1, 46]) - 1, 63];
                                    }
                                }
                            }


                            if (FromPhi == ToPhi)
                            {
                                if (ThisSlopeSliceNo % 2 == 0)
                                {
                                    if (ThisSliceNo > ThisSlopeSliceNo / 2d)
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 71] = FromPhi + 2d * (Analytical_Slice_Data[Slice_Counter - 1, 32] - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo) / (ThisSlopeSliceNo);//right force angle
                                        Analytical_Slice_Data[Slice_Counter - 1, 72] = FromPhi + 2d * (Analytical_Slice_Data[Slice_Counter - 1, 32] - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo + 1) / (ThisSlopeSliceNo);//Left force angle
                                    }
                                    else
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 71] = Analytical_Slice_Data[Slice_Counter - 1, 32] + (ToPhi - Analytical_Slice_Data[Slice_Counter - 1, 32]) * (ThisSlopeSliceNo / 2d - ThisSliceNo) / (ThisSlopeSliceNo / 2d);//right force angle
                                        Analytical_Slice_Data[Slice_Counter - 1, 72] = Analytical_Slice_Data[Slice_Counter - 1, 32] + (ToPhi - Analytical_Slice_Data[Slice_Counter - 1, 32]) * (ThisSlopeSliceNo / 2d - ThisSliceNo + 1) / (ThisSlopeSliceNo / 2d);//Left force angle
                                    }
                                }
                                else
                                {
                                    if (ThisSliceNo > (ThisSlopeSliceNo + 1) / 2d)
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 71] = FromPhi + 2d * (Analytical_Slice_Data[Slice_Counter - 1, 32] - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo) / (ThisSlopeSliceNo);//right force angle
                                        Analytical_Slice_Data[Slice_Counter - 1, 72] = FromPhi + 2d * (Analytical_Slice_Data[Slice_Counter - 1, 32] - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo + 1) / (ThisSlopeSliceNo);//Left force angle
                                    }
                                    else if (ThisSliceNo == 1 + (ThisSlopeSliceNo - 1) / 2d)
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 71] = FromPhi + 2d * (Analytical_Slice_Data[Slice_Counter - 1, 32] - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo) / (ThisSlopeSliceNo);//right force angle
                                        Analytical_Slice_Data[Slice_Counter - 1, 72] = Analytical_Slice_Data[Slice_Counter - 1, 32] + (ToPhi - Analytical_Slice_Data[Slice_Counter - 1, 32]) * (ThisSlopeSliceNo / 2d - ThisSliceNo + 1) / (ThisSlopeSliceNo / 2d);//Left force angle
                                    }
                                    else
                                    {
                                        Analytical_Slice_Data[Slice_Counter - 1, 71] = Analytical_Slice_Data[Slice_Counter - 1, 32] + (ToPhi - Analytical_Slice_Data[Slice_Counter - 1, 32]) * (ThisSlopeSliceNo / 2d - ThisSliceNo) / (ThisSlopeSliceNo / 2d);//right force angle
                                        Analytical_Slice_Data[Slice_Counter - 1, 72] = Analytical_Slice_Data[Slice_Counter - 1, 32] + (ToPhi - Analytical_Slice_Data[Slice_Counter - 1, 32]) * (ThisSlopeSliceNo / 2d - ThisSliceNo + 1) / (ThisSlopeSliceNo / 2d);//Left force angle
                                    }
                                }
                            }
                            else
                            {
                                Analytical_Slice_Data[Slice_Counter - 1, 71] = FromPhi + (ToPhi - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo) / ThisSlopeSliceNo;//right force angle
                                Analytical_Slice_Data[Slice_Counter - 1, 72] = FromPhi + (ToPhi - FromPhi) * (ThisSlopeSliceNo - ThisSliceNo + 1) / ThisSlopeSliceNo;//Left force angle
                            }

                            //                Excelcheck(0, SliceNo - 1, 0, 79, 1, FromNo, ToNo,1000);


                            Sin_Saay_R = Math.Sin(Analytical_Slice_Data[Slice_Counter - 1, 71] * Math.PI / 180);
                            Cos_Saay_R = Math.Cos(Analytical_Slice_Data[Slice_Counter - 1, 71] * Math.PI / 180);
                            Sin_Saay_L = Math.Sin(Analytical_Slice_Data[Slice_Counter - 1, 72] * Math.PI / 180);
                            Cos_Saay_L = Math.Cos(Analytical_Slice_Data[Slice_Counter - 1, 72] * Math.PI / 180);
                            Sin_Saay_b = Math.Sin((Analytical_Slice_Data[Slice_Counter - 1, 55] + Slice_Angle - 90) * Math.PI / 180);
                            Cos_Saay_b = Math.Cos((Analytical_Slice_Data[Slice_Counter - 1, 55] + Slice_Angle - 90) * Math.PI / 180);
                            Tan_Saay_b = Math.Tan((Analytical_Slice_Data[Slice_Counter - 1, 55] + Slice_Angle - 90) * Math.PI / 180);
                            Sin_Saay_C = Math.Sin(Slice_Angle * Math.PI / 180);
                            Cos_Saay_C = Math.Cos(Slice_Angle * Math.PI / 180);
                            Sin_Saay_Anch = Math.Sin((90 - Analytical_Slice_Data[Slice_Counter - 1, 27] - Slice_Angle) * Math.PI / 180);
                            Cos_Saay_Anch = Math.Cos((90 - Analytical_Slice_Data[Slice_Counter - 1, 27] - Slice_Angle) * Math.PI / 180);
                            Tan_Phi_Material = Math.Tan(Analytical_Slice_Data[Slice_Counter - 1, 32] * Math.PI / 180);
                            C_Material = Analytical_Slice_Data[Slice_Counter - 1, 30];
                            l_w_R = Analytical_Slice_Data[Slice_Counter - 1, 21];
                            l_w_L = Analytical_Slice_Data[Slice_Counter - 1, 23];
                            h_c = Analytical_Slice_Data[Slice_Counter - 1, 19];
                            h_Anch = Analytical_Slice_Data[Slice_Counter - 1, 20];
                            h_f_R = Analytical_Slice_Data[Slice_Counter - 1, 73];///
                            L = Analytical_Slice_Data[Slice_Counter - 1, 25];
                            W = Analytical_Slice_Data[Slice_Counter - 1, 24];
                            f_R = Analytical_Slice_Data[Slice_Counter - 1, 69];//////////////////////
                            f_L = Analytical_Slice_Data[Slice_Counter - 1, 70];///////////////////////
                            f_Anch = Analytical_Slice_Data[Slice_Counter - 1, 26];
                            t = Analytical_Slice_Data[Slice_Counter - 1, 43];

                            if (ModelDetail[7] == "Soil_Rock" && Slice_Counter == FromNo)
                            {
                                Sin_Saay_C_Int = Math.Sin((Analytical_Slice_Data[Slice_Counter, 49] - Analytical_Slice_Data[Slice_Counter - 1, 61]) * Math.PI / 180);
                                Cos_Saay_C_Int = Math.Cos((Analytical_Slice_Data[Slice_Counter, 49] - Analytical_Slice_Data[Slice_Counter - 1, 61]) * Math.PI / 180);
                                Cos_Phi_Int = Math.Cos(Analytical_Slice_Data[Slice_Counter - 1, 63] * Math.PI / 180);
                                l_R = Analytical_Slice_Data[Slice_Counter - 1, 18];

                                Analytical_Slice_Data[Slice_Counter - 1, 70] = Soil_Triangle_Element_Left_Force
                                                                            (Sin_Saay_C_Int, Cos_Saay_C_Int
                                                                            , Sin_Saay_L, Cos_Saay_L
                                                                            , Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                                            , Sin_Saay_C, Cos_Saay_C
                                                                            , Tan_Phi_Material
                                                                            , C_Material
                                                                            , l_w_R, l_w_L
                                                                            , l_R
                                                                            , W
                                                                            , f_R); //left force
                                if (Analytical_Slice_Data[Slice_Counter - 1, 70] < 0)
                                    Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;

                                f_L = Analytical_Slice_Data[Slice_Counter - 1, 70];
                                if (f_L > 0)
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Soil_Triangle_Element_Left_ForceHeight
                                                                            (Sin_Saay_C_Int, Cos_Saay_C_Int
                                                                            , Sin_Saay_L, Cos_Saay_L
                                                                            , Cos_Saay_b, Tan_Saay_b
                                                                            , Sin_Saay_C, Cos_Saay_C
                                                                            , Cos_Phi_Int
                                                                            , l_w_R, l_w_L
                                                                            , l_R
                                                                            , W
                                                                            , h_f_R
                                                                            , f_R
                                                                            , f_L); //left force height
                                else
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;
                            }

                            else
                            {
                                Analytical_Slice_Data[Slice_Counter - 1, 70] = Soil_Left_Force//////////////////left force
                                                                            (Sin_Saay_R, Cos_Saay_R
                                                                            , Sin_Saay_L, Cos_Saay_L
                                                                            , Sin_Saay_b, Cos_Saay_b
                                                                            , Sin_Saay_C, Cos_Saay_C
                                                                            , Sin_Saay_Anch, Cos_Saay_Anch
                                                                            , Tan_Phi_Material//////////////////SF
                                                                            , C_Material////////////////////////SF
                                                                            , l_w_R, l_w_L
                                                                            , L, W
                                                                            , f_R
                                                                            , f_Anch
                                                                            , t);
                                if (Analytical_Slice_Data[Slice_Counter - 1, 70] < 0)
                                    Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;

                                f_L = Analytical_Slice_Data[Slice_Counter - 1, 70];
                                if (f_L > 0)
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Soil_Left_ForceHeight
                                                                                (Sin_Saay_R, Cos_Saay_R
                                                                                , Sin_Saay_L, Cos_Saay_L
                                                                                , Sin_Saay_b, Cos_Saay_b, Tan_Saay_b
                                                                                , Sin_Saay_C, Cos_Saay_C
                                                                                , Sin_Saay_Anch, Cos_Saay_Anch
                                                                                , Tan_Phi_Material/////////////////////SF
                                                                                , l_w_R, l_w_L
                                                                                , h_c
                                                                                , h_Anch
                                                                                , L, W
                                                                                , h_f_R
                                                                                , f_R
                                                                                , f_L
                                                                                , f_Anch
                                                                                , t); //left force height
                                else
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;

                            }



                            if (Analytical_Slice_Data[Slice_Counter - 1, 74] < 0)//if left force height is negative or too high
                            {
                                Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;
                                Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;
                            }

                            if (Slice_Counter > 1)
                            {
                                if (Analytical_Slice_Data[Slice_Counter - 1, 74] > Analytical_Slice_Data[Slice_Counter - 1, 20])//if left force height is negative or too high
                                {
                                    Analytical_Slice_Data[Slice_Counter - 1, 74] = Analytical_Slice_Data[Slice_Counter - 1, 20];
                                    Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force of next slice
                                    Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 2, 18] * 2d / 3d;//right force height of next slice

                                    //                                    Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;
                                }
                                else
                                {
                                    Analytical_Slice_Data[Slice_Counter - 2, 69] = Analytical_Slice_Data[Slice_Counter - 1, 70];//right force of next slice
                                    Analytical_Slice_Data[Slice_Counter - 2, 73] = Analytical_Slice_Data[Slice_Counter - 1, 74];//right force height of next slice
                                }
                            }


                            if (Analytical_Slice_Data[Slice_Counter - 1, 70] > 0)//failure mode
                                Analytical_Slice_Data[Slice_Counter - 1, 79] = 5;
                            else
                                Analytical_Slice_Data[Slice_Counter - 1, 79] = 0;
                        }

                        else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)//soil
                        {
                            Analytical_Slice_Data[Slice_Counter - 1, 69] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 70] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 71] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 72] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 73] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 74] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 75] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 76] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 77] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 78] = 0;//
                            Analytical_Slice_Data[Slice_Counter - 1, 79] = 6;//out of range
                        }
                    }//analytical calculation of all soil slices End
                     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                     //                    if (Rad_Btn_Sensitivity_Analysis.Checked == true)
                     //                        EXCEL_Analytical_Critical_Situation();
                    if (Exact_Slip_Surfaces_FOS_flag == false)
                        Critical_Situation_Registration(FromNo, ToNo, UpNo, DwnNo);
                    else
                        Critical_Situation_Registration_onExactSurfaseinSoil(FromNo, ToNo, UpNo, DwnNo);
                    //                    Reset_Analytical_Data_Array(ToNo, SliceNo-1);
                    //                    Reset_Critical_Data_Array(ToNo + 1, SliceNo + 1);

                }//circular failure plane search End



                //                Excelcheck(0, SliceNo - 1, 0, 79, 1, FromNo, ToNo,1000);

            }//tenstion crack depth search End
             ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (Unstable_Found == true && Exact_Slip_Surfaces_FOS_flag == false)
            {
                for (int i = 0; i < SliceNo; i++)
                    for (int j = 0; j < 80; j++)
                        Analytical_Slice_Data[i, j] = Temp_Analytical_Slice_Data[i, j];//to Retrive All data of the worst case situation for post Calculation
            }
            //            if(ToNo>0)
            //            {
            //                Analytical_Slice_Data[ToNo - 1, 69] = Analytical_Slice_Data[ToNo, 70];
            //                Analytical_Slice_Data[ToNo - 1, 71] = Analytical_Slice_Data[ToNo, 72];
            //                Analytical_Slice_Data[ToNo - 1, 73] = Analytical_Slice_Data[ToNo, 74];
            //            }
        }

        private void Apply_Circular_Failure_plain(
            double M_C,
            double X_Arc_Center,
            double Y_Arc_Center,
            double Arc_Radius,
            double Slice_Angle,
            int FromNo,
            int ToNo)
        {
            double A = 0, B = 0, C = 0;
            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)//compleat each soil slice data
            {
                if ((Slice_Counter > FromNo || Slice_Counter <= ToNo) && Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)//right slices that is behind tension crack
                {
                    Analytical_Slice_Data[Slice_Counter - 1, 6] = Analytical_Slice_Data[Slice_Counter - 1, 0];//XBL
                    Analytical_Slice_Data[Slice_Counter - 1, 7] = Analytical_Slice_Data[Slice_Counter - 1, 1];//YBL
                    Analytical_Slice_Data[Slice_Counter - 1, 8] = Analytical_Slice_Data[Slice_Counter - 1, 2];//XBM
                    Analytical_Slice_Data[Slice_Counter - 1, 9] = Analytical_Slice_Data[Slice_Counter - 1, 3];//YBM
                    Analytical_Slice_Data[Slice_Counter - 1, 10] = Analytical_Slice_Data[Slice_Counter - 1, 4];//XBR
                    Analytical_Slice_Data[Slice_Counter - 1, 11] = Analytical_Slice_Data[Slice_Counter - 1, 5];//YBR
                    Analytical_Slice_Data[Slice_Counter - 1, 18] = 0;//Block right height
                    Analytical_Slice_Data[Slice_Counter - 1, 19] = 0;//block middle height
                    Analytical_Slice_Data[Slice_Counter - 1, 20] = 0;//block left height
                    Analytical_Slice_Data[Slice_Counter - 1, 21] = 0;//WR height
                    Analytical_Slice_Data[Slice_Counter - 1, 22] = 0;//WM height
                    Analytical_Slice_Data[Slice_Counter - 1, 23] = 0;//WL Height
                    Analytical_Slice_Data[Slice_Counter - 1, 24] = 0;//Block Weight
                    Analytical_Slice_Data[Slice_Counter - 1, 55] = 0;//Basal angle
                }

                else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)
                {
                    A = 1 + (1 / Math.Pow(M_C, 2));
                    B = -2 * (Y_Arc_Center + (Analytical_Slice_Data[Slice_Counter - 1, 1] / M_C
                        + X_Arc_Center - Analytical_Slice_Data[Slice_Counter - 1, 0]) / M_C);
                    C = Math.Pow(X_Arc_Center, 2) + Math.Pow(Y_Arc_Center, 2) + Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 0], 2)
                        - Math.Pow(Arc_Radius, 2) - 2 * X_Arc_Center * Analytical_Slice_Data[Slice_Counter - 1, 0]
                        + (Analytical_Slice_Data[Slice_Counter - 1, 1] / M_C)
                        * ((Analytical_Slice_Data[Slice_Counter - 1, 1] / M_C) + 2 * (X_Arc_Center - Analytical_Slice_Data[Slice_Counter - 1, 0]));

                    Analytical_Slice_Data[Slice_Counter - 1, 7] = (-B + Math.Sqrt(B * B - 4 * A * C)) / (2 * A);//YBL
                    if ((-B - Math.Sqrt(B * B - 4 * A * C)) / (2 * A) < Analytical_Slice_Data[Slice_Counter - 1, 7])
                        Analytical_Slice_Data[Slice_Counter - 1, 7] = (-B - Math.Sqrt(B * B - 4 * A * C)) / (2 * A);

                    Analytical_Slice_Data[Slice_Counter - 1, 6] = ((Analytical_Slice_Data[Slice_Counter - 1, 7]//XBL
                        - Analytical_Slice_Data[Slice_Counter - 1, 1]) / M_C) + Analytical_Slice_Data[Slice_Counter - 1, 0];

                    Analytical_Slice_Data[Slice_Counter - 1, 8] = (Analytical_Slice_Data[Slice_Counter - 1, 6]
                        + Analytical_Slice_Data[Slice_Counter - 1, 10]) / 2;//XBM
                    Analytical_Slice_Data[Slice_Counter - 1, 9] = (Analytical_Slice_Data[Slice_Counter - 1, 7]
                        + Analytical_Slice_Data[Slice_Counter - 1, 11]) / 2;//YBM

                    if (Slice_Counter > 1 && Slice_Counter - 2 >= ToNo)
                    {
                        Analytical_Slice_Data[Slice_Counter - 2, 10] = Analytical_Slice_Data[Slice_Counter - 1, 6];//XBR next slice
                        Analytical_Slice_Data[Slice_Counter - 2, 11] = Analytical_Slice_Data[Slice_Counter - 1, 7];//YBR next slice
                    }

                    Analytical_Slice_Data[Slice_Counter - 1, 18] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 4]
                        - Analytical_Slice_Data[Slice_Counter - 1, 10], 2)
                        + Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 5] - Analytical_Slice_Data[Slice_Counter - 1, 11], 2));//block right height
                    Analytical_Slice_Data[Slice_Counter - 1, 20] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 0]
                        - Analytical_Slice_Data[Slice_Counter - 1, 6], 2)
                        + Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 1] - Analytical_Slice_Data[Slice_Counter - 1, 7], 2));//block left height
                    Analytical_Slice_Data[Slice_Counter - 1, 19] = (Analytical_Slice_Data[Slice_Counter - 1, 18]
                        + Analytical_Slice_Data[Slice_Counter - 1, 20]) / 2d;//block mean height
                    Analytical_Slice_Data[Slice_Counter - 1, 21] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 16]
                        - Analytical_Slice_Data[Slice_Counter - 1, 10], 2)
                        + Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 17] - Analytical_Slice_Data[Slice_Counter - 1, 11], 2));//water right height
                    Analytical_Slice_Data[Slice_Counter - 1, 23] = Math.Sqrt(Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 12]
                        - Analytical_Slice_Data[Slice_Counter - 1, 6], 2)
                        + Math.Pow(Analytical_Slice_Data[Slice_Counter - 1, 13] - Analytical_Slice_Data[Slice_Counter - 1, 7], 2));//water left height
                    if (Analytical_Slice_Data[Slice_Counter - 1, 17] < Analytical_Slice_Data[Slice_Counter - 1, 11])//if water level is under basal plane
                        Analytical_Slice_Data[Slice_Counter - 1, 21] = 0;
                    if (Analytical_Slice_Data[Slice_Counter - 1, 13] < Analytical_Slice_Data[Slice_Counter - 1, 7])//if water level is under basal plane
                        Analytical_Slice_Data[Slice_Counter - 1, 23] = 0;
                    Analytical_Slice_Data[Slice_Counter - 1, 22] = (Analytical_Slice_Data[Slice_Counter - 1, 21]
                        + Analytical_Slice_Data[Slice_Counter - 1, 23]) / 2;//water mean height


                    if (ModelDetail[7] == "Soil_Rock" && Slice_Counter == FromNo)
                    {
                        Analytical_Slice_Data[Slice_Counter - 1, 24] = (Analytical_Slice_Data[Slice_Counter - 1, 1] - Analytical_Slice_Data[Slice_Counter - 1, 7])
                            * (Analytical_Slice_Data[Slice_Counter - 1, 10] - Analytical_Slice_Data[Slice_Counter - 1, 6]) * Analytical_Slice_Data[Slice_Counter - 1, 34] / 2d;//block weight (newton)
                        Analytical_Slice_Data[Slice_Counter - 1, 43] = (Analytical_Slice_Data[Slice_Counter - 1, 10] - Analytical_Slice_Data[Slice_Counter - 1, 6]) / 2d;//mean triangular soli element Thickness
                    }
                    else
                    {
                        Analytical_Slice_Data[Slice_Counter - 1, 24] = Analytical_Slice_Data[Slice_Counter - 1, 43]
                            * Analytical_Slice_Data[Slice_Counter - 1, 19] * Analytical_Slice_Data[Slice_Counter - 1, 34];//block weight (newton)
                    }

                    Analytical_Slice_Data[Slice_Counter - 1, 55] = Math.Atan((Analytical_Slice_Data[Slice_Counter - 1, 11]
                        - Analytical_Slice_Data[Slice_Counter - 1, 7]) / (Analytical_Slice_Data[Slice_Counter - 1, 10]
                        - Analytical_Slice_Data[Slice_Counter - 1, 6])) * 180 / Math.PI;//Basal angle
                }
            }
            //check point 5
            //               Excelcheck(0, SliceNo - 1, 0, 79, 1, FromNo, ToNo,1000);
        }

        private void Critical_Situation_Registration_onExactSurfaseinSoil(int FromNo, int ToNo, int UpNo, int DwnNo)
        {
            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
            {
                Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                    Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 0)

                    Analytical_Critical_Situation[Slice_Counter, 12] = "Stable";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 5)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Unstable";
                if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 6)
                    Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                if (Slice_Counter <= FromNo && Slice_Counter > ToNo)
                {
                    Analytical_Critical_Situation[Slice_Counter, 2] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 19]);//column Height
                    Analytical_Critical_Situation[Slice_Counter, 3] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 24]);//column Weight

                    Analytical_Critical_Situation[Slice_Counter, 4] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 55]);//Basal Angle
                    Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 72]);//Left Force Angle

                    Analytical_Critical_Situation[Slice_Counter, 5] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 75]);//Sliding force
                    Analytical_Critical_Situation[Slice_Counter, 6] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 76]);//Toppling Force
                    Analytical_Critical_Situation[Slice_Counter, 7] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 77]);//Flrxur force
                    Analytical_Critical_Situation[Slice_Counter, 8] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 78]);//shear force
                    Analytical_Critical_Situation[Slice_Counter, 9] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 70]);//Left Force
                    Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 74]);//Left Force Height
                    if (Slice_Counter == 1 && System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)
                        Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d);


                    Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                }
                else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == Analytical_Slice_Data[FromNo - 1, 29])
                {
                    Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                    Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";

                    Analytical_Critical_Situation[Slice_Counter, 2] = "-----";//column Height
                    Analytical_Critical_Situation[Slice_Counter, 3] = "-----";//column Weight
                    Analytical_Critical_Situation[Slice_Counter, 4] = "-----";//Basal Angle
                    Analytical_Critical_Situation[Slice_Counter, 11] = "-----";//Left Force Angle

                    Analytical_Critical_Situation[Slice_Counter, 5] = "-----";//Sliding force
                    Analytical_Critical_Situation[Slice_Counter, 6] = "-----";//Toppling Force
                    Analytical_Critical_Situation[Slice_Counter, 7] = "-----";//Flrxur force
                    Analytical_Critical_Situation[Slice_Counter, 8] = "-----";//shear force
                    Analytical_Critical_Situation[Slice_Counter, 9] = "-----";//Left Force
                    Analytical_Critical_Situation[Slice_Counter, 10] = "-----";//Left Force Height

                    Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                    Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                    Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                }
            }

            if (Analytical_Slice_Data[ToNo, 70] > 0)
                Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
            else
                Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
            for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
            {
                if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                {
                    if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                    {
                        Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                        Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                        Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                        Slice_Counter = 0;//to exit loop
                    }
                    else if (Slice_Counter == 1)
                    {
                        Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                        Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                        Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                    }
                }
            }
            Analytical_Critical_Situation[0, 4] = ToSientific(System.Convert.ToString(Arc_Radius));//Circular failure plain Radius
            Analytical_Critical_Situation[0, 5] = ToSientific(System.Convert.ToString(Circular_Arc_Angle));
            Analytical_Critical_Situation[0, 6] = ToSientific(System.Convert.ToString(X_Arc_Center));
            Analytical_Critical_Situation[0, 7] = ToSientific(System.Convert.ToString(Y_Arc_Center));
            Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
            Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
            Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);
            Analytical_Critical_Situation[0, 11] = System.Convert.ToString(Tension_Crack_Step);//Tension Crack Step
        }

        private void Critical_Situation_Registration(int FromNo, int ToNo, int UpNo, int DwnNo)
        {
            this_is_Worst_Case_Ever = false;

            for (int Column_Counter = ToNo; Column_Counter < FromNo; Column_Counter++)//TO find first Unstable block ot Slice in past Critical Situation
            {
                if ((Analytical_Critical_Situation[Column_Counter + 1, 12] != "-----" && Analytical_Critical_Situation[Column_Counter + 1, 12] != "Stable"
                    && Analytical_Critical_Situation[Column_Counter + 1, 12] != "Out" && Analytical_Critical_Situation[Column_Counter + 1, 12] != null) || Column_Counter + 1 == FromNo)
                {
                    if (Analytical_Critical_Situation[Column_Counter + 1, 9] == null || Analytical_Critical_Situation[Column_Counter + 1, 9] == "-----")
                        Analytical_Critical_Situation[Column_Counter + 1, 9] = "0";
                    for (int Column_Counter2 = ToNo; Column_Counter2 <= Column_Counter; Column_Counter2++)//to find first Unstable Column or Slice in this just Calculation
                    {
                        if ((Analytical_Slice_Data[Column_Counter2, 70] > System.Convert.ToDouble(Analytical_Critical_Situation[Column_Counter + 1, 9]))
                            || (Analytical_Slice_Data[Column_Counter2, 70] > 0 && Column_Counter2 < Column_Counter))//
                        {
                            this_is_Worst_Case_Ever = true;
                            Column_Counter2 = FromNo;//to exit finding unstable parts
                        }
                    }
                    Column_Counter = FromNo;//to exit finding unstable parts
                }
            }//IF THIS CASE IS WORST --> true else --> false

            if (this_is_Worst_Case_Ever == true)
            {
                for (int i = 0; i < SliceNo; i++)
                    for (int j = 0; j < 80; j++)
                        Temp_Analytical_Slice_Data[i, j] = Analytical_Slice_Data[i, j];//to save All data at the worst case situation for post Calculation
                Unstable_Found = true;


                for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                {
                    Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 1)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "Rock";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 3)
                        Analytical_Critical_Situation[Slice_Counter, 1] = "BIM";
                    //                        Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 72]);//Left Force Angle
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 0)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Stable";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 1)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Slide";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 2)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Topple";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 3)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Flexur";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 4)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Shear";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 5)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Unstable";
                    if (Analytical_Slice_Data[Slice_Counter - 1, 79] == 6)
                        Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                    if (Slice_Counter <= FromNo && Slice_Counter > ToNo)
                    {
                        Analytical_Critical_Situation[Slice_Counter, 2] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 19]);//column Height
                        Analytical_Critical_Situation[Slice_Counter, 3] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 24]);//column Weight
                        if (Analytical_Critical_Situation[Slice_Counter, 1] == "Rock")
                        {
                            Analytical_Critical_Situation[Slice_Counter, 4] = System.Convert.ToString(90 - Analytical_Slice_Data[Slice_Counter - 1, 49] + base_Rock_breakage_angle);//Basal Angle
                            Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(0);//Left Force Angle
                        }
                        else if (Analytical_Critical_Situation[Slice_Counter, 1] == "Soil")
                        {
                            Analytical_Critical_Situation[Slice_Counter, 4] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 55]);//Basal Angle
                            Analytical_Critical_Situation[Slice_Counter, 11] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 72]);//Left Force Angle
                        }

                        Analytical_Critical_Situation[Slice_Counter, 5] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 75]);//Sliding force
                        Analytical_Critical_Situation[Slice_Counter, 6] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 76]);//Toppling Force
                        Analytical_Critical_Situation[Slice_Counter, 7] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 77]);//Flrxur force
                        Analytical_Critical_Situation[Slice_Counter, 8] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 78]);//shear force
                        Analytical_Critical_Situation[Slice_Counter, 9] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 70]);//Left Force
                        Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 74]);//Left Force Height
                        if (Slice_Counter == 1 && System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)
                            Analytical_Critical_Situation[Slice_Counter, 10] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18] / 2d);


                        Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                    }
                    else if (Analytical_Slice_Data[Slice_Counter - 1, 29] == Analytical_Slice_Data[FromNo - 1, 29])
                    {
                        Analytical_Critical_Situation[Slice_Counter, 0] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 47]);//column No

                        if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 1)
                            Analytical_Critical_Situation[Slice_Counter, 1] = "Rock";
                        if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 2)
                            Analytical_Critical_Situation[Slice_Counter, 1] = "Soil";
                        if (Analytical_Slice_Data[Slice_Counter - 1, 29] == 3)
                            Analytical_Critical_Situation[Slice_Counter, 1] = "BIM";

                        Analytical_Critical_Situation[Slice_Counter, 2] = "-----";//column Height
                        Analytical_Critical_Situation[Slice_Counter, 3] = "-----";//column Weight
                        Analytical_Critical_Situation[Slice_Counter, 4] = "-----";//Basal Angle
                        Analytical_Critical_Situation[Slice_Counter, 11] = "-----";//Left Force Angle

                        Analytical_Critical_Situation[Slice_Counter, 5] = "-----";//Sliding force
                        Analytical_Critical_Situation[Slice_Counter, 6] = "-----";//Toppling Force
                        Analytical_Critical_Situation[Slice_Counter, 7] = "-----";//Flrxur force
                        Analytical_Critical_Situation[Slice_Counter, 8] = "-----";//shear force
                        Analytical_Critical_Situation[Slice_Counter, 9] = "-----";//Left Force
                        Analytical_Critical_Situation[Slice_Counter, 10] = "-----";//Left Force Height

                        Analytical_Critical_Situation[Slice_Counter, 12] = "Out";

                        Analytical_Critical_Situation[Slice_Counter, 13] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 6]);//X Left Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 14] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 7]);//Y Left Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 15] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 8]);//X Middle Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 16] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 9]);//Y Middle Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 17] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 10]);//X Right Basal plane (Critical Situation)
                        Analytical_Critical_Situation[Slice_Counter, 18] = System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 11]);//Y Right Basal plane (Critical Situation)
                    }
                }


                if (ModelDetail[7] == "Soil")
                {
                    if (Analytical_Slice_Data[ToNo, 70] > 0)
                        Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
                    else
                        Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {
                        if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                        {
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                            {
                                Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                                Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                                Slice_Counter = 0;//to exit loop
                            }
                            else if (Slice_Counter == 1)
                            {
                                Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                                Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                            }
                        }
                    }
                    Analytical_Critical_Situation[0, 4] = ToSientific(System.Convert.ToString(Arc_Radius));//Circular failure plain Radius
                    Analytical_Critical_Situation[0, 5] = ToSientific(System.Convert.ToString(Circular_Arc_Angle));
                    Analytical_Critical_Situation[0, 6] = ToSientific(System.Convert.ToString(X_Arc_Center));
                    Analytical_Critical_Situation[0, 7] = ToSientific(System.Convert.ToString(Y_Arc_Center));
                    Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
                    Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
                    Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);
                    Analytical_Critical_Situation[0, 11] = System.Convert.ToString(Tension_Crack_Step);//Tension Crack Step
                }

                if (ModelDetail[7] == "Rock")
                {
                    if (Analytical_Slice_Data[ToNo, 70] > 0)
                        Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
                    else
                        Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {
                        if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                        {
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                            {
                                Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                                Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                                Slice_Counter = 0;//to exit loop
                            }
                            else if (Slice_Counter == 1)
                            {
                                Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                                Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                            }
                        }
                    }
                    Analytical_Critical_Situation[0, 4] = "-----";//Circular failure plain Radius
                    Analytical_Critical_Situation[0, 5] = "-----";
                    Analytical_Critical_Situation[0, 6] = "-----";
                    Analytical_Critical_Situation[0, 7] = "-----";
                    Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
                    Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
                    Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);
                    Analytical_Critical_Situation[0, 11] = "-----";//Tension Crack Step
                }


                if (ModelDetail[7] == "Soil_Rock")
                {
                    if (Analytical_Slice_Data[ToNo, 70] > 0)
                        Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
                    else
                        Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {
                        if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                        {
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                            {
                                Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                                Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                                Slice_Counter = 0;//to exit loop
                            }
                            else if (Slice_Counter == 1)
                            {
                                Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                                Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                            }
                        }
                    }
                    if (Analytical_Slice_Data[FromNo - 1, 29] == 2)//soil
                    {
                        Analytical_Critical_Situation[0, 4] = ToSientific(System.Convert.ToString(Arc_Radius));//Circular failure plain Radius
                        Analytical_Critical_Situation[0, 5] = ToSientific(System.Convert.ToString(Circular_Arc_Angle));
                        Analytical_Critical_Situation[0, 6] = ToSientific(System.Convert.ToString(X_Arc_Center));
                        Analytical_Critical_Situation[0, 7] = ToSientific(System.Convert.ToString(Y_Arc_Center));
                        Analytical_Critical_Situation[0, 11] = System.Convert.ToString(Tension_Crack_Step);//Tension Crack Step
                    }
                    Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
                    Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
                    Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);

                }


                if (ModelDetail[7] == "Rock_Soil")
                {
                    if (Analytical_Slice_Data[ToNo, 70] > 0)
                        Analytical_Critical_Situation[0, 0] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[ToNo, 70]));// Final stability Force
                    else
                        Analytical_Critical_Situation[0, 0] = "Stable";// Final stability Force
                    for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                    {
                        if (Analytical_Critical_Situation[Slice_Counter, 9] != "-----")
                        {
                            if (System.Convert.ToDouble(Analytical_Critical_Situation[Slice_Counter, 9]) > 0)//to find first un stable block
                            {
                                Analytical_Critical_Situation[0, 1] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 4]));//X of tension crack
                                Analytical_Critical_Situation[0, 2] = ToSientific(System.Convert.ToString(Analytical_Slice_Data[Slice_Counter - 1, 18]));//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = System.Convert.ToString(Slice_Counter);//tention crack block no
                                Slice_Counter = 0;//to exit loop
                            }
                            else if (Slice_Counter == 1)
                            {
                                Analytical_Critical_Situation[0, 1] = "-----";//X of tension crack
                                Analytical_Critical_Situation[0, 2] = "-----";//depth of tension crack
                                Analytical_Critical_Situation[0, 3] = "-----";//tention crack block no
                            }
                        }
                    }
                    if (Analytical_Slice_Data[ToNo, 29] == 2)//soil
                    {
                        Analytical_Critical_Situation[0, 4] = ToSientific(System.Convert.ToString(Arc_Radius));//Circular failure plain Radius
                        Analytical_Critical_Situation[0, 5] = ToSientific(System.Convert.ToString(Circular_Arc_Angle));
                        Analytical_Critical_Situation[0, 6] = ToSientific(System.Convert.ToString(X_Arc_Center));
                        Analytical_Critical_Situation[0, 7] = ToSientific(System.Convert.ToString(Y_Arc_Center));
                        Analytical_Critical_Situation[0, 11] = System.Convert.ToString(Tension_Crack_Step);//Tension Crack Step
                    }
                    Analytical_Critical_Situation[0, 8] = System.Convert.ToString(SliceNo);//Slice No
                    Analytical_Critical_Situation[0, 9] = System.Convert.ToString(UpNo);
                    Analytical_Critical_Situation[0, 10] = System.Convert.ToString(DwnNo + 1);
                }
            }
        }

        private List<List<string>> Save_Critical_Table_List()
        {
            List<List<string>> Model_Critical_Table_List = new List<List<string>>();
            Model_Critical_Table_List.Clear();
            for (int RowNo = 0; RowNo < SliceNo + 1; RowNo++)
                Model_Critical_Table_List.Add(Save_Critical_Column(RowNo));
            return Model_Critical_Table_List;
        }

        private List<string> Save_Critical_Column(int RowNo)
        {
            List<string> Model_Critical_Column_List = new List<string>();
            Model_Critical_Column_List.Clear();
            for (int ClmNo = 0; ClmNo < 19; ClmNo++)
                Model_Critical_Column_List.Add(System.Convert.ToString(Analytical_Critical_Situation[RowNo, ClmNo]));
            return Model_Critical_Column_List;
        }

        private void Update_Result_DGV(int Critical_Situ_No)
        {
            for (int i = SliceNo; i > 0; i--)
            {
                DGVAnalytical_Output.Rows.Add();

                DGVAnalytical_Output.Rows[SliceNo - i].Cells[0].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 0];
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[1].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 1];
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[2].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 2]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[3].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 3]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[4].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 4]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[5].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 5]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[6].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 6]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[7].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 7]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[8].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 8]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[9].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 9]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[10].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 10]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[11].Value = ToSientific(Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 11]);
                DGVAnalytical_Output.Rows[SliceNo - i].Cells[12].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, i, 12];
            }


            DGVAnalytical_Report.Rows[0].Cells[0].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 0];//Report Final stability Force
            DGVAnalytical_Report.Rows[0].Cells[1].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 1];//Report X of tension crack
            DGVAnalytical_Report.Rows[0].Cells[2].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 2];//Report depth of tension crack
            DGVAnalytical_Report.Rows[0].Cells[3].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 3];//Report tension crack block no
            DGVAnalytical_Report.Rows[0].Cells[4].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 4];//Report Circular failure plain Radius

            DGVAnalytical_Report.Rows[0].Cells[5].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 5];//Report Circular Arc Angle
            DGVAnalytical_Report.Rows[0].Cells[6].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 6];//Report X Arc Center
            DGVAnalytical_Report.Rows[0].Cells[7].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 7];//Report Y Arc Center
            DGVAnalytical_Report.Rows[0].Cells[8].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 8];//Report Slice No
            DGVAnalytical_Report.Rows[0].Cells[9].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 9];//Report FromNo
            DGVAnalytical_Report.Rows[0].Cells[10].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 10];//Report To NO
            DGVAnalytical_Report.Rows[0].Cells[11].Value = Sorted_Critical_Situation_Charts[Critical_Situ_No, 0, 11];//Report TenstionCrack Step
            if ((ModelDetail[7] == "Soil" || ModelDetail[7] == "Rock") && fully_Stable_flag == false)
            {
                DGVAnalytical_Report.Rows[0].Cells[12].Value = System.Convert.ToString(Sorted_All_Slip_Surfase_FOS[Critical_Situ_No]);//Report FOS
                if (Sorted_All_Slip_Surfase_FOS[Critical_Situ_No] >= 1)
                    DGVAnalytical_Report.Rows[0].Cells[12].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                else
                    DGVAnalytical_Report.Rows[0].Cells[12].Style.BackColor = Color.FromArgb(255, 255, 155, 155);
            }

        }

        private double Soil_Left_Force
            (double Sin_Saay_R, double Cos_Saay_R
            , double Sin_Saay_L, double Cos_Saay_L
            , double Sin_Saay_b, double Cos_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Sin_Saay_Anch, double Cos_Saay_Anch
            , double Tan_Phi_Material
            , double C_Material
            , double l_w_R, double l_w_L
            , double L, double W
            , double f_R
            , double f_Anch
            , double t)
        {
            double A = 0;
            double B = 0;
            double Gama_Prime = 0;
            double[] Kesi = new double[7];


            A = Sin_Saay_b - Tan_Phi_Material * Cos_Saay_b;//phi is phi of soil
            B = Cos_Saay_b + Tan_Phi_Material * Sin_Saay_b;//phi is phi of soil
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = A * Sin_Saay_R + B * Cos_Saay_R;
            Kesi[1] = A * ((1d + Kv) * Sin_Saay_C - Kh * Cos_Saay_C)
                + B * ((1d + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = -t / Cos_Saay_b;
            Kesi[3] = A * Sin_Saay_Anch - B * Cos_Saay_Anch;
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 2d) * ((t / Cos_Saay_b) * Tan_Phi_Material + B * l_w_R);
            Kesi[5] = (Gama_Prime * Sin_Saay_C / 2d) * ((t / Cos_Saay_b) * Tan_Phi_Material - B * l_w_L);
            Kesi[6] = A * Sin_Saay_L + B * Cos_Saay_L;
            return (Math.Round((f_R * Kesi[0] + (L + W) * Kesi[1] + C_Material * Kesi[2] + f_Anch * Kesi[3]
                + l_w_R * Kesi[4] + l_w_L * Kesi[5]) / Kesi[6],0));
        }

        private double Soil_Triangle_Element_Left_Force
            (double Sin_Saay_C_Int, double Cos_Saay_C_Int
            , double Sin_Saay_L, double Cos_Saay_L
            , double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Tan_Phi_Material
            , double C_Material
            , double l_w_R, double l_w_L
            , double l_R
            , double W
            , double f_R)
        {
            double A = 0;
            double B = 0;
            double Gama_Prime = 0;
            double[] Kesi = new double[6];


            A = Sin_Saay_b - Tan_Phi_Material * Cos_Saay_b;//phi is phi of soil
            B = Cos_Saay_b + Tan_Phi_Material * Sin_Saay_b;//phi is phi of soil
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = A * Cos_Saay_C_Int + B * Sin_Saay_C_Int;
            Kesi[1] = A * (1d + Kv) + B * Kh;
            Kesi[2] = -(l_R * Cos_Saay_C) / Cos_Saay_b;
            Kesi[3] = (Gama_Prime * Sin_Saay_C / 2d) * (l_w_R * (A * Cos_Saay_C + B * Sin_Saay_C) - l_R * Cos_Saay_C * (A - B * Tan_Saay_b));
            Kesi[4] = -(Gama_Prime / 2d) * (l_w_L * B + l_R * Cos_Saay_C * (A - B * Tan_Saay_b));
            Kesi[5] = A * Sin_Saay_L + B * Cos_Saay_L;
            return (Math.Round((f_R * Kesi[0] + W * Kesi[1] + C_Material * Kesi[2]
                + l_w_R * Kesi[3] + l_w_L * Kesi[4]) / Kesi[5],0));
        }

        private double Soil_Left_ForceHeight
            (double Sin_Saay_R, double Cos_Saay_R
            , double Sin_Saay_L, double Cos_Saay_L
            , double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Sin_Saay_Anch, double Cos_Saay_Anch
            , double Tan_Phi_Material
            , double l_w_R, double l_w_L
            , double h_c
            , double h_Anch
            , double L, double W
            , double h_f_R
            , double f_R
            , double f_L
            , double f_Anch
            , double t)
        {
            double Gama_Prime = 0;
            double[] Kesi = new double[5];

            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = (t / 2d) * (Cos_Saay_L * Tan_Saay_b - Sin_Saay_L);
            Kesi[1] = (t / 2d) * (Cos_Saay_R * Tan_Saay_b - Sin_Saay_R) + h_f_R * Cos_Saay_R;
            Kesi[2] = (t / 2d) * (Cos_Saay_Anch * Tan_Saay_b + Sin_Saay_Anch) - h_Anch * Cos_Saay_Anch;
            Kesi[3] = h_c * ((1d + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 2d) * ((Math.Pow(l_w_R, 3) - Math.Pow(l_w_L, 3)) / 3d
                + t * Tan_Saay_b * (Math.Pow(l_w_R, 2) + Math.Pow(l_w_L, 2)) / 2d + Math.Pow(t, 2)
                * (l_w_R - l_w_L) / (6 * Cos_Saay_b));
            return (Math.Round((f_L * Kesi[0] + f_R * Kesi[1] + f_Anch * Kesi[2] + (L + W / 2d)
                * Kesi[3] + Kesi[4]) / (f_L * Cos_Saay_L),4));
        }

        private double Soil_Triangle_Element_Left_ForceHeight
            (double Sin_Saay_C_Int, double Cos_Saay_C_Int
            , double Sin_Saay_L, double Cos_Saay_L
            , double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Cos_Phi_Int
            , double l_w_R, double l_w_L
            , double l_R
            , double W
            , double h_f_R
            , double f_R
            , double f_L)
        {
            double Gama_Prime = 0;
            double[] Kesi = new double[4];

            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = (l_R * Cos_Saay_C / 2d) * (Cos_Saay_L * Tan_Saay_b - Sin_Saay_L);
            Kesi[1] = (l_R * Cos_Saay_C / 2d) * (Sin_Saay_C_Int * Tan_Saay_b - Cos_Saay_C_Int) + h_f_R * Cos_Phi_Int;
            Kesi[2] = (l_R / 6d) * ((1d + Kv) * Cos_Saay_C + Kh * (2 * Sin_Saay_C + Cos_Saay_C * Tan_Saay_b));
            Kesi[3] = (Gama_Prime * Sin_Saay_C / 2d) * ((Math.Pow(l_w_R, 3) - Math.Pow(l_w_L, 3) / Sin_Saay_C) / 3d
                + (l_R * Cos_Saay_C / 2d) * (Math.Pow(l_w_R, 2) * (Sin_Saay_C * Tan_Saay_b - Cos_Saay_C) + Math.Pow(l_w_L, 2) * Tan_Saay_b / Sin_Saay_C)
                + (1 / 6d) * Math.Pow(l_R * Cos_Saay_C / Cos_Saay_b, 2) * (l_w_R - (l_w_L / Sin_Saay_C)));
            return (Math.Round((f_L * Kesi[0] + f_R * Kesi[1] + W * Kesi[2] + Kesi[3]) / (f_L * Cos_Saay_L),4));
        }

        private double Toppling_Force
            (double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Cos_Saay_Anch
            , double Tan_Phi_R
            , double Tan_Phi_b
            , double C_R
            , double l_w_R, double l_w_L
            , double h_c
            , double h_Anch
            , double l_R
            , double L, double W
            , double f_R
            , double h_f_R
            , double h_f_L
            , double f_Anch
            , double t)
        {
            double Gama_Prime = 0;
            double[] Kesi = new double[5];

/*
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = h_f_R - t * Tan_Phi_R;

            Kesi[1] = 0.5d * (W + L) * (Kh * Cos_Saay_C - (1d + Kv) * Sin_Saay_C) * t
                + (0.5d * W + L) * (Kh * Sin_Saay_C + (1d + Kv) * Cos_Saay_C) * h_c;
            Kesi[2] = -h_Anch * Cos_Saay_Anch;
            Kesi[3] = -l_R * t;
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 6d) * ((Math.Pow(l_w_R, 3) - Math.Pow(l_w_L, 3))
                + Math.Pow(t, 2) * (2 * l_w_R + l_w_L));
            return (Math.Round((f_R * Kesi[0] + Kesi[1] + f_Anch * Kesi[2] + C_R * Kesi[3] + Kesi[4]) / h_f_L,2));
*/


            double A = 0;
            double B = 0;
            A = Sin_Saay_b - Tan_Phi_b * Cos_Saay_b;//phi is related to phi of carck in basement of Rock column
            B = Cos_Saay_b + Tan_Phi_b * Sin_Saay_b;//phi is related to phi of carck in basement of Rock column
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = h_f_R + t * (Tan_Saay_b - Tan_Phi_R);
            Kesi[1] = (1d + Kv) * (Cos_Saay_C * (h_c + t * Tan_Saay_b + L * h_c / (L + W)) - t * Sin_Saay_C)
                    + Kh * (Sin_Saay_C * (h_c + t * Tan_Saay_b + L * h_c / (L + W)) + t * Cos_Saay_C);
            Kesi[2] = -h_Anch * Cos_Saay_Anch;
            Kesi[3] = -l_R * t;
            Kesi[4] = Gama_Prime * Sin_Saay_C * ((Math.Pow(l_w_R, 3) - Math.Pow(l_w_L, 3)) / 6d + Math.Pow(l_w_R, 2)
                * t * Tan_Saay_b / 2d + (Math.Pow(t / Cos_Saay_b, 2) * (2 * l_w_R + l_w_L) / 6d));
            if (Math.Round(h_c, 4) <= 0)
                return (0);
            else
                return ((f_R * Kesi[0] + ((L + W) / 2) * Kesi[1] + f_Anch * Kesi[2] + C_R * Kesi[3] + Kesi[4]) / h_f_L);


        }

        private double Slide_Force
            (double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Sin_Saay_Anch, double Cos_Saay_Anch
            , double Tan_Phi_R
            , double Tan_Phi_L
            , double Tan_Phi_b
            , double C_R
            , double C_L
            , double C_b
            , double l_w_R, double l_w_L
            , double h_c
            , double l_R
            , double l_L
            , double L, double W
            , double f_R
            , double f_Anch
            , double t)
        {
            double Gama_Prime = 0;
            double[] Kesi = new double[6];

/*
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = Tan_Phi_b * Tan_Phi_R - 1;
            Kesi[1] = Tan_Phi_b * ((1 + Kv) * Sin_Saay_C - Kh * Cos_Saay_C) 
                - ((1 + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = Tan_Phi_b * Sin_Saay_Anch + Cos_Saay_Anch;
            Kesi[3] = -C_b * t + Tan_Phi_b * (C_R * l_R - C_L * l_L);
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 2d) * (t * Tan_Phi_b * (l_w_L + l_w_R) 
                + (Math.Pow(l_w_L, 2) - Math.Pow(l_w_R, 2)));
            Kesi[5] = Tan_Phi_b * Tan_Phi_L - 1;
            return (Math.Round((f_R * Kesi[0] + (L + W) * Kesi[1] + f_Anch * Kesi[2] + Kesi[3] + Kesi[4]) / Kesi[5],0));
*/


            double A = 0;
            double B = 0;
            A = Sin_Saay_b - Tan_Phi_b * Cos_Saay_b;//phi is related to phi of carck in basement of Rock column
            B = Cos_Saay_b + Tan_Phi_b * Sin_Saay_b;//phi is related to phi of carck in basement of Rock column
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            Kesi[0] = A * Tan_Phi_R + B;
            Kesi[1] = A * ((1 + Kv) * Sin_Saay_C - Kh * Cos_Saay_C) + B * ((1 + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = A * Sin_Saay_Anch - B * Cos_Saay_Anch;
            Kesi[3] = -C_b * t + (A * Tan_Saay_b + B) + A * (C_R * l_R - C_L * l_L);
            Kesi[4] = -(Gama_Prime * Sin_Saay_C / 2d) * (t * (l_w_L + l_w_R) * (A - B * Tan_Saay_b)
                + B * (Math.Pow(l_w_L, 2) - Math.Pow(l_w_R, 2)));
            Kesi[5] = A * Tan_Phi_L + B;
            if (Math.Round(h_c ,4) <= 0)
                return (0);
            else
                return ((f_R * Kesi[0] + (L + W) * Kesi[1] + f_Anch * Kesi[2] + Kesi[3] + Kesi[4]) / Kesi[5]);


        }

        private double Shear_Force
            (double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Sin_Saay_Anch, double Cos_Saay_Anch
            , double Tan_Phi_R
            , double Tan_Phi_L
            , double Tan_Phi_Material
            , double C_R
            , double C_L
            , double C_Material
            , double l_w_R, double l_w_L
            , double h_c
            , double l_R
            , double l_L
            , double L, double W
            , double f_R
            , double f_Anch
            , double t)
        {
            double Gama_Prime = 0;
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            double[] Kesi = new double[6];

/*
            Kesi[0] = Tan_Phi_Material * Tan_Phi_R - 1;
            Kesi[1] = Tan_Phi_Material * ((1 + Kv) * Sin_Saay_C - Kh * Cos_Saay_C) 
                - ((1 + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = Tan_Phi_Material * Sin_Saay_Anch + Cos_Saay_Anch;
            Kesi[3] = C_Material * t + Tan_Phi_Material * (C_R * l_R - C_L * l_L);
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 2d) * (Tan_Phi_Material * t * (l_w_L + l_w_R)
                + (Math.Pow(l_w_L, 2) - Math.Pow(l_w_R, 2)));
            Kesi[5] = Tan_Phi_Material * Tan_Phi_L - 1;
            return (Math.Round((f_R * Kesi[0] + (L + W) * Kesi[1] + f_Anch * Kesi[2] + Kesi[3] + Kesi[4]) / Kesi[5],0));
*/




            double A = 0;
            double B = 0;
            A = Sin_Saay_b - Tan_Phi_Material * Cos_Saay_b;//phi is phi of intact Rock
            B = Cos_Saay_b + Tan_Phi_Material * Sin_Saay_b;//phi is phi of intact Rock


            Kesi[0] = A * Tan_Phi_R + B;
            Kesi[1] = A * ((1 + Kv) * Sin_Saay_C - Kh * Cos_Saay_C) + B * ((1 + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = A * Sin_Saay_Anch - B * Cos_Saay_Anch;
            Kesi[3] = -C_Material * t * (A * Tan_Saay_b + B) + A * (C_R * l_R - C_L * l_L);
            Kesi[4] = -(Gama_Prime * Sin_Saay_C / 2d) * (t * (l_w_L + l_w_R) * (A - B * Tan_Saay_b)
                + B * (Math.Pow(l_w_L, 2) - Math.Pow(l_w_R, 2)));
            Kesi[5] = A * Tan_Phi_L + B;
            if (Math.Round(h_c, 4) <= 0)
                return (0);
            else
                return ((f_R * Kesi[0] + (L + W) * Kesi[1] + f_Anch * Kesi[2] + Kesi[3] + Kesi[4]) / Kesi[5]);


        }

        private double Flexure_Force
            (double Sin_Saay_b, double Cos_Saay_b, double Tan_Saay_b
            , double Sin_Saay_C, double Cos_Saay_C
            , double Sin_Saay_Anch, double Cos_Saay_Anch
            , double Tan_Phi_R
            , double Tan_Phi_L
            , double Tan_Phi_Material
            , double C_R
            , double C_L
            , double C_Material
            , double Sigma_Tensile_Material
            , double l_w_R, double l_w_L
            , double h_c
            , double h_Anch
            , double l_R
            , double l_L
            , double L, double W
            , double f_R
            , double h_f_R
            , double h_f_L
            , double f_Anch
            , double t)
        {
            double Gama_Prime = 0;
            Gama_Prime = Gama * Math.Sqrt(Math.Pow(1d + Kv, 2) + Math.Pow(Kh, 2));
            double[] Kesi = new double[7];

/*
            Kesi[0] = h_f_R - (2 * t / 3d) * Tan_Phi_R;
            Kesi[1] = h_c * (0.5 * W + L) * ((1d + Kv) * Cos_Saay_C + Kh * Sin_Saay_C)
                - (t / 6d) * (W + L) * ((1d + Kv) * Sin_Saay_C - Kh * Cos_Saay_C);
            Kesi[2] = (t / 3d) * Sin_Saay_Anch - h_Anch * Cos_Saay_Anch;
            Kesi[3] = (Gama_Prime * Sin_Saay_C / 6d) * (Math.Pow(l_w_R, 3) 
                - Math.Pow(l_w_L, 3) + Math.Pow(t, 2) * l_w_R);
            Kesi[4] = -(t / 3d) * (2 * C_R * l_R + C_L * l_L + t * Sigma_Tensile_Material / 2d);
            Kesi[5] = h_f_L + (t / 3d) * Tan_Phi_L;
            return (Math.Round((f_R * Kesi[0] + Kesi[1] + f_Anch * Kesi[2] + Kesi[3]
                + Kesi[4]) / Kesi[5],0));
*/



            double A = 0;
            double B = 0;
            A = Sin_Saay_b - Tan_Phi_Material * Cos_Saay_b;//phi is phi of intact Rock
            B = Cos_Saay_b + Tan_Phi_Material * Sin_Saay_b;//phi is phi of intact Rock
            Kesi[0] = B * (h_f_R + t * (Tan_Saay_b - Tan_Phi_R) / 2d) - t * Cos_Saay_b * Tan_Phi_R / 6d;
            Kesi[1] = h_c * B * ((1d + Kv) * Cos_Saay_C + Kh * Sin_Saay_C);
            Kesi[2] = -(t * Cos_Saay_b / 6d) * ((1d + Kv) * Sin_Saay_C - Kh * Cos_Saay_C);
            Kesi[3] = -B * (Cos_Saay_Anch * (h_Anch - t * Tan_Saay_b / 2d) - t * Sin_Saay_Anch / 2d)
                + t * Cos_Saay_b * Sin_Saay_Anch;
            Kesi[4] = (Gama_Prime * Sin_Saay_C / 2d) * (B * ((Math.Pow(l_w_R, 3) - Math.Pow(l_w_L, 3)) / 3d
                + t * Tan_Saay_b * (Math.Pow(l_w_R, 2) + Math.Pow(l_w_L, 2)) / 2d + Math.Pow(t, 2)
                * (l_w_R - l_w_L) / (6 * Cos_Saay_b)) + Math.Pow(t, 2) * Cos_Saay_b * (l_w_R + l_w_L) / 12d);
            Kesi[5] = -(t / 2d) * (B * (C_R * l_R + C_L * l_L + t * Sigma_Tensile_Material / 3d)
                + Cos_Saay_b * (C_R * l_R - C_L * l_L - C_Material * t * Tan_Saay_b) / 3d);
            Kesi[6] = B * (h_f_L - t * (Tan_Saay_b - Tan_Phi_L) / 2d) - t * Cos_Saay_b * Tan_Phi_L / 6d;
            if (Math.Round(h_c, 4) <= 0)
                return (0);
            else
                return ((f_R * Kesi[0] + (L + W / 2) * Kesi[1] + (L + W) * Kesi[2] + f_Anch * Kesi[3]
                + Kesi[4] + Kesi[5]) / Kesi[6]);


        }

        private string ToSientific(string Input_ToScientific)
        {
            double NoToConvToScinetficString = 0;
            if (Input_ToScientific == "-----")
                return ("-----");
            else
                NoToConvToScinetficString = System.Convert.ToDouble(Input_ToScientific);

            if ((NoToConvToScinetficString > -0.01 && NoToConvToScinetficString < 0.01 && NoToConvToScinetficString != 0))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString * 100000) / 100) + "E-03");

            if (NoToConvToScinetficString == 0)
                return ("0");

            if (((NoToConvToScinetficString >= 0.01 && NoToConvToScinetficString < 0.1) || (NoToConvToScinetficString <= -0.01 && NoToConvToScinetficString > -0.1)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString * 10000) / 100) + "E-02");

            if (((NoToConvToScinetficString >= 0.1 && NoToConvToScinetficString < 1) || (NoToConvToScinetficString <= -0.1 && NoToConvToScinetficString > -1)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString * 1000) / 100) + "E-01");

            if (((NoToConvToScinetficString >= 1 && NoToConvToScinetficString < 10) || (NoToConvToScinetficString <= -1 && NoToConvToScinetficString > -10)))
            {
                if (NoToConvToScinetficString % 1 != 0)
                    return (System.Convert.ToString(Math.Round(NoToConvToScinetficString * 100) / 100) + "E+00");
                else
                    return (System.Convert.ToString(NoToConvToScinetficString));
            }

            if (((NoToConvToScinetficString >= 10 && NoToConvToScinetficString < 100) || (NoToConvToScinetficString <= -10 && NoToConvToScinetficString > -100)))
            {
                if (NoToConvToScinetficString % 1 != 0)
                    return (System.Convert.ToString(Math.Round(NoToConvToScinetficString * 10) / 100) + "E+01");
                else
                    return (System.Convert.ToString(NoToConvToScinetficString));
            }

            if (((NoToConvToScinetficString >= 100 && NoToConvToScinetficString < 1000) || (NoToConvToScinetficString <= -100 && NoToConvToScinetficString > -1000)))
            {
                if (NoToConvToScinetficString % 1 != 0)
                    return (System.Convert.ToString(Math.Round(NoToConvToScinetficString) / 100) + "E+02");
                else
                    return (System.Convert.ToString(NoToConvToScinetficString));
            }

            if (((NoToConvToScinetficString >= 1000 && NoToConvToScinetficString < 10000) || (NoToConvToScinetficString <= -1000 && NoToConvToScinetficString > -10000)))
            {
                if (NoToConvToScinetficString % 1 != 0)
                    return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 10) / 100) + "E+03");
                else
                    return (System.Convert.ToString(NoToConvToScinetficString));
            }

            if (((NoToConvToScinetficString >= 10000 && NoToConvToScinetficString < 100000) || (NoToConvToScinetficString <= -10000 && NoToConvToScinetficString > -100000)))
            {
                if (NoToConvToScinetficString % 1 != 0)
                    return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 100) / 100) + "E+04");
                else
                    return (System.Convert.ToString(NoToConvToScinetficString));
            }

            if (((NoToConvToScinetficString >= 100000 && NoToConvToScinetficString < 1000000) || (NoToConvToScinetficString <= -100000 && NoToConvToScinetficString > -1000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 1000) / 100) + "E+05");

            if (((NoToConvToScinetficString >= 1000000 && NoToConvToScinetficString < 10000000) || (NoToConvToScinetficString <= -1000000 && NoToConvToScinetficString > -10000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 10000) / 100) + "E+06");

            if (((NoToConvToScinetficString >= 10000000 && NoToConvToScinetficString < 100000000) || (NoToConvToScinetficString <= -10000000 && NoToConvToScinetficString > -100000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 100000) / 100) + "E+07");

            if (((NoToConvToScinetficString >= 100000000 && NoToConvToScinetficString < 1000000000) || (NoToConvToScinetficString <= -100000000 && NoToConvToScinetficString > -1000000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 1000000) / 100) + "E+08");

            if (((NoToConvToScinetficString >= 1000000000 && NoToConvToScinetficString < 10000000000) || (NoToConvToScinetficString <= -1000000000 && NoToConvToScinetficString > -10000000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 10000000) / 100) + "E+09");

            if (((NoToConvToScinetficString >= 10000000000 && NoToConvToScinetficString < 100000000000) || (NoToConvToScinetficString <= -10000000000 && NoToConvToScinetficString > -100000000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 100000000) / 100) + "E+10");

            if (((NoToConvToScinetficString >= 100000000000 && NoToConvToScinetficString < 1000000000000) || (NoToConvToScinetficString <= -100000000000 && NoToConvToScinetficString > -1000000000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 1000000000) / 100) + "E+11");

            if (((NoToConvToScinetficString >= 1000000000000 && NoToConvToScinetficString < 10000000000000) || (NoToConvToScinetficString <= -1000000000000 && NoToConvToScinetficString > -10000000000000)))
                return (System.Convert.ToString(Math.Round(NoToConvToScinetficString / 10000000000) / 100) + "E+12");
            else
                return (System.Convert.ToString(0));

        }

        private void Apply_Anchors(int Seq_Counter, int k, double Seq_Face_Height, double Seq_Face_ColumnNo)
        {
            int Anchored_ColumnNo = 0;
            double pre_AnchorageForce = 0;
            double pre_AnchorageAngle = 0;
            double Anchorage_Angle = 0;

            for (int Anchor_Counter = 1; Anchor_Counter <= AnchorNo; Anchor_Counter++)//apply each dead load on top of slices or columns that is related to this slope
            {
                if (System.Convert.ToInt32(AnchorList[Anchor_Counter - 1, 8]) == Seq_Counter)
                {
                    Anchored_ColumnNo = System.Convert.ToInt32(Math.Floor(System.Convert.ToDouble(k)
                            - (Seq_Face_Height - System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 3])) / (Seq_Face_Height / Seq_Face_ColumnNo)));
                    pre_AnchorageForce = Analytical_Slice_Data[Anchored_ColumnNo, 26];//previous Anchor force
                    pre_AnchorageAngle = Analytical_Slice_Data[Anchored_ColumnNo, 27];//previous Anchor force angle
                    Anchorage_Angle = Math.Tan((pre_AnchorageForce * Math.Sin(pre_AnchorageAngle * Math.PI / 180)
                        + System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 6])
                        * Math.Sin(System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 4]) * Math.PI / 180))
                        / (pre_AnchorageForce * Math.Cos(pre_AnchorageAngle * Math.PI / 180)
                        + System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 6])
                        * Math.Cos(System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 4]) * Math.PI / 180))) * 180 / Math.PI;//calculate new anchorage angle by vectors subtraction
                    Analytical_Slice_Data[Anchored_ColumnNo, 26] = Math.Sqrt(
                        Math.Pow((pre_AnchorageForce * Math.Sin(pre_AnchorageAngle * Math.PI / 180)
                        + System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 6])
                        * Math.Sin(System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 4]) * Math.PI / 180)), 2)
                        + Math.Pow((pre_AnchorageForce * Math.Cos(pre_AnchorageAngle * Math.PI / 180)
                        + System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 6])
                        * Math.Cos(System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 4]) * Math.PI / 180)), 2));//calculate new anchorage force by vectors subtraction
                    Analytical_Slice_Data[Anchored_ColumnNo, 27] = Anchorage_Angle;
                    Analytical_Slice_Data[Anchored_ColumnNo, 28] += System.Convert.ToDouble(AnchorList[Anchor_Counter - 1, 7]);
                }
            }
        }

        private void Apply_External_forces(int Seq_Counter, int k, double Seq_Face_Height, double Seq_Face_ColumnNo)//apply dead loads on top of slices or columns
        {
            double Uniform_Force_Division = 0;
            for (int Force_Counter = 1; Force_Counter <= ForceNo; Force_Counter++)//apply each dead load on top of slices or columns that is related to this slope
            {
                if (System.Convert.ToInt32(ForceList[Force_Counter - 1, 8]) == Seq_Counter)//if this force is related to this slope?
                {
                    if (ForceList[Force_Counter - 1, 2] == "Point")//if force type is uniform
                    {
                        Analytical_Slice_Data[System.Convert.ToInt32(System.Convert.ToDouble(k) - (Seq_Face_Height - System.Convert.ToDouble(ForceList[Force_Counter - 1, 5]))
                            / (Seq_Face_Height / Seq_Face_ColumnNo)), 25] = System.Convert.ToDouble(ForceList[Force_Counter - 1, 7]);//top load of this column or slice
                    }
                    if (ForceList[Force_Counter - 1, 2] == "Uniform")//if force type is uniform
                    {
                        int Start_UniForce = 0;
                        int End_uniforce = 0;

                        Start_UniForce = System.Convert.ToInt32(Math.Floor(System.Convert.ToDouble(k)
                            - (Seq_Face_Height - System.Convert.ToDouble(ForceList[Force_Counter - 1, 5])) / (Seq_Face_Height / Seq_Face_ColumnNo)));//find first column or slice that is under force line
                        End_uniforce = System.Convert.ToInt32(Math.Floor(System.Convert.ToDouble(k) - (Seq_Face_Height - System.Convert.ToDouble(ForceList[Force_Counter - 1, 6]))
                            / (Seq_Face_Height / Seq_Face_ColumnNo)));//find last column or slice that is under force line
                        Uniform_Force_Division = System.Convert.ToDouble(ForceList[Force_Counter - 1, 7])
                            / ((System.Convert.ToDouble(ForceList[Force_Counter - 1, 6]) - System.Convert.ToDouble(ForceList[Force_Counter - 1, 5]))
                            / (Seq_Face_Height / Seq_Face_ColumnNo));//calculate force diviation for slices that is fully under force line
                        if (Start_UniForce == End_uniforce)//if just one column or slice is under uniform force
                        {
                            Analytical_Slice_Data[Start_UniForce, 25] = System.Convert.ToDouble(ForceList[Force_Counter - 1, 7]);
                        }
                        else
                        {
                            for (int Slice_Counter = Start_UniForce; Slice_Counter <= End_uniforce; Slice_Counter++)
                            {
                                if (Slice_Counter == Start_UniForce)//calculate force diviation for first column or slice
                                {
                                    Analytical_Slice_Data[Slice_Counter, 25]
                                        = (Analytical_Slice_Data[Slice_Counter, 5] - Analytical_Slice_Data[k - System.Convert.ToInt32(Seq_Face_ColumnNo), 1]
                                        - System.Convert.ToDouble(ForceList[Force_Counter - 1, 5])) * Uniform_Force_Division / (Seq_Face_Height / Seq_Face_ColumnNo);

                                }
                                else if (Slice_Counter == End_uniforce)//calculate force diviation for last column or slice
                                {
                                    Analytical_Slice_Data[Slice_Counter, 25]
                                        = (System.Convert.ToDouble(ForceList[Force_Counter - 1, 6]) - (Analytical_Slice_Data[Slice_Counter, 1] - Analytical_Slice_Data[k - System.Convert.ToInt32(Seq_Face_ColumnNo), 1]))
                                        * Uniform_Force_Division / (Seq_Face_Height / Seq_Face_ColumnNo);
                                }
                                else//calculate force diviation for medial columns or slices
                                {
                                    Analytical_Slice_Data[Slice_Counter, 25]
                                        = Uniform_Force_Division;
                                }
                            }
                        }
                    }
                }
            }
        }

        private void ERROR_Joint_DB()
        {

            double ThisV = 0, UpV = 0, DwnV = 0, ThisDev = 0, UpDev = 0, DwnDev = 0;

            SqlCommand Query = new SqlCommand();
            if (TxtBx_JointName.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill 'Joint Name' \n";
            }
            else if (TxtBx_JointName.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "'Joint Name' Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint] Where [Joint Name] = '"
                    + System.Convert.ToString(TxtBx_JointName.Text.Trim()) + "'";//read column joints information of slopes
                DataTable dt_Joint = new DataTable();
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                if (dt_Joint.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Joint Name' Is Repetitive \n";
                }
            }

            try
            {
                if (TxtBx_JointCohesiveStrength.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Cohesive Strength' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_JointCohesiveStrength.Text.Trim());
                UpV = 1000000000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Cohesive Strength' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Cohesive Strength' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_JointCohesiveStrength.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_JointCohesiveStrength_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Less Than "
                                    + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_JointCohesiveStrength_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_JointCohesiveStrength_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Cohesive Strength Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Cohesive Strength' Must Be Numeric \n";
            }
            try
            {
                if (TxtBx_JointFrictionAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Friction Angle' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_JointFrictionAngle.Text.Trim());
                UpV = 90;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Friction Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Friction Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_JointFrictionAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_JointFrictionAngle.Text.Trim()), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_JointFrictionAngle_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;
                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Less Than "
                                    + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_JointFrictionAngle_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_JointFrictionAngle_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Friction Angle Deviation' Must Be Numeric \n";
                        }
                    }

                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Friction Angle' Must Be Numeric \n";
            }

            if (TxtBx_JointCohesiveStrength_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_JointCohesiveStrength_Dev.Text = "0";
                WarningString = WarningString + "'Cohesive Strength' Set to Zero \n";
            }
            if (TxtBx_JointFrictionAngle_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_JointFrictionAngle_Dev.Text = "0";
                WarningString = WarningString + "'Friction Angle Deviation' Set to Zero \n";
            }

            if (ComBx_JointCohesiveStrength_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "K"))
                ComBx_JointCohesiveStrength_Dist.SelectedItem = "Exact Value";

            if (ComBx_JointFrictionAngle_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "K"))
                ComBx_JointFrictionAngle_Dist.SelectedItem = "Exact Value";

        }

        private void Btn_DefineJoint_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Joint Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_Joint_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Joint] ([Joint Name], [Cohesive Strength], [Cohesive Strength Tolerance]"
                    + ", [Friction Angle], [Friction Angle Tolerance], [Cohesive Strength Disrtibution], [Friction Angle Distribution])"
                    + " VALUES (@JointName, @CohesiveStrengt, @CohesiveStrengtTolerance, @FrictionAngle, @FrictionAngleTolerance"
                    + ", @CohesiveStrengthDisrtibution, @FrictionAngleDistribution)";

                Query.Parameters.Add("@JointName", SqlDbType.NVarChar).Value = TxtBx_JointName.Text.Trim();
                Query.Parameters.Add("@CohesiveStrengt", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointCohesiveStrength.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengtTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointCohesiveStrength_Dev.Text.Trim());
                Query.Parameters.Add("@FrictionAngle", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointFrictionAngle.Text.Trim());
                Query.Parameters.Add("@FrictionAngleTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointFrictionAngle_Dev.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthDisrtibution", SqlDbType.NVarChar).Value = ComBx_JointCohesiveStrength_Dist.SelectedItem;
                Query.Parameters.Add("@FrictionAngleDistribution", SqlDbType.NVarChar).Value = ComBx_JointFrictionAngle_Dist.SelectedItem;

                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshJointComboboxes();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }

        }

        private void ERROR_Slope_DB()
        {
            double ThisV = 0, UpV = 0, DwnV = 0, ThisDev = 0, UpDev = 0, DwnDev = 0;
            SqlCommand Query = new SqlCommand();

            if (TxtBx_SlopeName.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill 'Slope Name' \n";
            }
            else if (TxtBx_SlopeName.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "'Slope Name' Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '"
                    + TxtBx_SlopeName.Text + "'";//read all data of Slopes that created sequenses
                DataTable dt_Slope = new DataTable();
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();

                if (dt_Slope.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Slope Name' is Repetitive \n";
                }
            }

            try
            {
                if (TxtBx_FaceAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Face Angle' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_FaceAngle.Text.Trim());
                UpV = 90;
                DwnV = -45;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Face Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Face Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_FaceAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Face Angle' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_FaceHeight.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Face Height' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_FaceHeight.Text.Trim());
                UpV = 1000;
                DwnV = -1000;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Face Height'  Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Face Height'  Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_FaceHeight.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 3));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Face Height'  Must Be Numeric \n";
            }


            try
            {
                if (TxtBx_FaceColumnNo.Text.Trim().Length == 0)
                {
                    Error = true;
                    if(Lbl_FaceColumnNo.Text== "Face Column No")
                        ErrorString = ErrorString + "Please Fill 'Face Column No.' \n";
                    else
                        ErrorString = ErrorString + "Please Fill 'Face Slice No.' \n";

                }
                ThisV = System.Convert.ToDouble(TxtBx_FaceColumnNo.Text.Trim());
                UpV = 1000;
                DwnV = 1;
                if (ThisV > UpV)
                {
                    Error = true;
                    if (Lbl_FaceColumnNo.Text == "Face Column No")
                        ErrorString = ErrorString + "'Face Column No.' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                    else
                        ErrorString = ErrorString + "'Face Slice No.' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    if (Lbl_FaceColumnNo.Text == "Face Column No")
                        ErrorString = ErrorString + "'Face Column No.' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                    else
                        ErrorString = ErrorString + "'Face Slice No.' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_FaceColumnNo.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
                    try
                    {
                        ThisDev = System.Convert.ToInt32(TxtBx_FaceColumnNo_Dev.Text.Trim());
                        UpDev = System.Convert.ToInt32((UpV - ThisV) / 4d);
                        DwnDev = System.Convert.ToInt32((ThisV - DwnV) / 4d);
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            if (Lbl_FaceColumnNo.Text == "Face Column No")
                                ErrorString = ErrorString + "'Face Column No. Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                            else
                                ErrorString = ErrorString + "'Face Slice No. Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";

                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            if (Lbl_FaceColumnNo.Text == "Face Column No")
                                ErrorString = ErrorString + "'Face Column No. Deviation' Must Be Positive \n";
                            else
                                ErrorString = ErrorString + "'Face Slice No. Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_FaceColumnNo_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 0));
                    }
                    catch
                    {
                        if (TxtBx_FaceColumnNo_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            if (Lbl_FaceColumnNo.Text == "Face Column No")
                                ErrorString = ErrorString + "'Face Column No. Deviation' Must Be Numeric \n";
                            else
                                ErrorString = ErrorString + "'Face Slice No. Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                if (Lbl_FaceColumnNo.Text == "Face Column No")
                    ErrorString = ErrorString + "'Face Column No.' Must Be Numeric \n";
                else
                    ErrorString = ErrorString + "'Face Slice No.' Must Be Numeric \n";
            }


            try
            {
                if (Lbl_ColumnAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    if (TxtBx_ColumnAngle.Text == "Column Angle")
                        ErrorString = ErrorString + "Please Fill 'Column Angle' \n";
                    else
                        ErrorString = ErrorString + "Please Fill 'Slice Angle' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_ColumnAngle.Text.Trim());
                UpV = 90;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    if (TxtBx_ColumnAngle.Text == "Column Angle")
                        ErrorString = ErrorString + "'Column Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                    else
                        ErrorString = ErrorString + "'Slice Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    if (TxtBx_ColumnAngle.Text == "Column Angle")
                        ErrorString = ErrorString + "'Column Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                    else
                        ErrorString = ErrorString + "'Slice Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_ColumnAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_ColumnAngle_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            if (TxtBx_ColumnAngle.Text == "Column Angle")
                                ErrorString = ErrorString + "'Column Angle Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                            else
                                ErrorString = ErrorString + "'Slice Angle Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            if (TxtBx_ColumnAngle.Text == "Column Angle")
                                ErrorString = ErrorString + "'Column Angle Deviation' Must Be Positive \n";
                            else
                                ErrorString = ErrorString + "'Slice Angle Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_ColumnAngle_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_ColumnAngle_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            if (TxtBx_ColumnAngle.Text == "Column Angle")
                                ErrorString = ErrorString + "'Column Angle Deviation' Must Be Numeric \n";
                            else
                                ErrorString = ErrorString + "'Slice Angle Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                if (TxtBx_ColumnAngle.Text == "Column Angle")
                    ErrorString = ErrorString + "'Column Angle' Must Be Numeric \n";
                else
                    ErrorString = ErrorString + "'Slice Angle' Must Be Numeric \n";
            }


            try
            {
                if (TxtBx_BasalPlaneAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Basal Plane Angle' \n";
                }
                if(Lbl_ColumnAngle.Text == "Slice Angle")
                    TxtBx_BasalPlaneAngle.Text = System.Convert.ToString(80 - System.Convert.ToDouble(TxtBx_ColumnAngle.Text.Trim()));
                ThisV = System.Convert.ToDouble(TxtBx_BasalPlaneAngle.Text.Trim());
                UpV = 180 - System.Convert.ToDouble(TxtBx_ColumnAngle.Text.Trim());
                DwnV = 80 - System.Convert.ToDouble(TxtBx_ColumnAngle.Text.Trim());
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Basal Plane Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Basal Plane Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_BasalPlaneAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_BasalPlaneAngle_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Basal Plane Angle Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Basal Plane Angle Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_BasalPlaneAngle_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_BasalPlaneAngle_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Basal Plane Angle Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Basal Plane Angle' Must Be Numeric \n";
            }


            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_TopWaterLevel.Text.Trim());
                UpV = 1000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Top Water Level' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Top Water Level' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_TopWaterLevel.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 3));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_TopWaterLevel_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Top Water Level Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Top Water Level Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_TopWaterLevel_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 3));
                    }
                    catch
                    {
                        if (TxtBx_TopWaterLevel_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Top Water Level Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_TopWaterLevel.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Top Water Level' Must Be Numeric \n";
                }
            }


            try
            {
                ThisV = System.Convert.ToDouble(TxtBx_WaterLevelAngle.Text.Trim());
                UpV = 80;
                DwnV = -80;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Water Level Angle' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Water Level Angle' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_WaterLevelAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_WaterLevelAngle_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Water Level Angle Deviation' Must Be Less Than "
                                + System.Convert.ToString(UpDev) + " \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Water Level Angle Deviation' Must Be Positive \n";
                        }
                        else
                            TxtBx_WaterLevelAngle_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 2));
                    }
                    catch
                    {
                        if (TxtBx_WaterLevelAngle_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Water Level Angle Deviation' Must Be Numeric \n";
                        }
                    }
                }
            }
            catch
            {
                if (TxtBx_WaterLevelAngle.Text.Trim().Length != 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Water Level Angle' Must Be Numeric \n";
                }
            }


            try
            {
                if (TxtBx_ColumnBlockyness.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Blockiness' Must \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_ColumnBlockyness.Text.Trim());
                UpV = 100;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Blockiness' Must Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Blockiness' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                {
                    TxtBx_ColumnBlockyness.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
                    try
                    {
                        ThisDev = System.Convert.ToDouble(TxtBx_ColumnBlockyness_Dev.Text.Trim());
                        UpDev = (UpV - ThisV) / 4d;
                        DwnDev = (ThisV - DwnV) / 4d;
                        if (DwnDev < UpDev)
                            UpDev = DwnDev;

                        if (ThisDev > UpDev)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Blockiness Deviation' Must Must Be Less Than "
                                + System.Convert.ToString(UpDev) + "% \n";
                        }
                        else if (ThisDev < 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Blockiness Deviation' Must Must Be Positive \n";
                        }
                        else
                            TxtBx_ColumnBlockyness_Dev.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisDev), 2));
                    }
                    catch
                    {
                        if (TxtBx_ColumnBlockyness_Dev.Text.Trim().Length != 0)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'Blockiness Deviation' Must Must Be Numeric \n";
                        }
                    }

                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Blockiness' Must Must Be Numeric \n";
            }



            if (TxtBx_FaceColumnNo_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_FaceColumnNo_Dev.Text = "0";
                WarningString = WarningString + "'Face Column No. Deviation' Set to Zero \n";
            }
            if (TxtBx_ColumnAngle_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_ColumnAngle_Dev.Text = "0";
                WarningString = WarningString + "'Column Angle Deviation' Set to Zero \n";
            }
            if (TxtBx_BasalPlaneAngle_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_BasalPlaneAngle_Dev.Text = "0";
                WarningString = WarningString + "'Basal Plane Angle Deviation' Set to Zero \n";
            }



            if (TxtBx_TopWaterLevel.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_TopWaterLevel.Text = "0";
                WarningString = WarningString + "'Top Water Level' Set to Zero \n";
            }

            if (TxtBx_TopWaterLevel_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_TopWaterLevel_Dev.Text = "0";
                WarningString = WarningString + "Water Level Deviation Set to Zero \n";
            }

            if (TxtBx_WaterLevelAngle.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_WaterLevelAngle.Text = "0";
                WarningString = WarningString + "'Water Level Angle' Set to Zero \n";
            }
            if (TxtBx_WaterLevelAngle_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_WaterLevelAngle_Dev.Text = "0";
                WarningString = WarningString + "'Water Level Angle Deviation' Set to Zero \n";
            }
            if (TxtBx_ColumnBlockyness_Dev.Text.Trim().Length == 0 && Error == false)
            {
                TxtBx_ColumnBlockyness_Dev.Text = "0";
                WarningString = WarningString + "'Blockiness Deviation' Set to Zero \n";
            }

            if (ComBx_FaceColumnNo_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "K"))
                ComBx_FaceColumnNo_Dist.SelectedItem = "Exact Value";
            if (ComBx_ColumnAngle_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "K"))
                ComBx_ColumnAngle_Dist.SelectedItem = "Exact Value";
            if (ComBx_BasalPlaneAngle_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "K"))
                ComBx_BasalPlaneAngle_Dist.SelectedItem = "Exact Value";
            if (ComBx_TopWaterLevel_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "K"))
                ComBx_TopWaterLevel_Dist.SelectedItem = "Exact Value";
            if (ComBx_WaterLevelAngle_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "K"))
                ComBx_WaterLevelAngle_Dist.SelectedItem = "Exact Value";
            if (ComBx_ColumnBlockyness_Dist.SelectedItem == null ||
               (System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "K"))
                ComBx_ColumnBlockyness_Dist.SelectedItem = "Exact Value";
        }

        private void Btn_DefineSlope_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Slope Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_Slope_DB();

            if (Error == false)
            {
                Query.CommandText = "SELECT * FROM[dbo].[Tbl_Material] WHERE [Material Name] ='" + ComBx_SelectMaterial.Text + "'";
                DataTable dt_Material = new DataTable();
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();
                string Selected_Material_Type = System.Convert.ToString(dt_Material.Rows[0].ItemArray[2]);//Material Type

                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope] ([Slope Name], Id_Material, [Face Angle], [Face Height]"
                    + ", [Face Column No], [Face Column No Tolerance], [Column Angle], [Column Angle Tolerance], Id_Column_Joint, "
                    + "[Basal Plane Angle], [Basal Plane Angle Tolerance], Id_Basal_Joint, [Top Water Level], [Top Water Level Tolerance]"
                    + ", [Water Level Angle], [Water Level Angle Tolerance], Blockiness, [Blockiness Tolerance], [Material Type]"
                    + ", [Face Column No Distribution], [Column Angle Distribution], [Basal Plane Angle Distribution], [Top Water Level Distribution]"
                    + ", [Water Level Angle Distribution], [Blockiness Distribution]) "
                    + "VALUES (@SlopeName, (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '"
                    + ComBx_SelectMaterial.Text + "'), @FaceAngle, @FaceHeight, @FaceColumnNo, @FaceColumnNoTolerance, @ColumnAngle, @ColumnAngleTolerance"
                    + ", (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + ComBx_SelectColumnJoint.Text + "'), @BasalPlaneAngle, @BasalPlaneAngleTolerance, (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '"
                    + ComBx_SelectBasalPlaneJoint.Text + "'), @TopWaterLevel, @TopWaterLevelTolerance, @WaterLevelAngle, @WaterLevelAngleTolerance, @Blockiness, @BlockinessTolerance, @MaterialType"
                    + ", @FaceColumnNoDistribution, @ColumnAngleDistribution, @BasalPlaneAngleDistribution, @TopWaterLevelDistribution, @WaterLevelAngleDistribution, @BlockinessDistribution)";
                Query.Parameters.Add("@SlopeName", SqlDbType.NVarChar).Value = TxtBx_SlopeName.Text.Trim();
                Query.Parameters.Add("@FaceAngle", SqlDbType.Decimal).Value = TxtBx_FaceAngle.Text.Trim();
                Query.Parameters.Add("@FaceHeight", SqlDbType.Decimal).Value = TxtBx_FaceHeight.Text.Trim();
                Query.Parameters.Add("@FaceColumnNo", SqlDbType.Int).Value = System.Convert.ToInt32(TxtBx_FaceColumnNo.Text.Trim());
                Query.Parameters.Add("@FaceColumnNoTolerance", SqlDbType.Int).Value = System.Convert.ToInt32(TxtBx_FaceColumnNo_Dev.Text.Trim());
                Query.Parameters.Add("@ColumnAngle", SqlDbType.Decimal).Value = TxtBx_ColumnAngle.Text.Trim();
                Query.Parameters.Add("@ColumnAngleTolerance", SqlDbType.Decimal).Value = TxtBx_ColumnAngle_Dev.Text.Trim();
                Query.Parameters.Add("@BasalPlaneAngle", SqlDbType.Decimal).Value = TxtBx_BasalPlaneAngle.Text.Trim();
                Query.Parameters.Add("@BasalPlaneAngleTolerance", SqlDbType.Decimal).Value = TxtBx_BasalPlaneAngle_Dev.Text.Trim();
                Query.Parameters.Add("@TopWaterLevel", SqlDbType.Decimal).Value = TxtBx_TopWaterLevel.Text.Trim();
                Query.Parameters.Add("@TopWaterLevelTolerance", SqlDbType.Decimal).Value = TxtBx_TopWaterLevel_Dev.Text.Trim();
                Query.Parameters.Add("@WaterLevelAngle", SqlDbType.Decimal).Value = TxtBx_WaterLevelAngle.Text.Trim();
                Query.Parameters.Add("@WaterLevelAngleTolerance", SqlDbType.Decimal).Value = TxtBx_WaterLevelAngle_Dev.Text.Trim();
                Query.Parameters.Add("@Blockiness", SqlDbType.Decimal).Value = TxtBx_ColumnBlockyness.Text.Trim();
                Query.Parameters.Add("@BlockinessTolerance", SqlDbType.Decimal).Value = TxtBx_ColumnBlockyness_Dev.Text.Trim();
                Query.Parameters.Add("@MaterialType", SqlDbType.NVarChar).Value = Selected_Material_Type;
                Query.Parameters.Add("@FaceColumnNoDistribution", SqlDbType.NVarChar).Value = ComBx_FaceColumnNo_Dist.SelectedItem;
                Query.Parameters.Add("@ColumnAngleDistribution", SqlDbType.NVarChar).Value = ComBx_ColumnAngle_Dist.SelectedItem;
                Query.Parameters.Add("@BasalPlaneAngleDistribution", SqlDbType.NVarChar).Value = ComBx_BasalPlaneAngle_Dist.SelectedItem;
                Query.Parameters.Add("@TopWaterLevelDistribution", SqlDbType.NVarChar).Value = ComBx_TopWaterLevel_Dist.SelectedItem;
                Query.Parameters.Add("@WaterLevelAngleDistribution", SqlDbType.NVarChar).Value = ComBx_WaterLevelAngle_Dist.SelectedItem;
                Query.Parameters.Add("@BlockinessDistribution", SqlDbType.NVarChar).Value = ComBx_ColumnBlockyness_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Btn_AddSequence_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Sequence Added Successfully";

            if (Error == false)
            {
                SqlCommand Query = new SqlCommand();
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Slope_Sequence] (Id_Model, Id_Slope, Id_Side_joint, [Sequence No]) "
                    + "VALUES ((SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '" + ComBx_SelectModel_Sequence.Text
                    + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_SelectSlope_Sequence.Text
                    + "'), (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = '" + ComBx_SelectJoint_Sequence.Text + "'), @SequenceNo)";
                Query.Parameters.Add("@SequenceNo", SqlDbType.Int).Value = TxtBx_SequenceNo.Text;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                Refresh_ComBx_SequenceNo();
                if (TxtBx_SequenceNo.Text == "1")
                {
                    Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Type]) Values (@ModelType)";
                    Query.Parameters.Add("@ModelType", SqlDbType.NVarChar).Value = "";
                    Query.Connection = Connection;
                    Connection.Open();
                    Query.ExecuteNonQuery();
                    Connection.Close();
                }
            }
            else
            {
                MessageBox.Show(ErrorString);
            }


            SetModelType();

        }

        private void ERROR_Anchor_DB()
        {
            double ThisV = 0, UpV = 0, DwnV = 0;
            double Slope_Face_Height = 0;
            double Slope_Face_Angle = 0;

            SqlCommand Query = new SqlCommand();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_SelectSlope.Text + "'";//read all data of Slopes that created sequenses
            DataTable dt_Slope = new DataTable();
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            Slope_Face_Angle = System.Convert.ToDouble(dt_Slope.Rows[0].ItemArray[3]);
            Slope_Face_Height = System.Convert.ToDouble(dt_Slope.Rows[0].ItemArray[4]);


            if (TxtBx_AnchorName.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill 'Anchor Name' \n";
            }
            else if (TxtBx_AnchorName.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Name' Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Anchor] Where [Anchor Name] = '"
                    + System.Convert.ToString(TxtBx_AnchorName.Text.Trim()) + "'";//read anchors information
                DataTable dt_Anchor = new DataTable();
                dt_Anchor.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Anchor);
                Connection.Close();

                if (dt_Anchor.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Joint Name' Is Repetitive \n";
                }
            }

            try
            {
                if (TxtBx_AnchorHeight.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Anchor Height' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_AnchorHeight.Text.Trim());
                UpV = Slope_Face_Height;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Height' Must Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Height' Must Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_AnchorHeight.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 3));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Height' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_AnchorAngle.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Anchor Angle' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_AnchorAngle.Text.Trim());
                UpV = Slope_Face_Angle;
                DwnV = -90;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Angle' Must  Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Angle' Must  Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_AnchorAngle.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 2));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Angle' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_AnchorLength.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Anchor Length' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_AnchorLength.Text.Trim());
                UpV = 5 * Slope_Face_Height / Math.Tan(Slope_Face_Angle * Math.PI / 180);
                DwnV = 2 * Slope_Face_Height / Math.Tan(Slope_Face_Angle * Math.PI / 180);
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Length' Must  Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Length' Must  Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_AnchorLength.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 3));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Length' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_AnchorForce.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Anchor Force' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_AnchorForce.Text.Trim());
                UpV = 1000000000;
                DwnV = 0;
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Force' Must  Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Force' Must  Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_AnchorForce.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Force' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_AnchorYeild.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Anchor Yeild Force' \n";
                }
                ThisV = System.Convert.ToDouble(TxtBx_AnchorYeild.Text.Trim());
                UpV = 5 * System.Convert.ToDouble(TxtBx_AnchorForce.Text.Trim());
                DwnV = System.Convert.ToDouble(TxtBx_AnchorForce.Text.Trim());
                if (ThisV > UpV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Yeild Force' Must  Be Less Than "
                        + System.Convert.ToString(UpV) + " \n";
                }
                else if (ThisV < DwnV)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Anchor Yeild Force' Must  Be More Than "
                        + System.Convert.ToString(DwnV) + " \n";
                }
                else
                    TxtBx_AnchorYeild.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(ThisV), 0));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Anchor Yeild Force' Must Be Numeric \n";
            }
        }

        private void Btn_DefineAnchor_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Anchor Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_Anchor_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Anchor] ([Anchor Name], Id_Slope, Id_Model, [Height in Face], [Anchor Angle]"
                    + ", [Anchor Length], [Anchorage Force], [Anchorage Yield Force]) "
                    + "VALUES (@AnchorName, (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_SelectSlope.Text
                    + "'), (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '" + ComBx_SelectModel.Text
                    + "'), @HeightinFace, @AnchorAngle, @AnchorLength, @AnchorageForce, @AnchorageYeildForce)";
                Query.Parameters.Add("@AnchorName", SqlDbType.NVarChar).Value = TxtBx_AnchorName.Text.Trim();
                Query.Parameters.Add("@HeightinFace", SqlDbType.Decimal).Value = TxtBx_AnchorHeight.Text.Trim();
                Query.Parameters.Add("@AnchorAngle", SqlDbType.Decimal).Value = TxtBx_AnchorAngle.Text.Trim();
                Query.Parameters.Add("@AnchorLength", SqlDbType.Decimal).Value = TxtBx_AnchorLength.Text.Trim();
                Query.Parameters.Add("@AnchorageForce", SqlDbType.Decimal).Value = TxtBx_AnchorForce.Text.Trim();
                Query.Parameters.Add("@AnchorageYeildForce", SqlDbType.Decimal).Value = TxtBx_AnchorYeild.Text.Trim();
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void ERROR_UniformLoad_DB()
        {
            double Slope_Face_Height = 0;
            double H1 = 0, H2 = 0;
            bool FlgH1 = false, FlgH2 = false;

            SqlCommand Query = new SqlCommand();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_Slope_PointLoad.Text + "'";//read all data of Slopes that created sequenses
            DataTable dt_Slope = new DataTable();
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            Slope_Face_Height = System.Convert.ToDouble(dt_Slope.Rows[0].ItemArray[4]);

            if (TxtBx_ForceName_UniFormLoad.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill 'Force Name' \n";
            }
            else if (TxtBx_ForceName_UniFormLoad.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "'Force Name' Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force] Where [Force Name] = '"
                    + System.Convert.ToString(TxtBx_ForceName_UniFormLoad.Text.Trim()) + "'";//read forces information
                DataTable dt_Forces = new DataTable();
                dt_Forces.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Forces);
                Connection.Close();
                if (dt_Forces.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Force Name' is Repetitive \n";
                }
            }

            try
            {
                if (TxtBx_FromHeighinFace_UniFormLoad.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'From Height in Face' \n";
                }
                else
                {
                    H1 = System.Convert.ToDouble(TxtBx_FromHeighinFace_UniFormLoad.Text.Trim());
                    FlgH1 = true;
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'From Height in Face' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_ToHeighinFace_UniFormLoad.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'To Height in Face' \n";
                }
                else
                {
                    H2 = System.Convert.ToDouble(TxtBx_ToHeighinFace_UniFormLoad.Text.Trim());
                    FlgH2 = true;
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'To Height in Face' Must Be Numeric \n";
            }

            if (FlgH1 == true && FlgH2 == true)
            {

                if (H2 > Slope_Face_Height)
                {
                    if (H1 > Slope_Face_Height)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                        ErrorString = ErrorString + "'To Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                    }
                    else if (H1 < 0)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Positive \n";
                        ErrorString = ErrorString + "'To Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                    }
                    else
                    {
                        Error = true;
                        ErrorString = ErrorString + "'To Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                    }
                }
                else if (H2 < 0)
                {
                    if (H1 < 0)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Positive \n";
                        ErrorString = ErrorString + "'To Height in Face' Must Be Positive \n";
                    }
                    else if (H1 > Slope_Face_Height)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                        ErrorString = ErrorString + "'To Height in Face' Must Be Positive \n";
                    }
                    else
                    {
                        Error = true;
                        ErrorString = ErrorString + "'To Height in Face' Must Be Positive \n";
                    }
                }
                else
                {
                    if (H1 < 0)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Positive \n";
                    }
                    else if (H1 > Slope_Face_Height)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'From Height in Face' Must Be Less Than " + System.Convert.ToString(H2) + " \n";
                    }
                    else
                    {
                        if (H1 > H2)
                        {
                            Error = true;
                            ErrorString = ErrorString + "'To Height in Face' Must Be Less Than " + System.Convert.ToString(H2) + " \n";
                        }
                        else if (H1 == H2)
                        {
                            Error = true;
                            ErrorString = ErrorString + "it's better to define this force as Point Load  \n";
                        }
                        else
                        {
                            TxtBx_FromHeighinFace_UniFormLoad.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_FromHeighinFace_UniFormLoad.Text.Trim()), 3));
                            TxtBx_ToHeighinFace_UniFormLoad.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_ToHeighinFace_UniFormLoad.Text.Trim()), 3));
                        }
                    }
                }
            }

            try
            {
                if (TxtBx_Force_UniFormLoad.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Force' \n";
                }
                else if (System.Convert.ToDecimal(TxtBx_Force_UniFormLoad.Text.Trim()) > 10000000000)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Force' Must Be Less Than 10000000000 \n";
                }
                else if (System.Convert.ToDecimal(TxtBx_Force_UniFormLoad.Text.Trim()) < 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Force' Must Be Positive \n";
                }
                else
                    TxtBx_Force_UniFormLoad.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_Force_UniFormLoad.Text.Trim()), 0));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Force' Must Be Numeric \n";
            }
        }

        private void Btn_UniformLoad_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Force Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_UniformLoad_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Force] ([Force Name], [Force Type], Model_Id, Slope_Id, [From Height In Face]"
                    + ", [To Height In Face], Force) VALUES (@ForceName, @ForceType, (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '"
                    + ComBx_Model_UniFormLoad.Text + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_Slope_UniFormLoad.Text
                    + "'), @FromHeightInFace, @ToHeightInFace, @Force)";
                Query.Parameters.Add("@ForceName", SqlDbType.NVarChar).Value = TxtBx_ForceName_UniFormLoad.Text.Trim();
                Query.Parameters.Add("@ForceType", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FromHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FromHeighinFace_UniFormLoad.Text.Trim());
                Query.Parameters.Add("@ToHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_ToHeighinFace_UniFormLoad.Text.Trim());
                Query.Parameters.Add("@Force", SqlDbType.Decimal).Value = TxtBx_Force_UniFormLoad.Text.Trim();
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void ERROR_PointLoad_DB()
        {
            double Slope_Face_Height = 0;
            SqlCommand Query = new SqlCommand();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_Slope_PointLoad.Text + "'";//read all data of Slopes that created sequenses
            DataTable dt_Slope = new DataTable();
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            Slope_Face_Height = System.Convert.ToDouble(dt_Slope.Rows[0].ItemArray[4]);

            if (TxtBx_ForceName_PointLoad.Text.Trim().Length == 0)
            {
                Error = true;
                ErrorString = ErrorString + "Please Fill 'Force Name' \n";
            }
            else if (TxtBx_ForceName_PointLoad.Text.Trim().Length > 50)
            {
                Error = true;
                ErrorString = ErrorString + "'Force Name' Is Too Big \n";
            }
            else
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force] Where [Force Name] = '" +
                    System.Convert.ToString(TxtBx_ForceName_PointLoad.Text.Trim()) + "'";//read forces information
                DataTable dt_Forces = new DataTable();
                dt_Forces.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Forces);
                Connection.Close();
                if (dt_Forces.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
                {
                    Error = true;
                    ErrorString = ErrorString + "This 'Force Name' is Repetitive \n";
                }
            }

            try
            {
                if (TxtBx_HeighinFace_PointLoad.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Height in Face' \n";
                }
                else
                {
                    if (System.Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim()) > System.Convert.ToDecimal(Slope_Face_Height))
                    {
                        Error = true;
                        ErrorString = ErrorString + "'Height in Face' Must Be Less Than " + System.Convert.ToString(Slope_Face_Height) + " \n";
                    }
                    else if (System.Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim()) < 0)
                    {
                        Error = true;
                        ErrorString = ErrorString + "'Height in Face' Must Be Positive \n";
                    }
                    else
                        TxtBx_HeighinFace_PointLoad.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim()), 3));
                }
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Height in Face' Must Be Numeric \n";
            }

            try
            {
                if (TxtBx_Force_PointLoad.Text.Trim().Length == 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "Please Fill 'Force' \n";
                }
                else if (System.Convert.ToDecimal(TxtBx_Force_PointLoad.Text.Trim()) > 9999999999)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Force' Must Be Less Than 9999999999 \n";
                }
                else if (System.Convert.ToDecimal(TxtBx_Force_PointLoad.Text.Trim()) < 0)
                {
                    Error = true;
                    ErrorString = ErrorString + "'Force' Must Be Positive \n";
                }
                else
                    TxtBx_Force_PointLoad.Text = System.Convert.ToString(Math.Round(System.Convert.ToDecimal(TxtBx_Force_PointLoad.Text.Trim()), 0));
            }
            catch
            {
                Error = true;
                ErrorString = ErrorString + "'Force' Must Be Numeric \n";
            }
        }

        private void Btn_PointLoad_Click(object sender, EventArgs e)
        {
            Error = false;
            ErrorString = "";
            WarningString = "Force Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_PointLoad_DB();

            if (Error == false)
            {
                Query.CommandText = "INSERT INTO [dbo].[Tbl_Force] ([Force Name], [Force Type], Model_Id, Slope_Id, [From Height In Face],"
                    + " [To Height In Face], Force) VALUES (@ForceName, @ForceType, (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '"
                    + ComBx_Model_PointLoad.Text + "'), (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_Slope_PointLoad.Text
                    + "'), @FromHeightInFace, @ToHeightInFace, @Force)";
                Query.Parameters.Add("@ForceName", SqlDbType.NVarChar).Value = TxtBx_ForceName_PointLoad.Text.Trim();
                Query.Parameters.Add("@ForceType", SqlDbType.NVarChar).Value = "Point";
                Query.Parameters.Add("@FromHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim());
                Query.Parameters.Add("@ToHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim());
                Query.Parameters.Add("@Force", SqlDbType.Decimal).Value = TxtBx_Force_PointLoad.Text.Trim();

                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void SetModelType()
        {
            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '"
                + ComBx_SelectModel_Sequence.Text + "'";//read data of the model and copy them to datatable
            DataTable dt_Model = new DataTable();
            dt_Model.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Model);
            Connection.Close();
            ModelId = System.Convert.ToInt32(dt_Model.Rows[0].ItemArray[0]);// Extract Id Model from Database
            ModelName = System.Convert.ToString(dt_Model.Rows[0].ItemArray[1]);// Extract Model Name from Database
            Kh = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[2]);// Extract Kh from database
            Kh_T = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[3]);// Extract Kh from database Deviation
            Kv = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[4]);// Extract Kv from database
            Kv_T = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[5]);// Extract Kv from database Deviation
            ModelType = System.Convert.ToString(dt_Model.Rows[0].ItemArray[6]);// Extract Model Typr from Database

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_SelectSlope_Sequence.Text + "'";
            DataTable dt_Slope = new DataTable();
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();
            string Material_Type = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[19]);//Material Type

            if (ModelType == "Rock")
            {
                if (Material_Type == "Soil")
                {
                    Query.CommandText = "UPDATE [dbo].[Tbl_Model_Name] SET [Model Type] = 'Rock_Soil' WHERE Id_Model = '"
                        + System.Convert.ToString(ModelId) + "'";
                    Query.Connection = Connection;
                    Connection.Open();
                    Query.ExecuteNonQuery();
                    Connection.Close();
                }
            }
            else if (ModelType == "Soil")
            {
                if (Material_Type == "Rock")
                {
                    Query.CommandText = "UPDATE [dbo].[Tbl_Model_Name] SET [Model Type] = 'Soil_Rock' WHERE Id_Model = '"
                        + System.Convert.ToString(ModelId) + "'";
                    Query.Connection = Connection;
                    Connection.Open();
                    Query.ExecuteNonQuery();
                    Connection.Close();
                }
            }
            else if (ModelType == "Soil_Rock")
            {
            }
            else if (ModelType == "Rock_Soil")
            {
            }
            else
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Model_Name] SET [Model Type] = '" + Material_Type + "' WHERE Id_Model = '"
                    + System.Convert.ToString(ModelId) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
            }
        }

        private void Refresh_ComBx_SequenceNo()
        {

            try
            {
                SqlCommand Query = new SqlCommand();
                Query.CommandText = "SELECT Id_Model FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '"
                    + ComBx_SelectModel_Sequence.Text + "'";//read data of the model and copy them to datatable
                DataTable dt_Model = new DataTable();
                dt_Model.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Model);
                Connection.Close();
                ModelId = System.Convert.ToInt32(dt_Model.Rows[0].ItemArray[0]);// Extract Id Model from Database

                Query.CommandText = "SELECT [Sequence No] FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '"
                    + System.Convert.ToString(ModelId) + "'";
                DataTable dt_SeqNo = new DataTable();
                dt_SeqNo.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_SeqNo);
                Connection.Close();

                dt_SeqNo.DefaultView.Sort = "Sequence No ASC";
                dt_SeqNo = dt_SeqNo.DefaultView.ToTable();//Sequense No data table sorted Ascending

                int SeqNo = dt_SeqNo.Rows.Count;

                TxtBx_SequenceNo.Text = System.Convert.ToString(System.Convert.ToInt32(dt_SeqNo.Rows[SeqNo - 1].ItemArray[0]) + 1);
            }
            catch
            {
                TxtBx_SequenceNo.Text = System.Convert.ToString(1);
            }
        }

        private void RefreshJointComboboxes()
        {
            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM Tbl_Joint";
            DataTable dt_Joint = new DataTable();
            dt_Joint.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Joint);
            Connection.Close();
            ComBx_SelectColumnJoint.BindingContext = new BindingContext();
            ComBx_SelectColumnJoint.DataSource = dt_Joint;
            ComBx_SelectColumnJoint.ValueMember = "Id_Joint";
            ComBx_SelectColumnJoint.DisplayMember = "Joint Name";

            ComBx_SelectBasalPlaneJoint.BindingContext = new BindingContext();
            ComBx_SelectBasalPlaneJoint.DataSource = dt_Joint;
            ComBx_SelectBasalPlaneJoint.ValueMember = "Id_Joint";
            ComBx_SelectBasalPlaneJoint.DisplayMember = "Joint Name";

            ComBx_SelectJoint_Sequence.BindingContext = new BindingContext();
            ComBx_SelectJoint_Sequence.DataSource = dt_Joint;
            ComBx_SelectJoint_Sequence.ValueMember = "Id_Joint";
            ComBx_SelectJoint_Sequence.DisplayMember = "Joint Name";
        }

        private void RefreshModelName()
        {
            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM Tbl_Model_Name";
            DataTable dt_Model = new DataTable();
            dt_Model.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Model);
            Connection.Close();
            ComBx_SelectModel_Sequence.BindingContext = new BindingContext();
            ComBx_SelectModel_Sequence.DataSource = dt_Model;
            ComBx_SelectModel_Sequence.ValueMember = "Id_Model";
            ComBx_SelectModel_Sequence.DisplayMember = "Model Name";

            ComBx_SelectModel.BindingContext = new BindingContext();
            ComBx_SelectModel.DataSource = dt_Model;
            ComBx_SelectModel.ValueMember = "Id_Model";
            ComBx_SelectModel.DisplayMember = "Model Name";

            ComBx_WhichModel.BindingContext = new BindingContext();
            ComBx_WhichModel.DataSource = dt_Model;
            ComBx_WhichModel.ValueMember = "Id_Model";
            ComBx_WhichModel.DisplayMember = "Model Name";

            ComBx_WhichModel_Prob.BindingContext = new BindingContext();
            ComBx_WhichModel_Prob.DataSource = dt_Model;
            ComBx_WhichModel_Prob.ValueMember = "Id_Model";
            ComBx_WhichModel_Prob.DisplayMember = "Model Name";

            ComBx_Model_PointLoad.BindingContext = new BindingContext();
            ComBx_Model_PointLoad.DataSource = dt_Model;
            ComBx_Model_PointLoad.ValueMember = "Id_Model";
            ComBx_Model_PointLoad.DisplayMember = "Model Name";

            ComBx_Model_UniFormLoad.BindingContext = new BindingContext();
            ComBx_Model_UniFormLoad.DataSource = dt_Model;
            ComBx_Model_UniFormLoad.ValueMember = "Id_Model";
            ComBx_Model_UniFormLoad.DisplayMember = "Model Name";
        }

        private void RefreshMaterial()
        {
            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM Tbl_Material";
            DataTable dt_Material = new DataTable();
            dt_Material.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Material);
            Connection.Close();
            ComBx_SelectMaterial.BindingContext = new BindingContext();
            ComBx_SelectMaterial.DataSource = dt_Material;
            ComBx_SelectMaterial.ValueMember = "Id_Material";
            ComBx_SelectMaterial.DisplayMember = "Material Name";
        }

        private void RefreshSlope()
        {
            SqlCommand Query = new SqlCommand();
            string Model_Type = "";
            try
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '" + ComBx_SelectModel_Sequence.Text + "'";
                DataTable dt_ModelType = new DataTable();
                dt_ModelType.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_ModelType);
                Connection.Close();
                Model_Type = System.Convert.ToString(dt_ModelType.Rows[0].ItemArray[6]);//Material Type
            }
            catch
            {

            }
            try
            {
                Query.CommandText = "SELECT * FROM Tbl_Slope";
                DataTable dt_Slope = new DataTable();
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();
                ComBx_SelectSlope_Sequence.BindingContext = new BindingContext();
                ComBx_SelectSlope_Sequence.DataSource = dt_Slope;
                ComBx_SelectSlope_Sequence.ValueMember = "Id_Slope";
                ComBx_SelectSlope_Sequence.DisplayMember = "Slope Name";

                ComBx_SelectSlope.BindingContext = new BindingContext();
                ComBx_SelectSlope.DataSource = dt_Slope;
                ComBx_SelectSlope.ValueMember = "Id_Slope";
                ComBx_SelectSlope.DisplayMember = "Slope Name";

                ComBx_Slope_PointLoad.BindingContext = new BindingContext();
                ComBx_Slope_PointLoad.DataSource = dt_Slope;
                ComBx_Slope_PointLoad.ValueMember = "Id_Slope";
                ComBx_Slope_PointLoad.DisplayMember = "Slope Name";

                ComBx_Slope_UniFormLoad.BindingContext = new BindingContext();
                ComBx_Slope_UniFormLoad.DataSource = dt_Slope;
                ComBx_Slope_UniFormLoad.ValueMember = "Id_Slope";
                ComBx_Slope_UniFormLoad.DisplayMember = "Slope Name";
            }
            catch
            {
            }

            if (Model_Type == "Soil_Rock")
            {

                Query.CommandText = "SELECT * FROM Tbl_Slope WHERE [Material Type] = 'Rock'";
                DataTable dt_Slope = new DataTable();
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();
                ComBx_SelectSlope_Sequence.BindingContext = new BindingContext();
                ComBx_SelectSlope_Sequence.DataSource = dt_Slope;
                ComBx_SelectSlope_Sequence.ValueMember = "Id_Slope";
                ComBx_SelectSlope_Sequence.DisplayMember = "Slope Name";
            }
            if (Model_Type == "Rock_Soil")
            {
                Query.CommandText = "SELECT * FROM Tbl_Slope WHERE [Material Type] = 'Soil'";
                DataTable dt_Slope = new DataTable();
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();
                ComBx_SelectSlope_Sequence.BindingContext = new BindingContext();
                ComBx_SelectSlope_Sequence.DataSource = dt_Slope;
                ComBx_SelectSlope_Sequence.ValueMember = "Id_Slope";
                ComBx_SelectSlope_Sequence.DisplayMember = "Slope Name";

            }

        }

        private void Btn_Submit_Click(object sender, EventArgs e)
        {
            SubmitModel();

        }

        private void SubmitModel()
        {
            fully_Stable_flag = false;

            DGVAnalytical_Output.Rows.Clear();//reset master output grid
            DGVAnalytical_Output.DataSource = null;
            DGVAnalytical_Report.Rows.Clear();// reset report grid
            DGVAnalytical_Report.DataSource = null;
            DGVAnalytical_Report.Rows.Add();
            Num_UpDwn_CriticalNo.Enabled = false;
            Num_UpDwn_CriticalNo.Minimum = 0;
            Num_UpDwn_CriticalNo.Value = 0;
            Num_UpDwn_CriticalNo.Maximum = 0;

            if (ExtractDataFromDataBase() == false)//extract data from data base
                return;//Exit Method if Slope Slope Sequence is not defined properly
            else
                Draw_Model();

            RadBtnAnalyticalSolution.Enabled = true;
            RadBtnKinematicAnalysis.Enabled = true;
            RadBtnProbabilisticAnalysis.Enabled = true;

            Chk_Bx_Arcs.Checked = false;
            Chk_Bx_Arcs.Enabled = false;
            Chk_Bx_Arcs.Visible = false;

            if (ComBx_WhichModel_Prob.Text != ComBx_WhichModel.Text)
                ComBx_WhichModel_Prob.Text = ComBx_WhichModel.Text;

            Submit_Flag = true;
        }

        private void Draw_Model()
        {
            // now all data extracted from database and Every things is ready for model drawing
            Pnl_ModelDraw.Refresh();//refresh and delete Past Model

            int X_DrawWindow = Pnl_ModelDraw.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ModelDraw.Size.Height;//the height of drawing area
            int X_margine = 10;
            int Y_margine = 10;

            double Model_Height = 0;//Height of model befor Scaling
            double Model_Width = 0;//Width of model befor Scaling

            double X_Scale = 1;
            double Y_Scale = 1;

            double M_c_p = 0, M_c = 0, X_A = 0, X_B = 0, Y_A = 0, Y_B = 0;

            for (int i = 1; i <= SequencesNo; i++)// calculate Model Size 
            {
                Model_Height += System.Convert.ToDouble(SequenceList[i - 1, 20]);
                Model_Width += System.Convert.ToDouble(SequenceList[i - 1, 20])
                    / Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 19]) * Math.PI / 180d);
            }
            Model_Height += 0.5 * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20]);//top Extra Domain for model
            Model_Height *= 1.2;//Down Extra domain for model
            Model_Width += 0.5 * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20])
                / Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 19]) * Math.PI / 180d);//Right Extra domain for model
            Model_Width *= 1.2;//Left Extra domain for model

            X_Scale = (X_DrawWindow - 2 * X_margine) / Model_Width;
            Y_Scale = (Y_DrawWindow - 2 * Y_margine) / Model_Height;

            if (X_Scale > Y_Scale)
                DrawingScale = Y_Scale;
            else
                DrawingScale = X_Scale;

            Model_Points = new Point[5];
            All_Slope_Points = new double[SequencesNo + 2, 10];

            //bottom Left
            All_Slope_Points[0, 0] = 0;
            All_Slope_Points[0, 1] = 0;
            //top left
            All_Slope_Points[0, 2] = 0;
            All_Slope_Points[0, 3] = -DrawingScale * Model_Height / 6d;
            //top right
            All_Slope_Points[0, 4] = DrawingScale * Model_Width / 6d;
            All_Slope_Points[0, 5] = -DrawingScale * Model_Height / 6d;
            //bottom right
            All_Slope_Points[0, 6] = All_Slope_Points[0, 4] - All_Slope_Points[0, 3]
                / Math.Tan(System.Convert.ToDouble(SequenceList[0, 23]) * Math.PI / 180d);
            All_Slope_Points[0, 7] = 0;

            if (All_Slope_Points[0, 6] > DrawingScale * (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
            {
                All_Slope_Points[0, 7] = -(All_Slope_Points[0, 6] - (X_DrawWindow - 2 * X_margine))
                    * Math.Tan(System.Convert.ToDouble(SequenceList[0, 23]) * Math.PI / 180d);
                All_Slope_Points[0, 6] = All_Slope_Points[0, 6] - (X_DrawWindow - 2 * X_margine);
            }
            //5th point
            All_Slope_Points[0, 8] = All_Slope_Points[0, 6];
            All_Slope_Points[0, 9] = All_Slope_Points[0, 1];


            Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[0, 0]);
            Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[0, 1]);

            Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[0, 2]);
            Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[0, 3]);

            Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[0, 4]);
            Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[0, 5]);

            Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[0, 6]);
            Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[0, 7]);

            Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[0, 8]);
            Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[0, 9]);

            using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                g.FillPolygon(Brushes.Sienna, Model_Points);//draw Toe
            }// model toe drew
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            for (int i = 1; i <= SequencesNo; i++)//draw Slopes one by one
            {
                //0 bottom Left
                All_Slope_Points[i, 0] = All_Slope_Points[i - 1, 6];
                All_Slope_Points[i, 1] = All_Slope_Points[i - 1, 7];
                //1 top left
                All_Slope_Points[i, 2] = All_Slope_Points[i - 1, 4];
                All_Slope_Points[i, 3] = All_Slope_Points[i - 1, 5];
                //2 top right
                All_Slope_Points[i, 4] = All_Slope_Points[i, 2] + DrawingScale
                    * System.Convert.ToDouble(SequenceList[i - 1, 20]) / Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 19]) * Math.PI / 180d);
                All_Slope_Points[i, 5] = All_Slope_Points[i, 3] - DrawingScale * System.Convert.ToDouble(SequenceList[i - 1, 20]);

                //3 bottom right
                All_Slope_Points[i, 6] = All_Slope_Points[i, 4] + (All_Slope_Points[i, 1] - All_Slope_Points[i, 5])
                    / Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                All_Slope_Points[i, 7] = All_Slope_Points[i, 1];

                if (i < SequencesNo)
                    if (SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")// at intersection od Rock and soil in Soil_Rock Model
                    {
                        All_Slope_Points[i, 6] = All_Slope_Points[i, 4] + (All_Slope_Points[i, 1] - All_Slope_Points[i, 5])
                            / Math.Tan(System.Convert.ToDouble(SequenceList[i, 23]) * Math.PI / 180d);
                    }

                if (All_Slope_Points[i, 6] > (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
                {
                    All_Slope_Points[i, 7] = -(All_Slope_Points[i, 6] - (X_DrawWindow - 2 * X_margine))
                        * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                    All_Slope_Points[i, 6] = (X_DrawWindow - 2 * X_margine);
                }
                //5th point

                All_Slope_Points[i, 8] = All_Slope_Points[i, 6];
                All_Slope_Points[i, 9] = All_Slope_Points[i, 1];

                Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);

                Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[i, 2]);
                Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[i, 3]);

                Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[i, 4]);
                Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[i, 5]);

                Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);

                Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[i, 8]);
                Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[i, 9]);


                using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                                                                               //                    if (SequenceList[i - 1, 6] == "Rock")
                                                                               //                        g.FillPolygon(Brushes.LightGray, Model_Points);//draw Slope
                    if (SequenceList[i - 1, 6] == "Soil")
                        g.FillPolygon(Brushes.Bisque, Model_Points);//draw Slope
                    if (SequenceList[i - 1, 6] == "BIM")
                        g.FillPolygon(Brushes.LightGreen, Model_Points);//draw Slope
                }// this slope drew

            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //0 bottom Left
            All_Slope_Points[SequencesNo + 1, 0] = All_Slope_Points[SequencesNo, 6];
            All_Slope_Points[SequencesNo + 1, 1] = All_Slope_Points[SequencesNo, 7];
            //1 top left
            All_Slope_Points[SequencesNo + 1, 2] = All_Slope_Points[SequencesNo, 4];
            All_Slope_Points[SequencesNo + 1, 3] = All_Slope_Points[SequencesNo, 5];
            //2 top right
            All_Slope_Points[SequencesNo + 1, 4] = All_Slope_Points[SequencesNo + 1, 2] + 0.5
                * DrawingScale * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20])
                / Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 19]) * Math.PI / 180d);
            All_Slope_Points[SequencesNo + 1, 5] = All_Slope_Points[SequencesNo + 1, 3] - 0.5
                * DrawingScale * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20]);
            //3 bottom right
            All_Slope_Points[SequencesNo + 1, 6] = All_Slope_Points[SequencesNo + 1, 4]
                + (All_Slope_Points[SequencesNo + 1, 1] - All_Slope_Points[SequencesNo + 1, 5])
                / Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 23]) * Math.PI / 180d);
            All_Slope_Points[SequencesNo + 1, 7] = All_Slope_Points[SequencesNo + 1, 1];

            if (All_Slope_Points[SequencesNo + 1, 6] > (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
            {
                All_Slope_Points[SequencesNo + 1, 7] = -(All_Slope_Points[SequencesNo + 1, 6]
                    - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 23]) * Math.PI / 180d);
                All_Slope_Points[SequencesNo + 1, 6] = (X_DrawWindow - 2 * X_margine);
            }
            //5th point
            All_Slope_Points[SequencesNo + 1, 8] = All_Slope_Points[SequencesNo + 1, 6];
            All_Slope_Points[SequencesNo + 1, 9] = All_Slope_Points[SequencesNo + 1, 1];


            Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 0]);
            Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 1]);

            Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 2]);
            Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 3]);

            Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 4]);
            Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 5]);

            Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 6]);
            Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 7]);

            Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 8]);
            Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 9]);

            using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                if (SequenceList[SequencesNo - 1, 6] == "Rock")
                    g.FillPolygon(Brushes.WhiteSmoke, Model_Points);//draw Right Domain
                if (SequenceList[SequencesNo - 1, 6] == "Soil")
                    g.FillPolygon(Brushes.Beige, Model_Points);//draw Right Domain
                if (SequenceList[SequencesNo - 1, 6] == "BIM")
                    g.FillPolygon(Brushes.LightGreen, Model_Points);//draw Right Domain
            }//right poligon of model drew
            //until now we draw all slopes
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            SliceNo = 0;
            for (int i = 1; i <= SequencesNo; i++)
            {
                SliceNo += System.Convert.ToInt32(SequenceList[i - 1, 21]);
            }

            int k = 0;
            bool flag1 = true;
            Slices = new double[SliceNo, 10];//all slices and colomn points coordination
            for (int i = SequencesNo; i > 0; i--)//Calculate all slices and colomns points coordination....i= slope no.
            {
                for (int j = 1; j <= System.Convert.ToInt32(SequenceList[i - 1, 21]); j++)//j = Slice No
                {
                    flag1 = true;
                    if (i < SequencesNo)
                        if (j == 1 && SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")//to add triangular element in Soil_Rock Model
                        {
                            Slices[k, 1] = Slices[k - 1, 5];//TRX
                            Slices[k, 2] = Slices[k - 1, 6];//TRY
                            Slices[k, 5] = Slices[k - 1, 5];//TLX
                            Slices[k, 6] = Slices[k - 1, 6];//TLY
                            Slices[k, 3] = Slices[k - 1, 7];//BRX
                            Slices[k, 4] = Slices[k - 1, 8];//BRY
                            Slices[k, 7] = Slices[k - 1, 5];//BLX
                            Slices[k, 8] = 0;//BLY
                            Slices[k, 9] = i - 1;//SEQ NO

                            if (Slices[k, 3] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                            {
                                Slices[k, 4] = -(Slices[k, 3] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                Slices[k, 3] = (X_DrawWindow - 2 * X_margine);
                            }
                            if (Slices[k, 7] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                            {
                                Slices[k, 8] = -(Slices[k, 7] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                Slices[k, 7] = (X_DrawWindow - 2 * X_margine);
                            }
                            using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
                            {
                                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                                if (SequenceList[i - 1, 6] == "Rock")
                                {
                                    Slices[k, 0] = 0;
                                    g.DrawLine(Pens.Black,
                                        System.Convert.ToInt32(Slices[k, 1]),
                                        System.Convert.ToInt32(Slices[k, 2]),
                                        System.Convert.ToInt32(Slices[k, 3]),
                                        System.Convert.ToInt32(Slices[k, 4]));
                                }
                                /*                        if (SequenceList[i - 1, 6] == "Soil")
                                                        {
                                                            Slices[k, 0] = 1;
                                                            g.DrawLine(Pens.Salmon,
                                                                System.Convert.ToInt32(Slices[k, 1]),
                                                                System.Convert.ToInt32(Slices[k, 2]),
                                                                System.Convert.ToInt32(Slices[k, 3]),
                                                                System.Convert.ToInt32(Slices[k, 4]));
                                                        }
                                */
                                if (SequenceList[i - 1, 6] == "BIM")
                                {
                                    Slices[k, 0] = 2;
                                    g.DrawLine(Pens.Aquamarine,
                                        System.Convert.ToInt32(Slices[k, 1]),
                                        System.Convert.ToInt32(Slices[k, 2]),
                                        System.Convert.ToInt32(Slices[k, 3]),
                                        System.Convert.ToInt32(Slices[k, 4]));
                                }
                            }
                            flag1 = false;
                        }
                    if (flag1 == true)
                    {
                        Slices[k, 1] = System.Convert.ToInt32(All_Slope_Points[i, 4] - (j - 1) * (All_Slope_Points[i, 4] - All_Slope_Points[i, 2])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top right x
                        Slices[k, 2] = System.Convert.ToInt32(All_Slope_Points[i, 5] + (j - 1) * (All_Slope_Points[i, 3] - All_Slope_Points[i, 5])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top right Y
                        Slices[k, 3] = Slices[k, 1] - Slices[k, 2] / Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//Bottom right x
                        Slices[k, 4] = 0;//Bottom right Y
                        Slices[k, 5] = System.Convert.ToInt32(All_Slope_Points[i, 4] - j * (All_Slope_Points[i, 4] - All_Slope_Points[i, 2])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top Left x
                        Slices[k, 6] = System.Convert.ToInt32(All_Slope_Points[i, 5] + j * (All_Slope_Points[i, 3] - All_Slope_Points[i, 5])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top Left Y
                        Slices[k, 7] = Slices[k, 5] - Slices[k, 6] / Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//Bottom Left x
                        Slices[k, 8] = 0;//Bottom Left Y
                        Slices[k, 9] = i;//Sequence No

                        if (Slices[k, 3] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                        {
                            Slices[k, 4] = -(Slices[k, 3] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                            Slices[k, 3] = (X_DrawWindow - 2 * X_margine);
                        }
                        if (Slices[k, 7] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                        {
                            Slices[k, 8] = -(Slices[k, 7] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                            Slices[k, 7] = (X_DrawWindow - 2 * X_margine);
                        }
                        using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
                        {
                            g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                            if (SequenceList[i - 1, 6] == "Rock")
                            {
                                Slices[k, 0] = 0;
                                Model_Points[0].X = System.Convert.ToInt32(Slices[k, 7]);
                                Model_Points[0].Y = System.Convert.ToInt32(Slices[k, 8]);
                                Model_Points[1].X = System.Convert.ToInt32(Slices[k, 5]);
                                Model_Points[1].Y = System.Convert.ToInt32(Slices[k, 6]);
                                Model_Points[2].X = System.Convert.ToInt32(Slices[k, 1]);
                                Model_Points[2].Y = System.Convert.ToInt32(Slices[k, 2]);
                                Model_Points[3].X = System.Convert.ToInt32(Slices[k, 3]);
                                Model_Points[3].Y = System.Convert.ToInt32(Slices[k, 4]);
                                Model_Points[4].X = System.Convert.ToInt32(Slices[k, 3]);
                                if (Model_Points[3].X == X_DrawWindow - 2 * X_margine)
                                    Model_Points[4].Y = 0;
                                else
                                    Model_Points[4].Y = System.Convert.ToInt32(Slices[k, 4]);
                                if (SteppedSurface == true)
                                {
                                    M_c = Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                    M_c_p = -1d / M_c;
                                    X_A = Slices[k, 5];
                                    Y_A = Slices[k, 6];
                                    X_B = Slices[k, 1];
                                    Y_B = Slices[k, 2];
                                    double XXX = (Y_B - Y_A + M_c * X_A - M_c_p * X_B) / (M_c - M_c_p);
                                    Model_Points[1].X = System.Convert.ToInt32(XXX);
                                    Model_Points[1].Y = System.Convert.ToInt32(Y_B + M_c_p * (XXX - X_B));
                                }
                                g.FillPolygon(Brushes.LightGray, Model_Points);//draw Slope
                                g.DrawLine(Pens.Black,
                                    System.Convert.ToInt32(Slices[k, 1]),
                                    System.Convert.ToInt32(Slices[k, 2]),
                                    System.Convert.ToInt32(Slices[k, 3]),
                                    System.Convert.ToInt32(Slices[k, 4]));


                            }
                            /*                        if (SequenceList[i - 1, 6] == "Soil")
                                                    {
                                                        Slices[k, 0] = 1;
                                                        g.DrawLine(Pens.Salmon,
                                                            System.Convert.ToInt32(Slices[k, 1]),
                                                            System.Convert.ToInt32(Slices[k, 2]),
                                                            System.Convert.ToInt32(Slices[k, 3]),
                                                            System.Convert.ToInt32(Slices[k, 4]));
                                                    }
                            */
                            if (SequenceList[i - 1, 6] == "BIM")
                            {
                                Slices[k, 0] = 2;
                                g.DrawLine(Pens.Aquamarine,
                                    System.Convert.ToInt32(Slices[k, 1]),
                                    System.Convert.ToInt32(Slices[k, 2]),
                                    System.Convert.ToInt32(Slices[k, 3]),
                                    System.Convert.ToInt32(Slices[k, 4]));
                            }
                        }

                    }

                    k++;
                }
                ////////////////////////////////////////////////////////////////////////////////

                using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Model in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    if (SequenceList[i - 1, 6] == "Rock")
                        g.DrawLine(Pens.Black,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                    if (SequenceList[i - 1, 6] == "Soil")
                        g.DrawLine(Pens.Salmon,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                    if (SequenceList[i - 1, 6] == "BIM")
                        g.DrawLine(Pens.Aquamarine,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                }
            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            Anchor_Line = new double[AnchorNo, 7];//all cordination , force sequence data aboat each anchor
            Pen AnchorPen = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing anchors
            for (int i = 1; i <= AnchorNo; i++)//calculate anchors parameters and draw
            {
                Anchor_Line[i - 1, 0] = System.Convert.ToDouble(AnchorList[i - 1, 8]);//Sequence No.
                Anchor_Line[i - 1, 1] = All_Slope_Points[System.Convert.ToInt32(Anchor_Line[i - 1, 0]), 2] + DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 3])
                    / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180);//Anchor head X
                Anchor_Line[i - 1, 2] = All_Slope_Points[System.Convert.ToInt32(Anchor_Line[i - 1, 0]), 3] - DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 3]);//Anchor Head Y
                Anchor_Line[i - 1, 3] = Anchor_Line[i - 1, 1] + DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 5]) * Math.Cos(System.Convert.ToDouble(AnchorList[i - 1, 4]) * Math.PI / 180);//Anchor Point X
                Anchor_Line[i - 1, 4] = Anchor_Line[i - 1, 2] - DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 5]) * Math.Sin(System.Convert.ToDouble(AnchorList[i - 1, 4]) * Math.PI / 180);//Anchor Point Y
                Anchor_Line[i - 1, 5] = System.Convert.ToDouble(AnchorList[i - 1, 6]);//Anchor force
                Anchor_Line[i - 1, 6] = System.Convert.ToDouble(AnchorList[i - 1, 7]);// anchor yeild force
                using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Anchors in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLine(AnchorPen,// to draw anchor cable
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4]));
                    g.DrawLine(AnchorPen,//to draw anchor Head
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] + 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] - 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] - 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] + 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)));
                    g.FillEllipse(Brushes.Black,// to draw anchor point
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3] - 6),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4] - 7),
                        12, 14);
                }
            }
            //until now we drawn all anchors
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            Pen ForceLine = new Pen(Color.FromArgb(255, 255, 215, 0), 3);// thick pen for drawing forces
            for (int i = 1; i <= ForceNo; i++)
            {
                if (ForceList[i - 1, 2] == "Point")
                {
                    using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Anchors in it's panel
                    {
                        g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 40));
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)) + 3,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 10));
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)) - 3,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 10));
                    }
                }
                if (ForceList[i - 1, 2] == "Uniform")
                {
                    using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Anchors in it's panel
                    {
                        g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                        for (int j = 0; j <= 5; j++)
                        {
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 40));
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180) + 3),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 10));
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180) - 3),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 10));
                        }
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]))
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5])) - 40),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])))
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5]))) - 40));
                    }
                }
            }
            //Untill Now we drew all forces
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            Pen WaterLine = new Pen(Color.FromArgb(255, 0, 0, 255), 5);// thick pen for drawing water line
            WaterLevel = new Point[6 * SequencesNo];
            double m_w = 0, m_f = 0, m_c = 0, X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

            for (int i = 1; i <= SequencesNo; i++)// water line for each slope
            {
                m_w = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 41])) * Math.PI / 180);//dip of water line
                m_c = Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//dip of columns or slices
                m_f = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 19])) * Math.PI / 180);//dip of face

                WaterLevel[(i - 1) * 6 + 0].X = System.Convert.ToInt32(All_Slope_Points[i, 8]);
                WaterLevel[(i - 1) * 6 + 0].Y = System.Convert.ToInt32(All_Slope_Points[i, 9]);
                WaterLevel[(i - 1) * 6 + 1].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                WaterLevel[(i - 1) * 6 + 1].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);

                WaterLevel[(i - 1) * 6 + 2].Y = System.Convert.ToInt32(System.Convert.ToDouble(All_Slope_Points[i, 5])
                    + DrawingScale * System.Convert.ToDouble(SequenceList[i - 1, 39]));
                if (WaterLevel[(i - 1) * 6 + 2].Y >= 0)
                {
                    WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 2].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                    WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                }
                else
                {
                    X1 = System.Convert.ToDouble(All_Slope_Points[i, 4]);
                    Y1 = System.Convert.ToDouble(All_Slope_Points[i, 5]);
                    Y2 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].Y);
                    WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(X1 + (Y2 - Y1) / m_c);


                    if (i < SequencesNo)//for Soil_Rock Model
                        if (SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")
                        {
                            WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(X1 + (Y2 - Y1) /
                                (Math.Tan((System.Convert.ToDouble(SequenceList[i, 23])) * Math.PI / 180)));
                        }





                    X1 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].X);
                    Y1 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].Y);
                    Y2 = 0;
                    if (X1 + (Y2 - Y1) / m_w >= System.Convert.ToDouble(All_Slope_Points[i, 0])
                        && X1 + (Y2 - Y1) / m_w <= System.Convert.ToDouble(All_Slope_Points[i, 6]))
                    {
                        WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X1 + (Y2 - Y1) / m_w);
                        WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                        WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                        WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                        WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                    }
                    else
                    {
                        X2 = System.Convert.ToDouble(All_Slope_Points[i, 2]);
                        Y2 = System.Convert.ToDouble(All_Slope_Points[i, 3]);
                        if ((m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w) < 0 && (m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w) > Y2)
                        {
                            WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32((m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w));
                            WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X2 + (System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 3].Y) - Y2) / m_c);
                            WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                            WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        }
                        else
                        {
                            WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32((m_f * Y1 - m_w * Y2 + m_f * m_w * (X2 - X1)) / (m_f - m_w));
                            WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X2 + (System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 3].Y) - Y2) / m_f);
                            WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 2]);
                            WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 3]);
                            WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        }
                    }
                }
            }

            using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw water level in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                g.DrawLines(WaterLine, WaterLevel);
            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (SequenceList[0, 6] == "Rock")//if we have fully rock slope or rock-soil slope-> count rocky slopes
            {
                RockySlopeNo = 0;
                for (int i = 0; i < SequencesNo; i++)
                    if (SequenceList[i, 6] == "Rock")
                        RockySlopeNo++;
                BasalPlanePoints = new Point[RockySlopeNo + 1];
                BasalPlanePoints[0].X = System.Convert.ToInt32(All_Slope_Points[1, 2]);
                BasalPlanePoints[0].Y = System.Convert.ToInt32(All_Slope_Points[1, 3]);
                double M_B = 0;
                double M_C = 0;
                for (int i = 1; i <= RockySlopeNo; i++)
                {
                    M_B = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 31])) * Math.PI / 180);
                    M_C = Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);
                    X1 = BasalPlanePoints[i - 1].X;
                    Y1 = BasalPlanePoints[i - 1].Y;
                    X2 = All_Slope_Points[i, 4];
                    Y2 = All_Slope_Points[i, 5];
                    BasalPlanePoints[i].X = System.Convert.ToInt32((Y2 - Y1 + M_B * X1 - M_C * X2) / (M_B - M_C));
                    BasalPlanePoints[i].Y = System.Convert.ToInt32(Y1 + M_B * (System.Convert.ToDouble(BasalPlanePoints[i].X) - X1));
                }
                Pen BasalLine = new Pen(Color.FromArgb(112, 128, 144, 255), 3);// thick pen for drawing water line
                using (Graphics g = Pnl_ModelDraw.CreateGraphics())//draw Anchors in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLines(BasalLine, BasalPlanePoints);
                }
            }

        }

        private bool ExtractDataFromDataBase()
        {
            int j = 0;
            string ErrorString = "";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Model = new DataTable();
            int thisModelModelId = 0;// Extract model id from Database
            string thisModelModelName = "";// Extract model name from Database
            double thisModelKh = 0;// Extract Kh from database
            double thisModelKh_Deviation = 0;// Extract Kh from database Deviation
            double thisModelKv = 0;// Extract Kv from database
            double thisModelKv_Deviation = 0;// Extract Kv from database Deviation
            string thisModelType = "";// Extract Model type from database

            if(RadBtnProbabilisticAnalysis.Checked == true)
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '" + ComBx_WhichModel_Prob.Text + "'";//read model data and copy them to datatable
            else
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '" + ComBx_WhichModel.Text + "'";//read model data and copy them to datatable

            try
            {
                dt_Model.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Model);
                Connection.Close();
                thisModelModelId = System.Convert.ToInt32(dt_Model.Rows[0].ItemArray[0]);// Extract model id from Database
                thisModelModelName = System.Convert.ToString(dt_Model.Rows[0].ItemArray[1]);// Extract model name from Database
                thisModelKh = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[2]);// Extract Kh from database
                thisModelKh_Deviation = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[3]);// Extract Kh from database Deviation
                thisModelKv = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[4]);// Extract Kv from database
                thisModelKv_Deviation = System.Convert.ToDouble(dt_Model.Rows[0].ItemArray[5]);// Extract Kv from database Deviation
                thisModelType = System.Convert.ToString(dt_Model.Rows[0].ItemArray[6]);// Extract Model type from database

            }
            catch
            {
                return false;
            }


            Query.CommandText = "SELECT * FROM Tbl_Slope_Sequence Where Id_Model = '" + System.Convert.ToString(thisModelModelId) + "'";//read all data fo all sequences of the model and copy all the information to datatable
            DataTable dt_Sequences = new DataTable();
            dt_Sequences.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Sequences);
            Connection.Close();
            SequencesNo = dt_Sequences.Rows.Count;// Extract No of sequences in the model definition


            dt_Sequences.DefaultView.Sort = "Sequence No ASC";
            dt_Sequences = dt_Sequences.DefaultView.ToTable();//Sequense data table sorted Ascending


            if (System.Convert.ToInt32(dt_Sequences.Rows[SequencesNo - 1].ItemArray[4]) != SequencesNo)// check if all sequences was not define
            {
                j = 1;
                for (int i = 1; i <= System.Convert.ToInt32(dt_Sequences.Rows[SequencesNo - 1].ItemArray[4]); i++)//find not defined sequnences
                {
                    if (System.Convert.ToInt32(dt_Sequences.Rows[j - 1].ItemArray[4]) != i)
                        ErrorString += "\n Slope Sequence No. " + System.Convert.ToString(i) + " Is Not Defined";
                    else
                        j = i + 1;
                }
                MessageBox.Show(ErrorString);//error solving instruction 
                return (false);//exit from this method
            }
            SequenceList = new string[SequencesNo, 67];// all slopes properties stores in this array//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            Origin_SequenceList = new string[SequencesNo, 67];// all slopes properties stores in this array//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            ModelDetail[1] = System.Convert.ToString(thisModelModelId);//this model Id
            ModelDetail[2] = System.Convert.ToString(thisModelModelName);//this model name
            ModelDetail[3] = System.Convert.ToString(thisModelKh);//this model Kh
            ModelDetail[4] = System.Convert.ToString(thisModelKh_Deviation);//this model Kh Deviation
            ModelDetail[5] = System.Convert.ToString(thisModelKv);//this model Kv
            ModelDetail[6] = System.Convert.ToString(thisModelKv_Deviation);//this model KvDeviation
            ModelDetail[7] = System.Convert.ToString(thisModelType);//this model Type
            ModelDetail[8] = System.Convert.ToString(dt_Model.Rows[0].ItemArray[7]);//this model Kh Dist
            ModelDetail[9] = System.Convert.ToString(dt_Model.Rows[0].ItemArray[8]);//this model Kv Dist
            for (int Counter = 0; Counter < 10; Counter++)
                Origin_ModelDetail[Counter] = ModelDetail[Counter];
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            for (int i = 1; i <= SequencesNo; i++)// to gadder all information about all slope sequences
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] Where Id_Slope = '"
                    + System.Convert.ToString(dt_Sequences.Rows[i - 1].ItemArray[2]) + "'";//read all data of Slopes that created sequenses
                DataTable dt_Slope = new DataTable();
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();

                SequenceList[i - 1, 1] = i.ToString();//Sequence No.
                SequenceList[i - 1, 2] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[0]);//Slope Id
                SequenceList[i - 1, 3] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[1]);//Slope Name
                SequenceList[i - 1, 4] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[2]);//Material Id


                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material] Where Id_Material = '"
                    + System.Convert.ToString(SequenceList[i - 1, 4]) + "'";//read material information of slope
                DataTable dt_Material = new DataTable();
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();

                SequenceList[i - 1, 5] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[1]);//Material Name
                SequenceList[i - 1, 6] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[2]);//Material Type
                SequenceList[i - 1, 7] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[3]);//Material 'Cohesive Strength'
                SequenceList[i - 1, 8] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[4]);//Material 'Cohesive Strength Deviation'
                SequenceList[i - 1, 9] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[5]);//Material 'Friction Angle'
                SequenceList[i - 1, 10] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[6]);//Material 'Friction Angle Deviation'
                SequenceList[i - 1, 11] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[7]);//Material Unit weight
                SequenceList[i - 1, 12] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[8]);//Material Unit weight Deviation
                SequenceList[i - 1, 13] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[9]);//Material Tensile strength
                SequenceList[i - 1, 14] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[10]);//Material Tensile strength Deviation
                SequenceList[i - 1, 15] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[11]);//Material Young Modulus
                SequenceList[i - 1, 16] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[12]);//Material Young Modulus Deviation
                SequenceList[i - 1, 17] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[13]);//Material Poisson Ratio
                SequenceList[i - 1, 18] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[14]);//Material Poisson Ratio Deviation

                SequenceList[i - 1, 51] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[15]);//Material 'Cohesive Strength' Distribution
                SequenceList[i - 1, 52] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[16]);//Material 'Friction Angle' Distribution
                SequenceList[i - 1, 53] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[17]);//Material Unit weight Distribution
                SequenceList[i - 1, 54] = System.Convert.ToString(dt_Material.Rows[0].ItemArray[18]);//Material Tensile strength Distribution


                SequenceList[i - 1, 19] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[3]);//'Face Angle'
                SequenceList[i - 1, 20] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[4]);//'Face Height'
                SequenceList[i - 1, 21] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[5]);//Face Column No
                if (i > 1)
                    if (ModelDetail[7] == "Soil_Rock" && SequenceList[i - 1, 6] == "Rock" && SequenceList[i - 2, 6] == "Soil")
                        SequenceList[i - 2, 21] = System.Convert.ToString(System.Convert.ToInt32(SequenceList[i - 2, 21]) + 1);//for one extra triangular Element
                SequenceList[i - 1, 22] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[6]);//Face Column No Deviation
                SequenceList[i - 1, 23] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[7]);//'Column Angle'
                SequenceList[i - 1, 24] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[8]);//'Column Angle Deviation'


                SequenceList[i - 1, 55] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[20]);//Face Column No Distribution
                SequenceList[i - 1, 56] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[21]);//Face 'Column Angle' Distribution



                SequenceList[i - 1, 25] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[9]);//Column Joint Id

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint] Where Id_Joint = '"
                    + System.Convert.ToString(SequenceList[i - 1, 25]) + "'";//read column joints information of slopes
                DataTable dt_Joint = new DataTable();
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                SequenceList[i - 1, 26] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[1]);//column 'Joint Name'
                SequenceList[i - 1, 27] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[2]);//column Joint 'Cohesive Strength'
                SequenceList[i - 1, 28] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[3]);//column Joint 'Cohesive Strength Deviation'
                SequenceList[i - 1, 29] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[4]);//column Joint 'Friction Angle'
                SequenceList[i - 1, 30] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[5]);//column Joint 'Friction Angle Deviation'

                SequenceList[i - 1, 57] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[6]);//column Joint 'Cohesive Strength' Distribution
                SequenceList[i - 1, 58] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[7]);//column Joint 'Friction Angle' Distribution



                SequenceList[i - 1, 31] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[10]);//'Basal Plane Angle'
                SequenceList[i - 1, 32] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[11]);//'Basal Plane Angle Deviation'

                SequenceList[i - 1, 59] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[22]);//'Basal Plane Angle' Distribution


                SequenceList[i - 1, 33] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[12]);//Basal Joint Id

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint] Where Id_Joint = '"
                    + System.Convert.ToString(SequenceList[i - 1, 33]) + "'";//read basal joints information of slopes
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                SequenceList[i - 1, 34] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[1]);//Basal 'Joint Name'
                SequenceList[i - 1, 35] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[2]);//Basal Joint 'Cohesive Strength'
                SequenceList[i - 1, 36] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[3]);//Basal Joint 'Cohesive Strength Deviation'
                SequenceList[i - 1, 37] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[4]);//Basal Joint 'Friction Angle'
                SequenceList[i - 1, 38] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[5]);//Basal Joint 'Friction Angle Deviation'

                SequenceList[i - 1, 60] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[6]);//Basal Joint 'Cohesive Strength' Distribution
                SequenceList[i - 1, 61] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[7]);//Basal Joint 'Friction Angle' Distribution


                SequenceList[i - 1, 39] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[13]);//'Top Water Level'
                SequenceList[i - 1, 40] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[14]);//'Top Water Level Deviation'
                SequenceList[i - 1, 41] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[15]);//'Water Level Angle'
                SequenceList[i - 1, 42] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[16]);//'Water Level Angle Deviation'


                SequenceList[i - 1, 62] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[23]);//'Water Level Angle' Distribution
                SequenceList[i - 1, 63] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[24]);//'Water Level Angle Deviation' Distribution


                SequenceList[i - 1, 43] = System.Convert.ToString(dt_Sequences.Rows[i - 1].ItemArray[3]);//sequence Joint Id

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint] Where Id_Joint = '"
                    + System.Convert.ToString(SequenceList[i - 1, 43]) + "'";//read sequence joints information of slopes
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                SequenceList[i - 1, 44] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[1]);//Sequence 'Joint Name'
                SequenceList[i - 1, 45] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[2]);//Sequence Joint 'Cohesive Strength'
                SequenceList[i - 1, 46] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[3]);//Sequence Joint 'Cohesive Strength Deviation'
                SequenceList[i - 1, 47] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[4]);//Sequence Joint 'Friction Angle'
                SequenceList[i - 1, 48] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[5]);//Sequence Joint 'Friction Angle Deviation'

                SequenceList[i - 1, 64] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[6]);//Sequence Joint 'Cohesive Strength' Distribution
                SequenceList[i - 1, 65] = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[7]);//Sequence Joint 'Friction Angle' Distribution


                SequenceList[i - 1, 49] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[17]);//Slope Column Blockiness
                SequenceList[i - 1, 50] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[18]);//Slope Column Blockiness Deviation

                SequenceList[i - 1, 66] = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[25]);//Slope Column Blockiness Distribution

            }
            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                    Origin_SequenceList[RowCounter, ClmCounter] = SequenceList[RowCounter, ClmCounter];//save original data for probabilistic analysis
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Anchor] Where Id_Model = '"
                + System.Convert.ToString(thisModelModelId) + "'";//read anchors information
            DataTable dt_Anchor = new DataTable();
            dt_Anchor.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Anchor);
            Connection.Close();

            dt_Anchor.DefaultView.Sort = "Id_Slope ASC";
            dt_Anchor = dt_Anchor.DefaultView.ToTable();//Anchor data table sorted Ascending
            AnchorNo = dt_Anchor.Rows.Count;// Extract No of Anchor in the model definition
            AnchorList = new string[AnchorNo, 9];// all Anchor properties store in this array

            int k = 0;
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            for (int i = 1; i <= AnchorNo; i++)//Store Anchors Data in array....i=Anchor No.
            {
                for (j = 1; j <= SequencesNo; j++)//j=Slope No.
                {
                    if (System.Convert.ToInt32(dt_Anchor.Rows[i - 1].ItemArray[2]) == System.Convert.ToInt32(SequenceList[j - 1, 2]))
                    {
                        AnchorList[k, 0] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[0]);//Anchor Id
                        AnchorList[k, 1] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[1]);//Anchor Name
                        AnchorList[k, 2] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[2]);//Slope Id
                        AnchorList[k, 3] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[4]);//Height in face
                        AnchorList[k, 4] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[5]);//'Anchor Angle'
                        AnchorList[k, 5] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[6]);//'Anchor Length'
                        AnchorList[k, 6] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[7]);//Anchorage force
                        AnchorList[k, 7] = System.Convert.ToString(dt_Anchor.Rows[i - 1].ItemArray[8]);//Anchorage yeild force
                        AnchorList[k, 8] = System.Convert.ToString(j);//Sequence
                        k++;//k = usable Anchors
                    }
                }
            }
            AnchorNo = k;
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force] Where Model_Id = '"
                + System.Convert.ToString(thisModelModelId) + "'";//read forces information
            DataTable dt_Forces = new DataTable();
            dt_Forces.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Forces);
            Connection.Close();

            dt_Forces.DefaultView.Sort = "Slope_Id ASC";
            dt_Forces = dt_Forces.DefaultView.ToTable();//Force data table sorted Ascending
            ForceNo = dt_Forces.Rows.Count;// Extract No of Force in the model definition
            ForceList = new string[ForceNo, 9];// all Anchor properties store in this array///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            k = 0;
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            for (int i = 1; i <= ForceNo; i++)
            {
                for (j = 1; j <= SequencesNo; j++)//j=Slope No.
                {
                    if (System.Convert.ToInt32(dt_Forces.Rows[i - 1].ItemArray[4]) == System.Convert.ToInt32(SequenceList[j - 1, 2]))
                    {
                        ForceList[k, 0] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[0]);//Force Id
                        ForceList[k, 1] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[1]);//Force Name
                        ForceList[k, 2] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[2]);//Force Type
                        ForceList[k, 3] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[3]);//Model Id
                        ForceList[k, 4] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[4]);//Slope Id
                        ForceList[k, 5] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[5]);//From Height
                        ForceList[k, 6] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[6]);//to Height
                        ForceList[k, 7] = System.Convert.ToString(dt_Forces.Rows[i - 1].ItemArray[7]);//force
                        ForceList[k, 8] = System.Convert.ToString(j);//Sequence No
                        k++;//k = usable Anchors
                    }
                }
            }
            ForceNo = k;
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            return (true);
        }

        private void ComBx_SelectModel_Sequence_SelectedIndexChanged(object sender, EventArgs e)
        {
            RefreshSlope();
            Refresh_ComBx_SequenceNo();
        }

        private void Btn_Export_Excel_Analytical_Result_Click(object sender, EventArgs e)
        {
            Form2 frm2 = new Form2(Sorted_All_Model_Details.GetLength(0));
            frm2.ShowDialog();
            if (Export_opp == true)
                Excel_Analytical_Result_Export();
        }

        private void Excel_Analytical_Result_Export()
        {
            string Excel_Path = "C:\\Topple2\\";
            string print_date;

            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            Excel_Path = "C:\\Topple2\\Output Data\\";


            Excel.Application app = new Excel.Application();
            Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
            Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;

            print_date = System.Convert.ToString(DateTime.Now.Day) + "_"
                + System.Convert.ToString(DateTime.Now.Month) + "_"
                + System.Convert.ToString(DateTime.Now.Year) + "___"
                + System.Convert.ToString(DateTime.Now.Hour) + "_"
                + System.Convert.ToString(DateTime.Now.Minute) + "_"
                + System.Convert.ToString(DateTime.Now.Second);

            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            Excel_Path = "C:\\Topple2\\Output Data\\Analytical Analaysis Results\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Data\\Analytical Analaysis Results\\" + ModelDetail[2] + "\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);


            app.Visible = true;


            int k = 1;
            for (int SheetNo = System.Convert.ToInt32(Export_FromNo); SheetNo <= Export_ToNo; SheetNo++)
            {
                //               app.Visible = true;
                if (SheetNo > Export_FromNo)
                    worksheet = workbook.Sheets.Add();
                worksheet = workbook.Sheets["Sheet" + System.Convert.ToString(k)];
                worksheet = workbook.ActiveSheet;
                worksheet.Name = "Analaysis Results " + System.Convert.ToString(SheetNo);

                //            worksheet = workbook.Sheets["Sheet1"];
                //            worksheet = workbook.ActiveSheet;
                //            worksheet.Name = "Analytical Analaysis Results";

                Excel.Range range = worksheet.Range["A6:CC6"];

                worksheet.Cells.Style.HorizontalAlignment = Excel.XlHAlign.xlHAlignCenter;//center horizontaly 
                worksheet.Cells.Style.VerticalAlignment = Excel.XlVAlign.xlVAlignCenter;//center vertically

                worksheet.Range[worksheet.Cells[1, 2], worksheet.Cells[1, 3]].Merge();
                worksheet.Range[worksheet.Cells[2, 2], worksheet.Cells[2, 3]].Merge();
                worksheet.Range[worksheet.Cells[1, 6], worksheet.Cells[1, 7]].Merge();
                worksheet.Range[worksheet.Cells[2, 5], worksheet.Cells[2, 7]].Merge();

                worksheet.Cells[1, 1] = "Date:";
                worksheet.Cells[1, 2] = System.Convert.ToString(DateTime.Now.Day) + "/" + System.Convert.ToString(DateTime.Now.Month) + "/" + System.Convert.ToString(DateTime.Now.Year);
                worksheet.Cells[2, 1] = "Time:";
                worksheet.Cells[2, 2] = System.Convert.ToString(DateTime.Now.Hour) + ":" + System.Convert.ToString(DateTime.Now.Minute) + ":" + System.Convert.ToString(DateTime.Now.Second);
                worksheet.Cells[1, 5] = "Export by:";
                worksheet.Cells[1, 6] = "Total Slope";
                worksheet.Cells[2, 5] = "akbarardestani@ut.ac.ir";


                worksheet.Range["A4:S4"].Cells.WrapText = true;


                range = worksheet.Range["A4:S4"];
                range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.CornflowerBlue;

                range = worksheet.Range["A5:A" + System.Convert.ToString(SliceNo + 4)];
                range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.OrangeRed;

                range = worksheet.Range["B5:S" + System.Convert.ToString(SliceNo + 4)];
                range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.PaleGoldenrod;


                worksheet.Cells[4, 1] = "No";
                worksheet.Cells[4, 2] = "Material \nType";
                worksheet.Cells[4, 3] = "Slice/Column \nHeight \n(m)";
                worksheet.Cells[4, 4] = "Slice/Column \nWeight \n(N)";
                worksheet.Cells[4, 5] = "Slice/Column \nBase Angle \n(m)";
                worksheet.Cells[4, 6] = "Sliding \nforce \n(N)";
                worksheet.Cells[4, 7] = "Toppling \nForce \n(N)";
                worksheet.Cells[4, 8] = "Flexural \nToppling \nForce \n(N)";
                worksheet.Cells[4, 9] = "Shear \nForce \n(N)";
                worksheet.Cells[4, 10] = "Force \n(N)";
                worksheet.Cells[4, 11] = "Force \nHeight \n(m)";
                worksheet.Cells[4, 12] = "Force \nAngle \n(Degree)";
                worksheet.Cells[4, 13] = "Failure \nMode";
                worksheet.Cells[4, 14] = "X Bottom \nLeft \nCorner";
                worksheet.Cells[4, 15] = "Y Bottom \nLeft \nCorner";
                worksheet.Cells[4, 16] = "X Bottom \nMiddle \nCorner";
                worksheet.Cells[4, 17] = "X Bottom \nMiddle \nCorner";
                worksheet.Cells[4, 18] = "X Bottom \nRight \nCorner";
                worksheet.Cells[4, 19] = "X Bottom \nRight \nCorner";

                for (int i = 0; i < SliceNo; i++)
                    for (int j = 0; j < 19; j++)
                        worksheet.Cells[5 + i, j + 1] = Sorted_Critical_Situation_Charts[SheetNo - 1, SliceNo - i, j];

                worksheet.Range["U4:AF4"].Cells.WrapText = true;

                range = worksheet.Range["U4:AF4"];
                range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.CornflowerBlue;


                range = worksheet.Range["U5:AF5"];
                range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.PaleGoldenrod;

                worksheet.Cells[4, 21] = "Result";
                worksheet.Cells[4, 22] = "Tension Crack \nDistance \nFrom Toe";
                worksheet.Cells[4, 23] = "Tension Crack \nDepth";
                worksheet.Cells[4, 24] = "Tention Crack \nSlice/Column \nNo";
                worksheet.Cells[4, 25] = "Circular Failure \nPlain Raidus";
                worksheet.Cells[4, 26] = "Arc \nAngle";
                worksheet.Cells[4, 27] = "X Arc \nCenter";
                worksheet.Cells[4, 28] = "Y Arc \nCenter";
                worksheet.Cells[4, 29] = "Column/Slice \nNo.";
                worksheet.Cells[4, 30] = "From No.";
                worksheet.Cells[4, 31] = "To No.";
                worksheet.Cells[4, 32] = "Tension \nCrack \n Step NO.";


                worksheet.Cells[5, 21] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 0];
                worksheet.Cells[5, 22] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 1];
                worksheet.Cells[5, 23] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 2];
                worksheet.Cells[5, 24] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 3];
                worksheet.Cells[5, 25] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 4];
                worksheet.Cells[5, 26] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 5];
                worksheet.Cells[5, 27] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 6];
                worksheet.Cells[5, 28] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 7];
                worksheet.Cells[5, 29] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 8];
                worksheet.Cells[5, 30] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 9];
                worksheet.Cells[5, 31] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 10];
                worksheet.Cells[5, 32] = Sorted_Critical_Situation_Charts[SheetNo - 1, 0, 11];



                range = worksheet.Range["A5:A" + System.Convert.ToString(SliceNo + 4)];
                var dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["C5:C" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["D5:D" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["E5:E" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["F5:F" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["G5:G" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["H5:H" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["I5:I" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["j5:j" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["K5:k" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                range = worksheet.Range["L5:L" + System.Convert.ToString(SliceNo + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;

                Excel.Range myCell = (Excel.Range)worksheet.Cells[7, 2];
                myCell = (Excel.Range)worksheet.Cells[5, 2];
                myCell.Activate();
                myCell.Application.ActiveWindow.FreezePanes = true;





                range = worksheet.Range["A" + System.Convert.ToString(SliceNo + 6) + ":CC" + System.Convert.ToString(SliceNo + 6)];


                worksheet.Range["A" + System.Convert.ToString(SliceNo + 6) + ":CC" + System.Convert.ToString(SliceNo + 6)].Cells.WrapText = true;

                range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.CornflowerBlue;


                worksheet.Cells[SliceNo + 6, 1] = "X \nSlice/Column \nNo";
                worksheet.Cells[SliceNo + 6, 2] = "X \nTop \nLeft";
                worksheet.Cells[SliceNo + 6, 3] = "Y \nTop \nLeft";
                worksheet.Cells[SliceNo + 6, 4] = "X \nTop \nMiddle";
                worksheet.Cells[SliceNo + 6, 5] = "Y \nTop \nMiddle";
                worksheet.Cells[SliceNo + 6, 6] = "X \nTop \nRight";
                worksheet.Cells[SliceNo + 6, 7] = "Y \nTop \nRight";
                worksheet.Cells[SliceNo + 6, 8] = "X \nBottom \nLeft";
                worksheet.Cells[SliceNo + 6, 9] = "Y \nBottom \nLeft";
                worksheet.Cells[SliceNo + 6, 10] = "X \nBottom \nMiddle";
                worksheet.Cells[SliceNo + 6, 11] = "Y \nBottom \nMiddle";
                worksheet.Cells[SliceNo + 6, 12] = "X \nBottom \nRight";
                worksheet.Cells[SliceNo + 6, 13] = "Y \nBottom \nRight";
                worksheet.Cells[SliceNo + 6, 14] = "X \nWater Level \nRight";
                worksheet.Cells[SliceNo + 6, 15] = "Y \nWater Level \nRight";
                worksheet.Cells[SliceNo + 6, 16] = "X \nWater Level \nMiddle";
                worksheet.Cells[SliceNo + 6, 17] = "Y \nWater Level \nMiddle";
                worksheet.Cells[SliceNo + 6, 18] = "X \nWater Level \nRight";
                worksheet.Cells[SliceNo + 6, 19] = "Y \nWater Level \nRight";
                worksheet.Cells[SliceNo + 6, 20] = "Slice/Column \nRight \nHeight";
                worksheet.Cells[SliceNo + 6, 21] = "Slice/Column \nMean \nHeight";
                worksheet.Cells[SliceNo + 6, 22] = "Slice/Column \nLeft \nHeight";
                worksheet.Cells[SliceNo + 6, 23] = "Water Level \nRight \nHeight";
                worksheet.Cells[SliceNo + 6, 24] = "Water Level \nMean \nHeight";
                worksheet.Cells[SliceNo + 6, 25] = "Water Level \nLeft \nHeight";
                worksheet.Cells[SliceNo + 6, 26] = "Slice/Column \nWeight";
                worksheet.Cells[SliceNo + 6, 27] = "Slice/Column \nTop Load";
                worksheet.Cells[SliceNo + 6, 28] = "Slice/Column \nAnchorage \nForce";
                worksheet.Cells[SliceNo + 6, 29] = "Slice/Column \nAnchorage \nForce Angle";
                worksheet.Cells[SliceNo + 6, 30] = "Slice/Column \nAnchorage \nYield Force";
                worksheet.Cells[SliceNo + 6, 31] = "Material \nType";
                worksheet.Cells[SliceNo + 6, 32] = "Material \nC";
                worksheet.Cells[SliceNo + 6, 33] = "Material \nC \nDeviation";
                worksheet.Cells[SliceNo + 6, 34] = "Material \nϕ";
                worksheet.Cells[SliceNo + 6, 35] = "Material \nϕ \nDeviation";
                worksheet.Cells[SliceNo + 6, 36] = "Material \nUnit Weight(N)";
                worksheet.Cells[SliceNo + 6, 37] = "Material \nUnit Weight(N) \nDeviation";
                worksheet.Cells[SliceNo + 6, 38] = "Material \nɣ";
                worksheet.Cells[SliceNo + 6, 39] = "Material \nɣ \nDeviation";
                worksheet.Cells[SliceNo + 6, 39] = "Material \nE";
                worksheet.Cells[SliceNo + 6, 40] = "Material \nE \nDeviation";
                worksheet.Cells[SliceNo + 6, 41] = "Material \nν";
                worksheet.Cells[SliceNo + 6, 42] = "Material \nν \nDeviation";
                worksheet.Cells[SliceNo + 6, 44] = "Slope \nFace \nAngle";
                worksheet.Cells[SliceNo + 6, 45] = "Slice/Column \nThickness";
                worksheet.Cells[SliceNo + 6, 46] = "Slice/Column \nNo";
                worksheet.Cells[SliceNo + 6, 47] = "Slice/Column \nNo \nDeviation";
                worksheet.Cells[SliceNo + 6, 48] = "Slice/Column \nNo \nin Slope";
                worksheet.Cells[SliceNo + 6, 49] = "Slice/Column \nNo \nin All";
                worksheet.Cells[SliceNo + 6, 50] = "Slope \nNo";
                worksheet.Cells[SliceNo + 6, 51] = "Slice/Column \nAngle";
                worksheet.Cells[SliceNo + 6, 52] = "Slice/Column \nAngle \nDeviation";
                worksheet.Cells[SliceNo + 6, 53] = "Slice/Column \nJoint C";
                worksheet.Cells[SliceNo + 6, 54] = "Slice/Column \nJoint C \nDeviation";
                worksheet.Cells[SliceNo + 6, 55] = "Slice/Column \nJoint ϕ";
                worksheet.Cells[SliceNo + 6, 56] = "Slice/Column \nJoint ϕ \nDeviation";
                worksheet.Cells[SliceNo + 6, 57] = "Slice/Column \nBasal Angle";
                worksheet.Cells[SliceNo + 6, 58] = "Slice/Column \nBasal Angle \nDeviation";
                worksheet.Cells[SliceNo + 6, 59] = "Slice/Column \nBasal Joint C";
                worksheet.Cells[SliceNo + 6, 60] = "Slice/Column \nBasal Joint C \nDeviation";
                worksheet.Cells[SliceNo + 6, 61] = "Slice/Column \nBasal Joint ϕ";
                worksheet.Cells[SliceNo + 6, 62] = "Slice/Column \nBasal Joint ϕ \nDeviation";
                worksheet.Cells[SliceNo + 6, 63] = "Slope Right \nInteraction C";
                worksheet.Cells[SliceNo + 6, 64] = "Slope Right \nInteraction C \nDeviation ";
                worksheet.Cells[SliceNo + 6, 65] = "Slope Right \nInteraction ϕ";
                worksheet.Cells[SliceNo + 6, 66] = "Slope Right \nInteraction ϕ \nDeviation";
                worksheet.Cells[SliceNo + 6, 67] = "Blockiness \n%";
                worksheet.Cells[SliceNo + 6, 68] = "Blockiness \nDeviation";
                worksheet.Cells[SliceNo + 6, 69] = "Blockiness \nSituation";
                worksheet.Cells[SliceNo + 6, 70] = "Model \nType";
                worksheet.Cells[SliceNo + 6, 71] = "Right \nForce";
                worksheet.Cells[SliceNo + 6, 72] = "Left \nForce";
                worksheet.Cells[SliceNo + 6, 73] = "Right \nForce \nAngle";
                worksheet.Cells[SliceNo + 6, 74] = "Left \nForce \nAngle";
                worksheet.Cells[SliceNo + 6, 75] = "Right \nForce \nHeight";
                worksheet.Cells[SliceNo + 6, 76] = "Left \nFore \nHeight";
                worksheet.Cells[SliceNo + 6, 77] = "Sliding \nForce";
                worksheet.Cells[SliceNo + 6, 78] = "Topling \nForce";
                worksheet.Cells[SliceNo + 6, 79] = "Flexural \nToppling \nForce";
                worksheet.Cells[SliceNo + 6, 80] = "Shear \nForce";
                worksheet.Cells[SliceNo + 6, 81] = "Failure \nmode";


                range = worksheet.Range["B" + System.Convert.ToString(SliceNo + 7) + ":CC" + System.Convert.ToString(2 * SliceNo + 6)];
                range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.PaleGoldenrod;

                range = worksheet.Range["A" + System.Convert.ToString(SliceNo + 7) + ":A" + System.Convert.ToString(2 * SliceNo + 6)];
                range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
                range.Borders.Weight = 3;
                range.Interior.Color = Color.OrangeRed;



                for (int i = 0; i < SliceNo; i++)
                    for (int j = 0; j < 81; j++)
                    {
                        if (j == 0)
                        {
                            worksheet.Cells[SliceNo + 7 + i, j + 1] = SliceNo - i;
                        }
                        else if (j == 30)
                        {
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 1)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 2)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 3)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "BIM";
                        }
                        else if (j == 68)
                        {
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 0)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Flexural";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 1)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Blocky";
                        }
                        else if (j == 69)
                        {
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 1)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 2)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 3)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock_Soil";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 4)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil_Rock";
                        }
                        else if (j == 80)
                        {
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 0)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Stable";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 1)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Sliding";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 2)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Toppling";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 3)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Flexural Toppling";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 4)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Shear";
                            if (Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1] == 5)
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = "Unstable";
                        }
                        else
                            worksheet.Cells[SliceNo + 7 + i, j + 1] = Sorted_All_Model_Details[SheetNo - 1, SliceNo - i - 1, j - 1];
                    }

                range = worksheet.Range["A1:CC" + System.Convert.ToString(2 * SliceNo + 6)];
                range.Columns.AutoFit();


                /*
                Excel.ChartObjects xlCharts = (Excel.ChartObjects)worksheet.ChartObjects(Type.Missing);
                Excel.ChartObject myChart = (Excel.ChartObject)xlCharts.Add(50, 200, 700, 300);
                Excel.Chart chartPage = myChart.Chart;



                range = worksheet.Range["A5,A" + System.Convert.ToString(SliceNo + 4) + ",j5:j" + System.Convert.ToString(SliceNo + 4)];
                chartPage.SetSourceData(range, Missing.Value);
                chartPage.ChartType = Excel.XlChartType.xlXYScatterSmooth;

                */

                k++;
            }
            workbook.SaveAs(Excel_Path + ModelDetail[2] + print_date + ".xlsx", Missing.Value, Missing.Value
                , Missing.Value, Missing.Value, Missing.Value, Excel.XlSaveAsAccessMode.xlNoChange
                , Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value);
            workbook.Close(true, Missing.Value, Missing.Value);

            app.Visible = false;
            MessageBox.Show("All Selected Results Exported to Excel file and Saved Succesfully");
        }

        private void Excel_Export()
        {
            int Max_Sheet_No = 100;
            string Excel_Path = "C:\\Topple2\\";
            string print_date;


            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\Probabilistic Analysis\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\Probabilistic Analysis\\" + ModelDetail[2] + "\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            print_date = System.Convert.ToString(DateTime.Now.Day) + "_"
                + System.Convert.ToString(DateTime.Now.Month) + "_"
                + System.Convert.ToString(DateTime.Now.Year) + "___"
                + System.Convert.ToString(DateTime.Now.Hour) + "_"
                + System.Convert.ToString(DateTime.Now.Minute) + "_"
                + System.Convert.ToString(DateTime.Now.Second);

            Excel_Path = "C:\\Topple2\\Output Files\\Probabilistic Analysis\\"
                + ModelDetail[2] + "\\" + ModelDetail[2] + "__" + print_date + "\\";
            Directory.CreateDirectory(Excel_Path);

            for (int FileNo = 1; (FileNo - 1) * Max_Sheet_No < All_Model_Details.Count(); FileNo++)
            {
                Excel.Application app = new Excel.Application();
                Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
                Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;
                for (int SheetNo = 1; SheetNo <= Max_Sheet_No && (FileNo - 1) * Max_Sheet_No + SheetNo <= All_Model_Details.Count(); SheetNo++)
                {
                    app.Visible = true;
                    if (SheetNo > 1)
                        worksheet = workbook.Sheets.Add();
                    worksheet = workbook.Sheets["Sheet" + System.Convert.ToString(SheetNo)];
                    worksheet = workbook.ActiveSheet;
                    worksheet.Name = "RUN " + System.Convert.ToString((FileNo - 1) * Max_Sheet_No + SheetNo);

                    Excel.Range range = worksheet.Range["A6:CC6"];

                    worksheet.Cells.Style.HorizontalAlignment = Excel.XlHAlign.xlHAlignCenter;//center horizontaly 
                    worksheet.Cells.Style.VerticalAlignment = Excel.XlVAlign.xlVAlignCenter;//center vertically

                    worksheet.Range[worksheet.Cells[1, 2], worksheet.Cells[1, 3]].Merge();
                    worksheet.Range[worksheet.Cells[2, 2], worksheet.Cells[2, 3]].Merge();
                    worksheet.Range[worksheet.Cells[1, 6], worksheet.Cells[1, 7]].Merge();
                    worksheet.Range[worksheet.Cells[2, 5], worksheet.Cells[2, 7]].Merge();

                    worksheet.Cells[1, 1] = "Date:";
                    worksheet.Cells[1, 2] = System.Convert.ToString(DateTime.Now.Day) + "/" + System.Convert.ToString(DateTime.Now.Month) + "/" + System.Convert.ToString(DateTime.Now.Year);
                    worksheet.Cells[2, 1] = "Time:";
                    worksheet.Cells[2, 2] = System.Convert.ToString(DateTime.Now.Hour) + ":" + System.Convert.ToString(DateTime.Now.Minute) + ":" + System.Convert.ToString(DateTime.Now.Second);
                    worksheet.Cells[1, 5] = "Export by:";
                    worksheet.Cells[1, 6] = "Total Slope";
                    worksheet.Cells[2, 5] = "akbarardestani@ut.ac.ir";


                    worksheet.Range["A4:S4"].Cells.WrapText = true;


                    range = worksheet.Range["A4:S4"];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.CornflowerBlue;

                    range = worksheet.Range["A5:A" + System.Convert.ToString(SliceNo + 4)];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.OrangeRed;

                    range = worksheet.Range["B5:S" + System.Convert.ToString(SliceNo + 4)];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.PaleGoldenrod;


                    worksheet.Cells[4, 1] = "No";
                    worksheet.Cells[4, 2] = "Material \nType";
                    worksheet.Cells[4, 3] = "Slice/Column \nHeight \n(m)";
                    worksheet.Cells[4, 4] = "Slice/Column \nWeight \n(N)";
                    worksheet.Cells[4, 5] = "Slice/Column \nBase Angle \n(Degree)";
                    worksheet.Cells[4, 6] = "Sliding \nforce \n(N)";
                    worksheet.Cells[4, 7] = "Toppling \nForce \n(N)";
                    worksheet.Cells[4, 8] = "Flexural \nToppling \nForce \n(N)";
                    worksheet.Cells[4, 9] = "Shear \nForce \n(N)";
                    worksheet.Cells[4, 10] = "Force \n(N)";
                    worksheet.Cells[4, 11] = "Force \nHeight \n(m)";
                    worksheet.Cells[4, 12] = "Force \nAngle \n(Degree)";
                    worksheet.Cells[4, 13] = "Failure \nMode";
                    worksheet.Cells[4, 14] = "X Bottom \nLeft \nCorner";
                    worksheet.Cells[4, 15] = "Y Bottom \nLeft \nCorner";
                    worksheet.Cells[4, 16] = "X Bottom \nMiddle \nCorner";
                    worksheet.Cells[4, 17] = "X Bottom \nMiddle \nCorner";
                    worksheet.Cells[4, 18] = "X Bottom \nRight \nCorner";
                    worksheet.Cells[4, 19] = "X Bottom \nRight \nCorner";

                    for (int i = 0; i < SliceNo; i++)
                        for (int j = 0; j < 19; j++)
                            worksheet.Cells[5 + i, j + 1] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i][j];

                    worksheet.Range["U4:Z4"].Cells.WrapText = true;

                    range = worksheet.Range["U4:Z4"];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.CornflowerBlue;


                    range = worksheet.Range["U5:Z5"];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.PaleGoldenrod;

                    worksheet.Cells[4, 21] = "Result";
                    worksheet.Cells[4, 22] = "Tension Crack \nDistance \nFrom Toe";
                    worksheet.Cells[4, 23] = "Tension Crack \nDepth";
                    worksheet.Cells[4, 24] = "Tention Crack \nSlice/Column \nNo";
                    worksheet.Cells[4, 25] = "Circular Failure \nPlain Raidus";
                    worksheet.Cells[4, 26] = "Column/Slice \nNo.";

                    worksheet.Cells[5, 21] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][0];
                    worksheet.Cells[5, 22] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][1];
                    worksheet.Cells[5, 23] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][2];
                    worksheet.Cells[5, 24] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][3];
                    worksheet.Cells[5, 25] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][4];
                    worksheet.Cells[5, 26] = Probabilistic_Analysis_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][0][5];



                    range = worksheet.Range["A5:A" + System.Convert.ToString(SliceNo + 4)];
                    var dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["C5:C" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["D5:D" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["E5:E" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["F5:F" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["G5:G" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["H5:H" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["I5:I" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["j5:j" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["K5:k" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    range = worksheet.Range["L5:L" + System.Convert.ToString(SliceNo + 4)];
                    dataBar = range.FormatConditions.AddDatabar();
                    dataBar.BarColor.Color = Color.Red;

                    Excel.Range myCell = (Excel.Range)worksheet.Cells[7, 2];
                    myCell = (Excel.Range)worksheet.Cells[5, 2];
                    myCell.Activate();
                    myCell.Application.ActiveWindow.FreezePanes = true;





                    range = worksheet.Range["A" + System.Convert.ToString(SliceNo + 6) + ":CC" + System.Convert.ToString(SliceNo + 6)];


                    worksheet.Range["A" + System.Convert.ToString(SliceNo + 6) + ":CC" + System.Convert.ToString(SliceNo + 6)].Cells.WrapText = true;

                    range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.CornflowerBlue;


                    worksheet.Cells[SliceNo + 6, 1] = "X \nSlice/Column \nNo";
                    worksheet.Cells[SliceNo + 6, 2] = "X \nTop \nLeft";
                    worksheet.Cells[SliceNo + 6, 3] = "Y \nTop \nLeft";
                    worksheet.Cells[SliceNo + 6, 4] = "X \nTop \nMiddle";
                    worksheet.Cells[SliceNo + 6, 5] = "Y \nTop \nMiddle";
                    worksheet.Cells[SliceNo + 6, 6] = "X \nTop \nRight";
                    worksheet.Cells[SliceNo + 6, 7] = "Y \nTop \nRight";
                    worksheet.Cells[SliceNo + 6, 8] = "X \nBottom \nLeft";
                    worksheet.Cells[SliceNo + 6, 9] = "Y \nBottom \nLeft";
                    worksheet.Cells[SliceNo + 6, 10] = "X \nBottom \nMiddle";
                    worksheet.Cells[SliceNo + 6, 11] = "Y \nBottom \nMiddle";
                    worksheet.Cells[SliceNo + 6, 12] = "X \nBottom \nRight";
                    worksheet.Cells[SliceNo + 6, 13] = "Y \nBottom \nRight";
                    worksheet.Cells[SliceNo + 6, 14] = "X \nWater Level \nRight";
                    worksheet.Cells[SliceNo + 6, 15] = "Y \nWater Level \nRight";
                    worksheet.Cells[SliceNo + 6, 16] = "X \nWater Level \nMiddle";
                    worksheet.Cells[SliceNo + 6, 17] = "Y \nWater Level \nMiddle";
                    worksheet.Cells[SliceNo + 6, 18] = "X \nWater Level \nRight";
                    worksheet.Cells[SliceNo + 6, 19] = "Y \nWater Level \nRight";
                    worksheet.Cells[SliceNo + 6, 20] = "Slice/Column \nRight \nHeight";
                    worksheet.Cells[SliceNo + 6, 21] = "Slice/Column \nMean \nHeight";
                    worksheet.Cells[SliceNo + 6, 22] = "Slice/Column \nLeft \nHeight";
                    worksheet.Cells[SliceNo + 6, 23] = "Water Level \nRight \nHeight";
                    worksheet.Cells[SliceNo + 6, 24] = "Water Level \nMean \nHeight";
                    worksheet.Cells[SliceNo + 6, 25] = "Water Level \nLeft \nHeight";
                    worksheet.Cells[SliceNo + 6, 26] = "Slice/Column \nWeight";
                    worksheet.Cells[SliceNo + 6, 27] = "Slice/Column \nTop Load";
                    worksheet.Cells[SliceNo + 6, 28] = "Slice/Column \nAnchorage \nForce";
                    worksheet.Cells[SliceNo + 6, 29] = "Slice/Column \nAnchorage \nForce Angle";
                    worksheet.Cells[SliceNo + 6, 30] = "Slice/Column \nAnchorage \nYield Force";
                    worksheet.Cells[SliceNo + 6, 31] = "Material \nType";
                    worksheet.Cells[SliceNo + 6, 32] = "Material \nC";
                    worksheet.Cells[SliceNo + 6, 33] = "Material \nC \nDeviation";
                    worksheet.Cells[SliceNo + 6, 34] = "Material \nϕ";
                    worksheet.Cells[SliceNo + 6, 35] = "Material \nϕ \nDeviation";
                    worksheet.Cells[SliceNo + 6, 36] = "Material \nUnit Weight(N)";
                    worksheet.Cells[SliceNo + 6, 37] = "Material \nUnit Weight(N) \nDeviation";
                    worksheet.Cells[SliceNo + 6, 38] = "Material \nɣ";
                    worksheet.Cells[SliceNo + 6, 39] = "Material \nɣ \nDeviation";
                    worksheet.Cells[SliceNo + 6, 39] = "Material \nE";
                    worksheet.Cells[SliceNo + 6, 40] = "Material \nE \nDeviation";
                    worksheet.Cells[SliceNo + 6, 41] = "Material \nν";
                    worksheet.Cells[SliceNo + 6, 42] = "Material \nν \nDeviation";
                    worksheet.Cells[SliceNo + 6, 44] = "Slope \nFace \nAngle";
                    worksheet.Cells[SliceNo + 6, 45] = "Slice/Column \nThickness";
                    worksheet.Cells[SliceNo + 6, 46] = "Slice/Column \nNo";
                    worksheet.Cells[SliceNo + 6, 47] = "Slice/Column \nNo \nDeviation";
                    worksheet.Cells[SliceNo + 6, 48] = "Slice/Column \nNo \nin Slope";
                    worksheet.Cells[SliceNo + 6, 49] = "Slice/Column \nNo \nin All";
                    worksheet.Cells[SliceNo + 6, 50] = "Slope \nNo";
                    worksheet.Cells[SliceNo + 6, 51] = "Slice/Column \nAngle";
                    worksheet.Cells[SliceNo + 6, 52] = "Slice/Column \nAngle \nDeviation";
                    worksheet.Cells[SliceNo + 6, 53] = "Slice/Column \nJoint C";
                    worksheet.Cells[SliceNo + 6, 54] = "Slice/Column \nJoint C \nDeviation";
                    worksheet.Cells[SliceNo + 6, 55] = "Slice/Column \nJoint ϕ";
                    worksheet.Cells[SliceNo + 6, 56] = "Slice/Column \nJoint ϕ \nDeviation";
                    worksheet.Cells[SliceNo + 6, 57] = "Slice/Column \nBasal Angle";
                    worksheet.Cells[SliceNo + 6, 58] = "Slice/Column \nBasal Angle \nDeviation";
                    worksheet.Cells[SliceNo + 6, 59] = "Slice/Column \nBasal Joint C";
                    worksheet.Cells[SliceNo + 6, 60] = "Slice/Column \nBasal Joint C \nDeviation";
                    worksheet.Cells[SliceNo + 6, 61] = "Slice/Column \nBasal Joint ϕ";
                    worksheet.Cells[SliceNo + 6, 62] = "Slice/Column \nBasal Joint ϕ \nDeviation";
                    worksheet.Cells[SliceNo + 6, 63] = "Slope Right \nInteraction C";
                    worksheet.Cells[SliceNo + 6, 64] = "Slope Right \nInteraction C \nDeviation ";
                    worksheet.Cells[SliceNo + 6, 65] = "Slope Right \nInteraction ϕ";
                    worksheet.Cells[SliceNo + 6, 66] = "Slope Right \nInteraction ϕ \nDeviation";
                    worksheet.Cells[SliceNo + 6, 67] = "Blockiness \n%";
                    worksheet.Cells[SliceNo + 6, 68] = "Blockiness \nDeviation";
                    worksheet.Cells[SliceNo + 6, 69] = "Blockiness \nSituation";
                    worksheet.Cells[SliceNo + 6, 70] = "Model \nType";
                    worksheet.Cells[SliceNo + 6, 71] = "Right \nForce";
                    worksheet.Cells[SliceNo + 6, 72] = "Left \nForce";
                    worksheet.Cells[SliceNo + 6, 73] = "Right \nForce \nAngle";
                    worksheet.Cells[SliceNo + 6, 74] = "Left \nForce \nAngle";
                    worksheet.Cells[SliceNo + 6, 75] = "Right \nForce \nHeight";
                    worksheet.Cells[SliceNo + 6, 76] = "Left \nFore \nHeight";
                    worksheet.Cells[SliceNo + 6, 77] = "Sliding \nForce";
                    worksheet.Cells[SliceNo + 6, 78] = "Topling \nForce";
                    worksheet.Cells[SliceNo + 6, 79] = "Flexural \nToppling \nForce";
                    worksheet.Cells[SliceNo + 6, 80] = "Shear \nForce";
                    worksheet.Cells[SliceNo + 6, 81] = "Failure \nmode";


                    range = worksheet.Range["B" + System.Convert.ToString(SliceNo + 7) + ":CC" + System.Convert.ToString(2 * SliceNo + 6)];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.PaleGoldenrod;

                    range = worksheet.Range["A" + System.Convert.ToString(SliceNo + 7) + ":A" + System.Convert.ToString(2 * SliceNo + 6)];
                    range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
                    range.Borders.Weight = 3;
                    range.Interior.Color = Color.OrangeRed;



                    for (int i = 0; i < SliceNo; i++)
                        for (int j = 0; j < 81; j++)
                        {
                            if (j == 0)
                            {
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = SliceNo - i;
                            }
                            else if (j == 30)
                            {
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 1)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 2)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 3)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "BIM";
                            }
                            else if (j == 68)
                            {
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 0)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Flexural";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 1)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Blocky";
                            }
                            else if (j == 69)
                            {
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 1)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 2)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 3)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Rock_Soil";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 4)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Soil_Rock";
                            }
                            else if (j == 80)
                            {
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 0)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Stable";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 1)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Sliding";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 2)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Toppling";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 3)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Flexural Toppling";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 4)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Shear";
                                if (All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1] == 5)
                                    worksheet.Cells[SliceNo + 7 + i, j + 1] = "Unstable";
                            }
                            else
                                worksheet.Cells[SliceNo + 7 + i, j + 1] = All_Model_Details[(FileNo - 1) * Max_Sheet_No + SheetNo - 1][SliceNo - i - 1][j - 1];
                        }

                    range = worksheet.Range["A1:CC" + System.Convert.ToString(2 * SliceNo + 6)];
                    range.Columns.AutoFit();



                }
                workbook.SaveAs(Excel_Path + System.Convert.ToString(FileNo) + "_"
                    + ModelDetail[2] + "__" + print_date
                    + ".xlsx", Missing.Value, Missing.Value
                    , Missing.Value, Missing.Value, Missing.Value, Excel.XlSaveAsAccessMode.xlNoChange
                    , Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value);
                workbook.Close(true, Missing.Value, Missing.Value);

                app.Visible = false;
            }

        }

        private void Btn_Export_Excel_Sensitivity_Analysis_Click(object sender, EventArgs e)
        {
            if (Rad_Btn_Phi_Sensitivity.Checked == true)
                Excel_Sensitivity("Phi", 4, "Material\nPhi", "Main\nJoints\nPhi", "Basal\nJoints\nPhi", "Sequence\nIntersection\nPhi");
            if (Rad_Btn_Phi_Base_Sensitivity.Checked == true)
                Excel_Sensitivity("Basal Phi", 1, "Basal\nPhi", "Basal\nPhi", "Basal\nPhi", "Basal\nPhi");
            if (Rad_Btn_Phi_Mat_Sensitivity.Checked == true)
                Excel_Sensitivity("Material Phi", 1, "Material\nPhi", "Material\nPhi", "Material\nPhi", "Material\nPhi");
            if (Rad_Btn_Phi_int_Sensitivity.Checked == true)
                Excel_Sensitivity("Internal Phi", 2, "Main\nJoints\nPhi", "Sequence\nIntersection\nPhi", "Internal\nPhi", "Internal\nPhi");
            if (Rad_Btn_c_Sensitivity.Checked == true)
                Excel_Sensitivity("c", 4, "Materail\nc", "Main\nJoints\nc", "Basal\nJoints\nc", "Sequence\nIntersection\nc");
            if (Rad_Btn_c_Base_Sensitivity.Checked == true)
                Excel_Sensitivity("Basal c", 1, "Basal c", "Basal c", "Basal c", "Basal c");
            if (Rad_Btn_c_mat_Sensitivity.Checked == true)
                Excel_Sensitivity("Material c", 1, "Material c", "Material c", "Material c", "Material c");
            if (Rad_Btn_c_int_Sensitivity.Checked == true)
                Excel_Sensitivity("Internal c", 2, "Main\nJoints\nc", "Sequence\nIntersection\nc", "Main\nJoints\nc", "Main\nJoints\nc");
            if (Rad_Btn_Tensile_Sensitivity.Checked == true)
                Excel_Sensitivity("Tensile Strength", 1, "Tensile Strength", "Tensile Strength", "Tensile Strength", "Tensile Strength");
            if (Rad_Btn_UntWgt_Sensitivity.Checked == true)
                Excel_Sensitivity("Unit Weight", 1, "Unit Weight", "Unit Weight", "Unit Weight", "Unit Weight");
            if (Rad_Btn_FaceHeight_Sensitivity.Checked == true)
                Excel_Sensitivity("Face Height", 1, "Face Height", "Face Height", "Face Height", "Face Height");
            if (Rad_Btn_kh_Sensitivity.Checked == true)
                Excel_Sensitivity("Kh", 1, "Kh", "Kh", "Kh", "Kh");
            if (Rad_Btn_kv_Sensitivity.Checked == true)
                Excel_Sensitivity("Kv", 1, "Kv", "Kv", "Kv", "Kv");
            if (Rad_Btn_ColumnNo_Sensitivity.Checked == true)
                Excel_Sensitivity("Column No", 1, "Column No", "Column No", "Column No", "Column No");
            if (Rad_Btn_Face_angle_Sensitivity.Checked == true)
                Excel_Sensitivity("Face Angle", 1, "Face Angle", "Face Angle", "Face Angle", "Face Angle");
            if (Rad_Btn_Column_Angle_Sensitivity.Checked == true)
                Excel_Sensitivity("Column Angle", 1, "Column Angle", "Column Angle", "Column Angle", "Column Angle");
            if (Rad_Btn_Say_Base_Angle_Sensitivity.Checked == true)
                Excel_Sensitivity("Basal Angle", 1, "Basal Angle", "Basal Angle", "Basal Angle", "Basal Angle");
        }

        private void Excel_Sensitivity(string Sensitivity_Parameter, int ParNo, string Par1, string Par2, string Par3, string Par4)
        {
            string[] Par_Name = new string[4];
            Par_Name[0] = Par1;
            Par_Name[1] = Par2;
            Par_Name[2] = Par3;
            Par_Name[3] = Par4;
            int D1 = 0, D2 = 0, D3 = 0;
            char ascii = 'A';
            string Sheet_Column = "";
            int Sheet_Column_No = 0;

            string Excel_Path = "C:\\Topple2\\";
            string print_date;
            D1 = Sensitivity_Chart.Count;
            D2 = Sensitivity_Chart[0].Count;
            D3 = Sensitivity_Chart[0][0].Count;

            Sheet_Column_No = D2 * (D3 - 1) + 2;
            while (Sheet_Column_No > 0)
            {
                ascii = System.Convert.ToChar(64 + Sheet_Column_No % 26);
                if (ascii == '@')
                    ascii = 'z';

                Sheet_Column = ascii + Sheet_Column;
                Sheet_Column_No = (Sheet_Column_No - Sheet_Column_No % 26) / 26;
            }

            Excel.Application app = new Excel.Application();
            Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
            Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;

            print_date = System.Convert.ToString(DateTime.Now.Day) + "_"
                + System.Convert.ToString(DateTime.Now.Month) + "_"
                + System.Convert.ToString(DateTime.Now.Year) + "___"
                + System.Convert.ToString(DateTime.Now.Hour) + "_"
                + System.Convert.ToString(DateTime.Now.Minute) + "_"
                + System.Convert.ToString(DateTime.Now.Second);

            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            Excel_Path = "C:\\Topple2\\Output Files\\SenSitivity Analysis\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\SenSitivity Analysis\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\SenSitivity Analysis\\" + ModelDetail[2] + "\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            app.Visible = true;

            worksheet = workbook.Sheets["Sheet" + System.Convert.ToString(1)];
            worksheet = workbook.ActiveSheet;
            worksheet.Name = "Analaysis Results " + System.Convert.ToString(1);

            Excel.Range range = worksheet.Range["A6:" + Sheet_Column + System.Convert.ToString(SequencesNo + 4)];

            worksheet.Cells.Style.HorizontalAlignment = Excel.XlHAlign.xlHAlignCenter;//center horizontaly 
            worksheet.Cells.Style.VerticalAlignment = Excel.XlVAlign.xlVAlignCenter;//center vertically
            worksheet.Range["A4:" + Sheet_Column + "4"].Cells.WrapText = true;

            range = worksheet.Range["A4:" + Sheet_Column + "4"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.CornflowerBlue;

            range = worksheet.Range["C3:" + Sheet_Column + "3"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.GreenYellow;

            range = worksheet.Range["A5:A" + System.Convert.ToString(D1 + 4)];
            range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.OrangeRed;

            range = worksheet.Range["B5:" + Sheet_Column + System.Convert.ToString(D1 + 4)];
            range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.PaleGoldenrod;

            for (int j = 0; j < D2; j++)
            {
                worksheet.Cells[3, j * (D3 - 1) + 3] = "Slope No. " + System.Convert.ToString(j + 1);
                worksheet.Range[worksheet.Cells[3, j * (D3 - 1) + 3], worksheet.Cells[3, j * (D3 - 1) + ParNo + 2]].Merge();
            }


            worksheet.Cells[4, 1] = "Try\nNumber";
            worksheet.Cells[4, 2] = "Force";
            for (int j = 0; j < D2; j++)
            {
                for (int k = 1; k < D3; k++)
                {
                    worksheet.Cells[4, j * (D3 - 1) + k + 2] = Par_Name[(j * (D3 - 1) + k) % 4];
                }
            }

            for (int i = 0; i < D1; i++)
            {
                worksheet.Cells[i + 5, 1] = i + 1;
                worksheet.Cells[i + 5, 2] = Sensitivity_Chart[i][0][0];
                for (int j = 0; j < D2; j++)
                {
                    for (int k = 1; k < D3; k++)
                    {
                        worksheet.Cells[i + 5, j * (D3 - 1) + k + 2] = Sensitivity_Chart[i][j][k];
                    }
                }
            }

            range = worksheet.Range["A1:" + Sheet_Column + System.Convert.ToString(D1 + 6)];
            range.Columns.AutoFit();

            range = worksheet.Range["B5:B" + System.Convert.ToString(D1 + 4)];
            var dataBar = range.FormatConditions.AddDatabar();
            dataBar.BarColor.Color = Color.Red;

            for (int i = 0; i < D2 * (D3 - 1); i++)
            {
                Sheet_Column_No = i + 3;
                Sheet_Column = "";
                while (Sheet_Column_No > 0)
                {
                    ascii = System.Convert.ToChar(64 + Sheet_Column_No % 26);
                    if (ascii == '@')
                        ascii = 'z';
                    Sheet_Column = ascii + Sheet_Column;
                    Sheet_Column_No = (Sheet_Column_No - Sheet_Column_No % 26) / 26;
                }
                range = worksheet.Range[Sheet_Column + "5:" + Sheet_Column + System.Convert.ToString(D1 + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;
            }

            Excel.Range myCell = (Excel.Range)worksheet.Cells[7, 2];
            myCell = (Excel.Range)worksheet.Cells[5, 2];
            myCell.Activate();
            try
            {
            myCell.Application.ActiveWindow.FreezePanes = true;

            }
            catch
            {

            }

            workbook.SaveAs(Excel_Path + "Sensitivity " + Sensitivity_Parameter + " " + ModelDetail[2] + print_date + ".xlsx"
                , Missing.Value, Missing.Value
                , Missing.Value, Missing.Value, Missing.Value, Excel.XlSaveAsAccessMode.xlNoChange
                , Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value);
            workbook.Close(true, Missing.Value, Missing.Value);

            app.Visible = false;
        }

        private void RadBtnKinematicAnalysis_Click(object sender, EventArgs e)
        {
            Pnl_Kinematic.Enabled = true;
            Pnl_KinematicAnalysis.Enabled = true;
            Pnl_Kinematic.Visible = true;
            Pnl_KinematicAnalysis.Visible = true;

            if (SequenceList != null)
                Draw_Model();

            double draw_angle = 0;

            int margin = 20;
            int X_StrioCenter = 0, Y_StrioCenter = 0, StrioRadius = 0, k = 0;
            double X_Strio = 0, Y_Strio = 0, Z_Strio = 0;
            double MinSlipLimit = 90;
            string[,] StrioCommenet = new string[2 * SequencesNo + 6, 3];
            int CommentNo = 2 * SequencesNo + 5;//Number of comment that must Be print on strionet
            Point[] crv = new Point[37];
            Point[] crv2 = new Point[19];
            Point[] hash = new Point[3];
            Font drawFont = new Font("Arial", 7);

            drawFont = new Font("Arial", 12, FontStyle.Bold);

            X_StrioCenter = Pnl_KinematicAnalysis.Size.Width / 2;
            Y_StrioCenter = Pnl_KinematicAnalysis.Size.Height / 2;

            if (X_StrioCenter >= Y_StrioCenter)
                StrioRadius = Y_StrioCenter - margin;
            else
                StrioRadius = X_StrioCenter - margin;


            Pnl_KinematicAnalysis.Refresh();

            using (Graphics g = Pnl_KinematicAnalysis.CreateGraphics())//draw Model in it's panel
            {
                g.FillEllipse(Brushes.Green,//legend
                5,
                2 * Y_StrioCenter - 65,
                20,
                20);
                g.DrawString("Kinematically Stable faces", drawFont, Brushes.Black, 25, 2 * Y_StrioCenter - 60);
                g.FillEllipse(Brushes.Red,//legend
                5,
                2 * Y_StrioCenter - 35,
                20,
                20);
                g.DrawString("Kinematically Unstable faces", drawFont, Brushes.Black, 25, 2 * Y_StrioCenter - 30);


                g.TranslateTransform(X_StrioCenter, Y_StrioCenter); // to Move center of coordination System
                g.FillEllipse(Brushes.White, -StrioRadius, -StrioRadius, 2 * StrioRadius, 2 * StrioRadius);

                for (int Seq_Counter = 1; Seq_Counter <= SequencesNo; Seq_Counter++)// to find maximum no of critical zoon that must Be hashed
                    if (SequenceList[Seq_Counter - 1, 6] == "Rock" // count slopes that is rucky and can Be unstable kinematicaly
                        && (90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) < MinSlipLimit)
                        MinSlipLimit = (90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29]));

                for (double i = MinSlipLimit; i < 90; i += 0.5)//hash critical zone for toppling failure
                {

                    X_Strio = Math.Sin(i * Math.PI / 180);
                    Y_Strio = Math.Sin(10 * Math.PI / 180);
                    Z_Strio = Math.Cos(i * Math.PI / 180);
                    hash[1].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                        * X_Strio / (1 + Z_Strio));
                    hash[1].Y = 0;

                    X_Strio = (Math.Cos(10 * Math.PI / 180) * Math.Sin(i * Math.PI / 180));
                    Y_Strio = (Math.Sin(10 * Math.PI / 180));
                    Z_Strio = (Math.Cos(10 * Math.PI / 180) * Math.Cos(i * Math.PI / 180));
                    hash[0].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                        * X_Strio / (1 + Z_Strio));
                    hash[0].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                        * Y_Strio / (1 + Z_Strio));

                    hash[2].X = hash[0].X;
                    hash[2].Y = -hash[0].Y;
                    Pen StrioPen = new Pen(Color.FromArgb(255, 199, 21, 112), 5);// thick pen for drawing anchors
                    g.DrawCurve(StrioPen, hash);
                    if (i == MinSlipLimit)//create comment for critical zone
                    {
                        StrioCommenet[1, 0] = "Critical Zone";
                        StrioCommenet[1, 1] = System.Convert.ToString(hash[2].X - 40);//X of comment
                        StrioCommenet[1, 2] = System.Convert.ToString(hash[2].Y - 25);//Y of comment
                    }
                }
                k = 6 + SequencesNo;
                StrioCommenet[0, 0] = "0";
                StrioCommenet[0, 1] = "+";
                for (int Seq_Counter = 1; Seq_Counter <= SequencesNo; Seq_Counter++)//critical bound for toppling failure of each slope
                {
                    if (SequenceList[Seq_Counter - 1, 6] == "Rock" && (90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) <= 90)
                    {
                        X_Strio = Math.Sin((90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) * Math.PI / 180);
                        Y_Strio = Math.Sin(10 * Math.PI / 180);
                        Z_Strio = Math.Cos((90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) * Math.PI / 180);
                        hash[1].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * X_Strio / (1 + Z_Strio));
                        hash[1].Y = 0;

                        X_Strio = (Math.Cos(10 * Math.PI / 180) * Math.Sin((90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) * Math.PI / 180));
                        Y_Strio = (Math.Sin(10 * Math.PI / 180));
                        Z_Strio = (Math.Cos(10 * Math.PI / 180) * Math.Cos((90d - System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_Counter - 1, 29])) * Math.PI / 180));
                        hash[0].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * X_Strio / (1 + Z_Strio));
                        hash[0].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * Y_Strio / (1 + Z_Strio));

                        hash[2].X = hash[0].X;
                        hash[2].Y = -hash[0].Y;
                        Pen StrioPen = new Pen(Color.FromArgb(255, 0, 0, 0), 2);// thick pen 

                        g.DrawCurve(StrioPen, hash);

                        StrioCommenet[k, 0] = "Slip limit " + System.Convert.ToString(Seq_Counter);
                        StrioCommenet[k, 1] = System.Convert.ToString(hash[2].X - 65);//X of comment
                        if (StrioCommenet[0, 1] == "+")//trasing comments in multiple lines
                        {
                            if (System.Convert.ToInt32(StrioCommenet[0, 0]) + 10 < hash[0].Y)
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) + 10);
                            else
                            {
                                StrioCommenet[0, 1] = "-";
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) - 10);
                            }
                        }
                        else
                        {
                            if (System.Convert.ToInt32(StrioCommenet[0, 0]) - 5 > hash[2].Y)
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) - 10);
                            else
                            {
                                StrioCommenet[0, 1] = "+";
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) + 10);
                            }
                        }
                        StrioCommenet[k, 2] = StrioCommenet[0, 0];//Y of comment
                        k++;
                    }
                    else
                        CommentNo--;
                }


                //draw strio net
                for (int i = 0; i < 10; i++)//longitude
                {
                    for (int j = 0; j < 10; j++)//latitude
                    {
                        X_Strio = (Math.Cos(10 * j * Math.PI / 180) * Math.Sin(10 * i * Math.PI / 180));
                        Y_Strio = (Math.Sin(10 * j * Math.PI / 180));
                        Z_Strio = (Math.Cos(10 * j * Math.PI / 180) * Math.Cos(10 * i * Math.PI / 180));

                        crv[9 - j].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * X_Strio / (1 + Z_Strio));
                        crv[9 - j].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * Y_Strio / (1 + Z_Strio));

                        crv[9 + j].X = crv[9 - j].X;
                        crv[9 + j].Y = -crv[9 - j].Y;

                        crv[27 + j].X = -crv[9 - j].X;
                        crv[27 + j].Y = crv[9 - j].Y;

                        crv[27 - j].X = -crv[9 - j].X;
                        crv[27 - j].Y = -crv[9 - j].Y;

                    }

                    g.DrawCurve(Pens.DarkGray, crv);
                }
                //draw strionet
                for (int i = 0; i < 10; i++)//latitude
                {
                    for (int j = 0; j < 10; j++)//longitude
                    {
                        X_Strio = (Math.Cos(10 * i * Math.PI / 180) * Math.Sin(10 * j * Math.PI / 180));
                        Y_Strio = (Math.Sin(10 * i * Math.PI / 180));
                        Z_Strio = (Math.Cos(10 * i * Math.PI / 180) * Math.Cos(10 * j * Math.PI / 180));

                        crv2[9 + j].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * X_Strio / (1 + Z_Strio));
                        crv2[9 + j].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                            * Y_Strio / (1 + Z_Strio));

                        crv2[9 - j].X = -crv2[9 + j].X;
                        crv2[9 - j].Y = crv2[9 + j].Y;

                    }
                    Pen StrioPen = new Pen(Color.FromArgb(255, 0, 0, 128), 2);// thick pen
                    if (i == 1)
                    {
                        g.DrawCurve(StrioPen, crv2);//dip direction restriction
                        StrioCommenet[3, 0] = "Dip Direction Restriction";
                        StrioCommenet[3, 1] = System.Convert.ToString(crv2[9].X - 95);//X of comment
                        StrioCommenet[3, 2] = System.Convert.ToString(crv2[9].Y + 5);//Y of comment
                    }
                    else
                        g.DrawCurve(Pens.DarkGray, crv2);
                    for (int j = 0; j < 19; j++)
                    {
                        crv2[j].Y = -crv2[j].Y;
                    }
                    if (i == 1)
                    {
                        g.DrawCurve(StrioPen, crv2);//dip direction restriction
                        StrioCommenet[4, 0] = "Dip Direction Restriction";
                        StrioCommenet[4, 1] = System.Convert.ToString(crv2[9].X - 95);//X of comment
                        StrioCommenet[4, 2] = System.Convert.ToString(crv2[9].Y - 20);//Y of comment
                    }
                    else
                        g.DrawCurve(Pens.DarkGray, crv2);
                }
                g.FillEllipse(Brushes.Black, -2, -2, 4, 4);//center point


                for (int i = 0; i < 10; i++)//toe
                {
                    X_Strio = 0;
                    Y_Strio = (Math.Sin(10 * i * Math.PI / 180));
                    Z_Strio = (Math.Cos(10 * i * Math.PI / 180));
                    crv2[9 - i].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                                    * X_Strio / (1 + Z_Strio));
                    crv2[9 - i].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                                    * Y_Strio / (1 + Z_Strio));

                    crv2[9 + i].X = crv2[9 - i].X;
                    crv2[9 + i].Y = -crv2[9 - i].Y;
                }
                g.DrawCurve(Pens.Black, crv2);
                StrioCommenet[2, 0] = "Toe";
                StrioCommenet[2, 1] = System.Convert.ToString(0);//X of comment
                StrioCommenet[2, 2] = System.Convert.ToString(-10);//Y of comment

                k = 6;
                StrioCommenet[0, 0] = "3";
                StrioCommenet[0, 1] = "+";
                for (int Seq_counter = 1; Seq_counter <= SequencesNo; Seq_counter++)//draw each face angle curve
                {
                    if (SequenceList[Seq_counter - 1, 6] == "Rock")
                    {
                        draw_angle = 90d - System.Convert.ToDouble(SequenceList[Seq_counter - 1, 19]);
                        if (draw_angle > 90)
                            draw_angle -= 180;

                        for (int i = 0; i < 10; i++)//each face
                        {
                            X_Strio = (Math.Cos(10 * i * Math.PI / 180) * Math.Sin(draw_angle * Math.PI / 180));
                            Y_Strio = (Math.Sin(10 * i * Math.PI / 180));
                            Z_Strio = (Math.Cos(10 * i * Math.PI / 180) * Math.Cos(draw_angle * Math.PI / 180));
                            crv2[9 - i].X = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                                            * X_Strio / (1 + Z_Strio));
                            crv2[9 - i].Y = System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius)
                                            * Y_Strio / (1 + Z_Strio));

                            crv2[9 + i].X = crv2[9 - i].X;
                            crv2[9 + i].Y = -crv2[9 - i].Y;
                        }

                        if ((90d - System.Convert.ToDouble(SequenceList[Seq_counter - 1, 19]) + System.Convert.ToDouble(SequenceList[Seq_counter - 1, 29])) < System.Convert.ToDouble(SequenceList[0, 23]))
                        {
                            Pen StrioPen = new Pen(Color.FromArgb(255, 255, 0, 0), 2);// thick pen for drawing anchors
                            g.DrawCurve(StrioPen, crv2);
                        }
                        else
                        {
                            Pen StrioPen = new Pen(Color.FromArgb(255, 50, 205, 0), 2);// thick pen for drawing anchors
                            g.DrawCurve(StrioPen, crv2);
                        }


                        StrioCommenet[k, 0] = "Slope face " + System.Convert.ToString(Seq_counter);

                        if (StrioCommenet[0, 1] == "+")//trasing comments in multiple lines
                        {
                            if (System.Convert.ToInt32(StrioCommenet[0, 0]) + 1 <= 7
                                || (System.Convert.ToInt32(StrioCommenet[0, 0]) + 1 >= 11
                                && System.Convert.ToInt32(StrioCommenet[0, 0]) + 1 <= 14))
                            {
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) + 1);
                            }
                            else if (StrioCommenet[0, 0] == "7")
                            {
                                StrioCommenet[0, 0] = "11";
                            }
                            else if (StrioCommenet[0, 0] == "14")
                            {
                                StrioCommenet[0, 1] = "-";
                                StrioCommenet[0, 0] = "13";
                            }
                        }
                        else
                        {
                            if (System.Convert.ToInt32(StrioCommenet[0, 0]) - 1 >= 11
                                || (System.Convert.ToInt32(StrioCommenet[0, 0]) - 1 <= 7
                                && System.Convert.ToInt32(StrioCommenet[0, 0]) - 1 <= 4))
                            {
                                StrioCommenet[0, 0] = System.Convert.ToString(System.Convert.ToInt32(StrioCommenet[0, 0]) - 1);
                            }
                            else if (StrioCommenet[0, 0] == "11")
                            {
                                StrioCommenet[0, 0] = "7";
                            }
                            else if (StrioCommenet[0, 0] == "4")
                            {
                                StrioCommenet[0, 1] = "+";
                                StrioCommenet[0, 0] = "5";
                            }
                        }
                        StrioCommenet[k, 1] = System.Convert.ToString(crv2[System.Convert.ToInt32(StrioCommenet[0, 0])].X - 40);//X of comment
                        StrioCommenet[k, 2] = System.Convert.ToString(crv2[System.Convert.ToInt32(StrioCommenet[0, 0])].Y - 5);//X of comment

                        k++;
                    }
                }

                for (int Seq_counter = 1; Seq_counter <= SequencesNo; Seq_counter++)//Chech if there is Rocky slope to draw its column pole
                    if (SequenceList[Seq_counter - 1, 6] == "Rock")
                    {
                        X_Strio = Math.Sin((System.Convert.ToDouble(SequenceList[0, 23])) * Math.PI / 180);
                        Y_Strio = 0;
                        Z_Strio = Math.Cos((System.Convert.ToDouble(SequenceList[0, 23])) * Math.PI / 180);

                        g.FillEllipse(Brushes.Yellow,//column pole
                            System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius) * X_Strio / (1 + Z_Strio)) - 5,
                            -5,
                            10,
                            10);
                        StrioCommenet[5, 0] = "Column Pole";
                        StrioCommenet[5, 1] = System.Convert.ToString(System.Convert.ToInt16(System.Convert.ToDouble(StrioRadius) * X_Strio / (1 + Z_Strio)) - 50);//X of comment
                        StrioCommenet[5, 2] = System.Convert.ToString(-20);//Y of comment
                        Seq_counter = SequencesNo + 10;//exit from loop
                    }

                for (int i = 0; i < CommentNo; i++)
                    g.DrawString(StrioCommenet[i + 1, 0], drawFont, Brushes.Black, System.Convert.ToInt16(StrioCommenet[i + 1, 1]), System.Convert.ToInt16(StrioCommenet[i + 1, 2]));
            }
        }

        private void Btn_Autocad_Export_Click(object sender, EventArgs e)
        {
            // Getting running AutoCAD instance by Marshalling by passing Programmatic ID as a string, AutoCAD.Application is the Programmatic ID for AutoCAD.
            try
            {
                AcadApp = (AcadApplication)Marshal.GetActiveObject("AutoCAD.Application");

                //            double[] CenterOfCircle = new double[3];
                double[] CADPolyLinePoints = new double[3 * (5 + 2 * SliceNo)];
                double[] CAD_Start_Line = new double[3];
                double[] CAD_End_Line = new double[3];

                for (int i = 0; i < SliceNo; i++)
                {
                    CAD_Start_Line[0] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 0];
                    CAD_Start_Line[1] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 1];
                    CAD_Start_Line[2] = 0;
                    CAD_End_Line[0] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 4];
                    CAD_End_Line[1] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 5];
                    CAD_End_Line[2] = 0;
                    CADLine = AcadApp.ActiveDocument.ModelSpace.AddLine(CAD_Start_Line, CAD_End_Line);
                    CAD_Start_Line[0] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 10];
                    CAD_Start_Line[1] = Sorted_All_Model_Details[System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value), i, 11];
                    CAD_Start_Line[2] = 0;
                    CADLine = AcadApp.ActiveDocument.ModelSpace.AddLine(CAD_End_Line, CAD_Start_Line);
                }
            }
            catch
            {
                MessageBox.Show("Please Open New Blank Autocad File First");
            }
            /*            CADPolyLinePoints[0] = 0;
                        CADPolyLinePoints[1] = 0;
                        CADPolyLinePoints[2] = 0;

                        CADPolyLinePoints[3] = 0;
                        CADPolyLinePoints[4] = 0.7 * System.Convert.ToDouble(NumUpDwnHeight.Value);
                        CADPolyLinePoints[5] = 0;

                        CADPolyLinePoints[6] = System.Convert.ToDouble(NumUpDwnHeight.Value);
                        CADPolyLinePoints[7] = System.Convert.ToDouble(NumUpDwnHeight.Value) * (0.7
                                                + Math.Tan(System.Convert.ToDouble(NumUpDwnLowrFacAng.Value) * Math.PI / 180));
                        CADPolyLinePoints[8] = 0;


                        CADPolyLinePoints[9] = System.Convert.ToDouble(NumUpDwnHeight.Value) * (1d + 1d / Math.Tan(System.Convert.ToDouble(NumUpDwnFaceAngl.Value) * Math.PI / 180));
                        CADPolyLinePoints[10] = System.Convert.ToDouble(NumUpDwnHeight.Value) * (1.7 + Math.Tan(System.Convert.ToDouble(NumUpDwnLowrFacAng.Value) * Math.PI / 180));
                        CADPolyLinePoints[11] = 0;

                        CADPolyLinePoints[12] = System.Convert.ToDouble(NumUpDwnHeight.Value) * (2.3d + 1d / Math.Tan(System.Convert.ToDouble(NumUpDwnFaceAngl.Value) * Math.PI / 180));
                        CADPolyLinePoints[13] = System.Convert.ToDouble(NumUpDwnHeight.Value) * (1.7
                                                + Math.Tan(System.Convert.ToDouble(NumUpDwnLowrFacAng.Value) * Math.PI / 180)
                                                + 1.3 * Math.Tan(System.Convert.ToDouble(NumUpDwnUperfaceangl.Value) * Math.PI / 180));
                        CADPolyLinePoints[14] = 0;

                        CADPolyLinePoints[15] = System.Convert.ToDouble(NumUpDwnHeight.Value)
                                                * (2.3d + 1d / Math.Tan(System.Convert.ToDouble(NumUpDwnFaceAngl.Value) * Math.PI / 180));
                        CADPolyLinePoints[16] = 0;
                        CADPolyLinePoints[17] = 0;

                        CADPolyLinePoints[18] = 0;
                        CADPolyLinePoints[19] = 0;
                        CADPolyLinePoints[20] = 0;

            */


            //            CADPolyline = AcadApp.ActiveDocument.ModelSpace.AddPolyline(CADPolyLinePoints);
            /*
                                    for (int i = 0; i < EchBlkPar[MaxBlockNoNeed, 0]; i++)
                                    {
                                        CenterOfCircle[0] = System.Convert.ToInt32(EchBlkPar[i, 4] % XmeshNo);
                                        CenterOfCircle[1] = System.Convert.ToInt32((EchBlkPar[i, 4] - CenterOfCircle[0]) / XmeshNo) + 1;
                                        if (CenterOfCircle[0] == 0)
                                        {
                                            CenterOfCircle[0] = XmeshNo;
                                            CenterOfCircle[1]--;
                                        }
                                        CenterOfCircle[0] = (CenterOfCircle[0] - 0.5d) * System.Convert.ToDouble(NumUpDwnHeight.Value) / meshresolution;
                                        CenterOfCircle[1] = (CenterOfCircle[1] - 0.5d) * System.Convert.ToDouble(NumUpDwnHeight.Value) / meshresolution;
                                        CenterOfCircle[2] = 0;

                                        // Adding Circle to the modelspace and getting reference to the circle created.
                                        CADCircle = AcadApp.ActiveDocument.ModelSpace.AddCircle(CenterOfCircle, EchBlkPar[i, 1] / 2d);

                                    }
                        */
        }

        private List<List<double>> Save_Table_All_Model_Detai()
        {
            List<List<double>> Model_Detail_Table_List = new List<List<double>>();
            Model_Detail_Table_List.Clear();
            for (int RowNo = 0; RowNo < SliceNo; RowNo++)
                Model_Detail_Table_List.Add(Save_Column_All_Model_Detai(RowNo));
            return Model_Detail_Table_List;
        }

        private List<double> Save_Column_All_Model_Detai(int RowNo)
        {
            List<double> Model_Detail_Column_List = new List<double>();
            Model_Detail_Column_List.Clear();
            if (RowNo == -1)
            {
                Model_Detail_Column_List.Add(System.Convert.ToDouble(ModelDetail[3]));//Kh
                Model_Detail_Column_List.Add(System.Convert.ToDouble(ModelDetail[5]));//Kv
            }
            else
            {
                for (int ClmNo = 0; ClmNo < 80; ClmNo++)
                    Model_Detail_Column_List.Add(Analytical_Slice_Data[RowNo, ClmNo]);
            }
            return Model_Detail_Column_List;
        }

        private void Btn_Export_Excel_Probability_Sability_Click(object sender, EventArgs e)
        {
            Excel_Export();
        }

        private void Solve_For_FOS3()
        {
            Total_Analytical_Critical_Situation_List.Clear();//Reset critical situation
            if (Sorted_Critical_Situation_Charts != null)
                Array.Clear(Sorted_Critical_Situation_Charts, 0, Sorted_Critical_Situation_Charts.Length);//clear previous data
            if (Sorted_All_Model_Details != null)
                Array.Clear(Sorted_All_Model_Details, 0, Sorted_All_Model_Details.Length);//clear previous data
            All_Model_Details.Clear();//reset saved details of models that have at least one column or slice unstable
            All_Arcs_List.Clear();

            Analytical_Calculation_General_Preparation();//find top coordination of all slices and columns and save all other definition detail of each
            Analytical_Solve();//find bottom of each column or slice and solve the model
                               //1            EXCEL_SequenceList_ModelDetail();
        }

        private void Chk_Bx_Stepped_CheckedChanged(object sender, EventArgs e)
        {
            if (Chk_Bx_Stepped.Checked == true)
                SteppedSurface = true;
            else
                SteppedSurface = false;
        }

        private void Rad_Btn_Start_Click(object sender, EventArgs e)
        {
            string ErrorTXT = "";

            if (Rad_Btn_Phi.Checked == false &&
                Rad_Btn_Phi_B.Checked == false &&
                Rad_Btn_Phi_Mat.Checked == false &&
                Rad_Btn_Phi_Int.Checked == false &&
                Rad_Btn_Tensile.Checked == false &&
                Rad_Btn_C.Checked == false &&
                Rad_Btn_C_B.Checked == false &&
                Rad_Btn_C_Mat.Checked == false &&
                Rad_Btn_C_Int.Checked == false &&
                Rad_Btn_Unit_Weight.Checked == false &&
                Rad_Btn_Kh.Checked == false &&
                Rad_Btn_Kv.Checked == false &&
                Rad_Btn_Kh_Kv.Checked == false &&
                Rad_Btn_ColumnNo.Checked == false &&
                Rad_Btn_Face_Height.Checked == false &&
                Rad_Btn_Say_Face.Checked == false &&
                Rad_Btn_Column_Angle.Checked == false &&
                Rad_Btn_Say_Base.Checked == false &&
                Rad_Btn_Shear.Checked == false &&
                Rad_Btn_Reserve.Checked == false &&
                Rad_Btn_Buckling.Checked == false &&
                Rad_Btn_III.Checked == false)
            {
                ErrorTXT += "\n One of Determinidtic FOS Calculation Ways Should Be Selected";
                Rad_Btn_End.Checked = true;
            }
            else
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];



                Excel_sheetNo = 0;
                Excel_Work = false;
                Rad_Btn_Start.Text = "Deterministic FOS Analysis is Running";
                Rad_Btn_Start.Refresh();
                Pnl_Probabilistic.Enabled = false;
                Pnl_Sensitivity.Enabled = false;
                Pnl_MainMenu.Enabled = false;

                Lbl_ElpsTime.Visible = false;

                DGVProbabilisticResult.Visible = false;

                Solve_For_FOS3();



                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }



                Exact_Surfase = true;


                Deterministic_FOS_Calculation();
                ExtractDataFromDataBase();
                Rad_Btn_Start.Text = "START Deterministic FOS Analysis";
                Rad_Btn_Start.Refresh();
                Pnl_Probabilistic.Enabled = true;
                Pnl_Sensitivity.Enabled = true;
                Pnl_MainMenu.Enabled = true;

            }
            if (ErrorTXT != "")
            {
                MessageBox.Show(ErrorTXT);
            }

            Exact_Surfase = false;

        }

        private void Deterministic_FOS_Calculation()
        {
            if (Rad_Btn_Start.Checked == true)
                FOS_List.Clear();
            FOS_Value = 1;

            if (Rad_Btn_Phi.Checked == true)
                Find_Critical_Phi();

            if (Rad_Btn_Phi_B.Checked == true)
                Find_Critical_Phi_Basal();

            if (Rad_Btn_Phi_Mat.Checked == true)
                Find_Critical_Phi_Material();

            if (Rad_Btn_Phi_Int.Checked == true)
                Find_Critical_Phi_Internal();

            if (Rad_Btn_C.Checked == true)
                Find_Critical_C();

            if (Rad_Btn_C_B.Checked == true)
                Find_Critical_C_Basal();

            if (Rad_Btn_C_Mat.Checked == true)
                Find_Critical_C_Material();

            if (Rad_Btn_C_Int.Checked == true)
                Find_Critical_C_Internal();

            if (Rad_Btn_Say_Base.Checked == true)
                Find_Critical_Say_Base();

            if (Rad_Btn_Tensile.Checked == true)
                Find_Critical_Tensile();//in rock column

            if (Rad_Btn_Say_Face.Checked == true)
                Find_Critical_Say_Face();

            if (Rad_Btn_Face_Height.Checked == true)
                Find_Critical_Slope_Height();

            if (Rad_Btn_Unit_Weight.Checked == true)
                Find_Critical_Unit_Weight();

            if (Rad_Btn_Column_Angle.Checked == true)
                Find_Critical_Say_Column();

            if (Rad_Btn_ColumnNo.Checked == true)
                Find_Critical_ColumnNo();

            if (Rad_Btn_Kh.Checked == true)
                Find_Critical_Kh();

            if (Rad_Btn_Kv.Checked == true)
                Find_Critical_Kv();

            if (Rad_Btn_Kh_Kv.Checked == true)
                Find_Critical_Kh_Kv();

            if (Rad_Btn_Shear.Checked == true)
                Find_Critical_Shear();

            if (Rad_Btn_Buckling.Checked == true)
            {
                if(ChkBx_Animation.Checked==false)
                    Find_Critical_Buckling();
                else
                    Find_Critical_Buckling_ByAnimation();
            }

            if (Rad_Btn_III.Checked == true)
            {
                if (ChkBx_Animation.Checked == false)
                    Find_Critical_III();
                else
                  Find_Critical_III_ByAnimation();
            }

            if (Rad_Btn_Start.Checked == true)
                Rad_Btn_End.Checked = true;
            Exact_Surfase = false;

        }

        private void Draw_FOS_Calculation_Path()
        {
            Pnl_ProbabilisticDeterminidtic_Chart.Refresh();
            int X_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Height;//the height of drawing area
            int X_margine = 10;
            int Y_margine = 10;

            double Model_Height = 0;//Height of model befor Scaling
            double Model_Width = 0;//Width of model befor Scaling

            double X_Scale = 1;
            double Y_Scale = 1;

            double M_c_p = 0, M_c = 0, X_A = 0, X_B = 0, Y_A = 0, Y_B = 0;

            for (int i = 1; i <= SequencesNo; i++)// calculate Model Size 
            {
                Model_Height += System.Convert.ToDouble(Origin_SequenceList[i - 1, 20]);
                Model_Width += System.Convert.ToDouble(Origin_SequenceList[i - 1, 20])
                    / Math.Tan(System.Convert.ToDouble(Origin_SequenceList[i - 1, 19]) * Math.PI / 180d);
            }
            Model_Height += 0.5 * System.Convert.ToDouble(Origin_SequenceList[SequencesNo - 1, 20]);//top Extra Domain for model
            Model_Height *= 1.2;//Down Extra domain for model
            Model_Width += 0.5 * System.Convert.ToDouble(Origin_SequenceList[SequencesNo - 1, 20])
                / Math.Tan(System.Convert.ToDouble(Origin_SequenceList[SequencesNo - 1, 19]) * Math.PI / 180d);//Right Extra domain for model
            Model_Width *= 1.2;//Left Extra domain for model

            X_Scale = (X_DrawWindow - 2 * X_margine) / Model_Width;
            Y_Scale = (Y_DrawWindow - 2 * Y_margine) / Model_Height;

            if (X_Scale > Y_Scale)
                DrawingScale = Y_Scale;
            else
                DrawingScale = X_Scale;

            Model_Points = new Point[5];

            All_Slope_Points = new double[SequencesNo + 2, 10];

            //bottom Left
            All_Slope_Points[0, 0] = 0;
            All_Slope_Points[0, 1] = 0;
            //top left
            All_Slope_Points[0, 2] = 0;
            All_Slope_Points[0, 3] = -DrawingScale * Model_Height / 6d;
            //top right
            All_Slope_Points[0, 4] = DrawingScale * Model_Width / 6d;
            All_Slope_Points[0, 5] = -DrawingScale * Model_Height / 6d;
            //bottom right
            All_Slope_Points[0, 6] = All_Slope_Points[0, 4] - All_Slope_Points[0, 3]
                / Math.Tan(System.Convert.ToDouble(SequenceList[0, 23]) * Math.PI / 180d);
            All_Slope_Points[0, 7] = 0;

            if (All_Slope_Points[0, 6] > DrawingScale * (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
            {
                All_Slope_Points[0, 7] = -(All_Slope_Points[0, 6] - (X_DrawWindow - 2 * X_margine))
                    * Math.Tan(System.Convert.ToDouble(SequenceList[0, 23]) * Math.PI / 180d);
                All_Slope_Points[0, 6] = All_Slope_Points[0, 6] - (X_DrawWindow - 2 * X_margine);
            }
            //5th point
            All_Slope_Points[0, 8] = All_Slope_Points[0, 6];
            All_Slope_Points[0, 9] = All_Slope_Points[0, 1];


            Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[0, 0]);
            Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[0, 1]);

            Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[0, 2]);
            Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[0, 3]);

            Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[0, 4]);
            Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[0, 5]);

            Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[0, 6]);
            Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[0, 7]);

            Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[0, 8]);
            Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[0, 9]);





            using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                g.FillPolygon(Brushes.Sienna, Model_Points);//draw Toe
            }// model toe drew
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            for (int i = 1; i <= SequencesNo; i++)//draw Slopes one by one
            {
                //0 bottom Left
                All_Slope_Points[i, 0] = All_Slope_Points[i - 1, 6];
                All_Slope_Points[i, 1] = All_Slope_Points[i - 1, 7];
                //1 top left
                All_Slope_Points[i, 2] = All_Slope_Points[i - 1, 4];
                All_Slope_Points[i, 3] = All_Slope_Points[i - 1, 5];
                //2 top right
                All_Slope_Points[i, 4] = All_Slope_Points[i, 2] + DrawingScale
                    * System.Convert.ToDouble(SequenceList[i - 1, 20]) / Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 19]) * Math.PI / 180d);
                All_Slope_Points[i, 5] = All_Slope_Points[i, 3] - DrawingScale * System.Convert.ToDouble(SequenceList[i - 1, 20]);

                //3 bottom right
                All_Slope_Points[i, 6] = All_Slope_Points[i, 4] + (All_Slope_Points[i, 1] - All_Slope_Points[i, 5])
                    / Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                All_Slope_Points[i, 7] = All_Slope_Points[i, 1];

                if (i < SequencesNo)
                    if (SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")// at intersection od Rock and soil in Soil_Rock Model
                    {
                        All_Slope_Points[i, 6] = All_Slope_Points[i, 4] + (All_Slope_Points[i, 1] - All_Slope_Points[i, 5])
                            / Math.Tan(System.Convert.ToDouble(SequenceList[i, 23]) * Math.PI / 180d);
                    }

                if (All_Slope_Points[i, 6] > (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
                {
                    All_Slope_Points[i, 7] = -(All_Slope_Points[i, 6] - (X_DrawWindow - 2 * X_margine))
                        * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                    All_Slope_Points[i, 6] = (X_DrawWindow - 2 * X_margine);
                }
                //5th point

                All_Slope_Points[i, 8] = All_Slope_Points[i, 6];
                All_Slope_Points[i, 9] = All_Slope_Points[i, 1];

                Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);

                Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[i, 2]);
                Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[i, 3]);

                Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[i, 4]);
                Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[i, 5]);

                Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);

                Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[i, 8]);
                Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[i, 9]);


                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                                                                               //                    if (SequenceList[i - 1, 6] == "Rock")
                                                                               //                        g.FillPolygon(Brushes.LightGray, Model_Points);//draw Slope
                    if (SequenceList[i - 1, 6] == "Soil")
                        g.FillPolygon(Brushes.Bisque, Model_Points);//draw Slope
                    if (SequenceList[i - 1, 6] == "BIM")
                        g.FillPolygon(Brushes.LightGreen, Model_Points);//draw Slope
                }// this slope drew

            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //0 bottom Left
            All_Slope_Points[SequencesNo + 1, 0] = All_Slope_Points[SequencesNo, 6];
            All_Slope_Points[SequencesNo + 1, 1] = All_Slope_Points[SequencesNo, 7];
            //1 top left
            All_Slope_Points[SequencesNo + 1, 2] = All_Slope_Points[SequencesNo, 4];
            All_Slope_Points[SequencesNo + 1, 3] = All_Slope_Points[SequencesNo, 5];
            //2 top right
            All_Slope_Points[SequencesNo + 1, 4] = All_Slope_Points[SequencesNo + 1, 2] + 0.5
                * DrawingScale * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20])
                / Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 19]) * Math.PI / 180d);
            All_Slope_Points[SequencesNo + 1, 5] = All_Slope_Points[SequencesNo + 1, 3] - 0.5
                * DrawingScale * System.Convert.ToDouble(SequenceList[SequencesNo - 1, 20]);
            //3 bottom right
            All_Slope_Points[SequencesNo + 1, 6] = All_Slope_Points[SequencesNo + 1, 4]
                + (All_Slope_Points[SequencesNo + 1, 1] - All_Slope_Points[SequencesNo + 1, 5])
                / Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 23]) * Math.PI / 180d);
            All_Slope_Points[SequencesNo + 1, 7] = All_Slope_Points[SequencesNo + 1, 1];

            if (All_Slope_Points[SequencesNo + 1, 6] > (X_DrawWindow - 2 * X_margine))//if slope cross right domain of Model
            {
                All_Slope_Points[SequencesNo + 1, 7] = -(All_Slope_Points[SequencesNo + 1, 6]
                    - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[SequencesNo - 1, 23]) * Math.PI / 180d);
                All_Slope_Points[SequencesNo + 1, 6] = (X_DrawWindow - 2 * X_margine);
            }
            //5th point
            All_Slope_Points[SequencesNo + 1, 8] = All_Slope_Points[SequencesNo + 1, 6];
            All_Slope_Points[SequencesNo + 1, 9] = All_Slope_Points[SequencesNo + 1, 1];


            Model_Points[0].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 0]);
            Model_Points[0].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 1]);

            Model_Points[1].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 2]);
            Model_Points[1].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 3]);

            Model_Points[2].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 4]);
            Model_Points[2].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 5]);

            Model_Points[3].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 6]);
            Model_Points[3].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 7]);

            Model_Points[4].X = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 8]);
            Model_Points[4].Y = System.Convert.ToInt32(All_Slope_Points[SequencesNo + 1, 9]);

            using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                if (SequenceList[SequencesNo - 1, 6] == "Rock")
                    g.FillPolygon(Brushes.WhiteSmoke, Model_Points);//draw Right Domain
                if (SequenceList[SequencesNo - 1, 6] == "Soil")
                    g.FillPolygon(Brushes.Beige, Model_Points);//draw Right Domain
                if (SequenceList[SequencesNo - 1, 6] == "BIM")
                    g.FillPolygon(Brushes.LightGreen, Model_Points);//draw Right Domain
            }//right poligon of model drew
            //until now we draw all slopes
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            SliceNo = 0;
            for (int i = 1; i <= SequencesNo; i++)
            {
                SliceNo += System.Convert.ToInt32(SequenceList[i - 1, 21]);
            }

            int k = 0;
            bool flag1 = true;
            Slices = new double[SliceNo, 10];//all slices and colomn points coordination
            if (First_Crown_Pick == true)
                Slices_FOS_Animation = new int[SliceNo, 10];//all slices and colomn points coordination
            for (int i = SequencesNo; i > 0; i--)//Calculate all slices and colomns points coordination....i= slope no.
            {
                for (int j = 1; j <= System.Convert.ToInt32(SequenceList[i - 1, 21]); j++)//j = Slice No
                {
                    flag1 = true;
                    if (i < SequencesNo)
                        if (j == 1 && SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")//to add triangular element in Soil_Rock Model
                        {
                            Slices[k, 1] = Slices[k - 1, 5];//TRX
                            Slices[k, 2] = Slices[k - 1, 6];//TRY
                            Slices[k, 5] = Slices[k - 1, 5];//TLX
                            Slices[k, 6] = Slices[k - 1, 6];//TLY
                            Slices[k, 3] = Slices[k - 1, 7];//BRX
                            Slices[k, 4] = Slices[k - 1, 8];//BRY
                            Slices[k, 7] = Slices[k - 1, 5];//BLX
                            Slices[k, 8] = 0;//BLY
                            Slices[k, 9] = i - 1;//SEQ NO


                            if (Slices[k, 3] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                            {
                                Slices[k, 4] = -(Slices[k, 3] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                Slices[k, 3] = (X_DrawWindow - 2 * X_margine);
                            }
                            if (Slices[k, 7] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                            {
                                Slices[k, 8] = -(Slices[k, 7] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                Slices[k, 7] = (X_DrawWindow - 2 * X_margine);
                            }
                            using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                            {
                                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                                if (SequenceList[i - 1, 6] == "Rock")
                                {
                                    Slices[k, 0] = 0;
                                    g.DrawLine(Pens.Black,
                                        System.Convert.ToInt32(Slices[k, 1]),
                                        System.Convert.ToInt32(Slices[k, 2]),
                                        System.Convert.ToInt32(Slices[k, 3]),
                                        System.Convert.ToInt32(Slices[k, 4]));
                                }
                                /*                        if (SequenceList[i - 1, 6] == "Soil")
                                                        {
                                                            Slices[k, 0] = 1;
                                                            g.DrawLine(Pens.Salmon,
                                                                System.Convert.ToInt32(Slices[k, 1]),
                                                                System.Convert.ToInt32(Slices[k, 2]),
                                                                System.Convert.ToInt32(Slices[k, 3]),
                                                                System.Convert.ToInt32(Slices[k, 4]));
                                                        }
                                */
                                if (SequenceList[i - 1, 6] == "BIM")
                                {
                                    Slices[k, 0] = 2;
                                    g.DrawLine(Pens.Aquamarine,
                                        System.Convert.ToInt32(Slices[k, 1]),
                                        System.Convert.ToInt32(Slices[k, 2]),
                                        System.Convert.ToInt32(Slices[k, 3]),
                                        System.Convert.ToInt32(Slices[k, 4]));
                                }
                            }
                            flag1 = false;
                        }
                    if (flag1 == true)
                    {
                        Slices[k, 1] = System.Convert.ToInt32(All_Slope_Points[i, 4] - (j - 1) * (All_Slope_Points[i, 4] - All_Slope_Points[i, 2])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top right x
                        Slices[k, 2] = System.Convert.ToInt32(All_Slope_Points[i, 5] + (j - 1) * (All_Slope_Points[i, 3] - All_Slope_Points[i, 5])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top right Y
                        Slices[k, 3] = Slices[k, 1] - Slices[k, 2] / Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//Bottom right x
                        Slices[k, 4] = 0;//Bottom right Y
                        Slices[k, 5] = System.Convert.ToInt32(All_Slope_Points[i, 4] - j * (All_Slope_Points[i, 4] - All_Slope_Points[i, 2])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top Left x
                        Slices[k, 6] = System.Convert.ToInt32(All_Slope_Points[i, 5] + j * (All_Slope_Points[i, 3] - All_Slope_Points[i, 5])
                            / System.Convert.ToDouble(SequenceList[i - 1, 21]));//top Left Y
                        Slices[k, 7] = Slices[k, 5] - Slices[k, 6] / Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//Bottom Left x
                        Slices[k, 8] = 0;//Bottom Left Y
                        Slices[k, 9] = i;//Sequence No

                        if (Slices[k, 3] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                        {
                            Slices[k, 4] = -(Slices[k, 3] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                            Slices[k, 3] = (X_DrawWindow - 2 * X_margine);
                        }
                        if (Slices[k, 7] > (X_DrawWindow - 2 * X_margine))//if Line cross right domain of Model
                        {
                            Slices[k, 8] = -(Slices[k, 7] - (X_DrawWindow - 2 * X_margine)) * Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                            Slices[k, 7] = (X_DrawWindow - 2 * X_margine);
                        }
                        using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                        {
                            g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                            if (SequenceList[i - 1, 6] == "Rock")
                            {
                                Slices[k, 0] = 0;
                                Model_Points[0].X = System.Convert.ToInt32(Slices[k, 7]);
                                Model_Points[0].Y = System.Convert.ToInt32(Slices[k, 8]);
                                Model_Points[1].X = System.Convert.ToInt32(Slices[k, 5]);
                                Model_Points[1].Y = System.Convert.ToInt32(Slices[k, 6]);
                                Model_Points[2].X = System.Convert.ToInt32(Slices[k, 1]);
                                Model_Points[2].Y = System.Convert.ToInt32(Slices[k, 2]);
                                Model_Points[3].X = System.Convert.ToInt32(Slices[k, 3]);
                                Model_Points[3].Y = System.Convert.ToInt32(Slices[k, 4]);
                                Model_Points[4].X = System.Convert.ToInt32(Slices[k, 3]);
                                if (Model_Points[3].X == X_DrawWindow - 2 * X_margine)
                                    Model_Points[4].Y = 0;
                                else
                                    Model_Points[4].Y = System.Convert.ToInt32(Slices[k, 4]);
                                if (SteppedSurface == true)
                                {
                                    M_c = Math.Tan(System.Convert.ToDouble(SequenceList[i - 1, 23]) * Math.PI / 180d);
                                    M_c_p = -1d / M_c;
                                    X_A = Slices[k, 5];
                                    Y_A = Slices[k, 6];
                                    X_B = Slices[k, 1];
                                    Y_B = Slices[k, 2];
                                    double XXX = (Y_B - Y_A + M_c * X_A - M_c_p * X_B) / (M_c - M_c_p);
                                    Model_Points[1].X = System.Convert.ToInt32(XXX);
                                    Model_Points[1].Y = System.Convert.ToInt32(Y_B + M_c_p * (XXX - X_B));
                                }
                                g.FillPolygon(Brushes.LightGray, Model_Points);//draw Slope
                                g.DrawLine(Pens.Black,
                                    System.Convert.ToInt32(Slices[k, 1]),
                                    System.Convert.ToInt32(Slices[k, 2]),
                                    System.Convert.ToInt32(Slices[k, 3]),
                                    System.Convert.ToInt32(Slices[k, 4]));

                            }
                            /*                        if (SequenceList[i - 1, 6] == "Soil")
                                                    {
                                                        Slices[k, 0] = 1;
                                                        g.DrawLine(Pens.Salmon,
                                                            System.Convert.ToInt32(Slices[k, 1]),
                                                            System.Convert.ToInt32(Slices[k, 2]),
                                                            System.Convert.ToInt32(Slices[k, 3]),
                                                            System.Convert.ToInt32(Slices[k, 4]));
                                                    }
                            */
                            if (SequenceList[i - 1, 6] == "BIM")
                            {
                                Slices[k, 0] = 2;
                                g.DrawLine(Pens.Aquamarine,
                                    System.Convert.ToInt32(Slices[k, 1]),
                                    System.Convert.ToInt32(Slices[k, 2]),
                                    System.Convert.ToInt32(Slices[k, 3]),
                                    System.Convert.ToInt32(Slices[k, 4]));
                            }

                            if (First_Crown_Pick == true)
                            {
                                Slices_FOS_Animation[k, 0] = Model_Points[0].X;
                                Slices_FOS_Animation[k, 1] = Model_Points[0].Y;
                                Slices_FOS_Animation[k, 2] = Model_Points[1].X;
                                Slices_FOS_Animation[k, 3] = Model_Points[1].Y;
                                Slices_FOS_Animation[k, 4] = Model_Points[2].X;
                                Slices_FOS_Animation[k, 5] = Model_Points[2].Y;
                                Slices_FOS_Animation[k, 6] = Model_Points[3].X;
                                Slices_FOS_Animation[k, 7] = Model_Points[3].Y;
                                Slices_FOS_Animation[k, 8] = Model_Points[4].X;
                                Slices_FOS_Animation[k, 9] = Model_Points[4].Y;
                            }
                        }

                    }

                    k++;
                }

                ////////////////////////////////////////////////////////////////////////////////

                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    if (SequenceList[i - 1, 6] == "Rock")
                        g.DrawLine(Pens.Black,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                    if (SequenceList[i - 1, 6] == "Soil")
                        g.DrawLine(Pens.Salmon,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                    if (SequenceList[i - 1, 6] == "BIM")
                        g.DrawLine(Pens.Aquamarine,
                            System.Convert.ToInt32(Slices[k - 1, 5]),
                            System.Convert.ToInt32(Slices[k - 1, 6]),
                            System.Convert.ToInt32(Slices[k - 1, 7]),
                            System.Convert.ToInt32(Slices[k - 1, 8]));
                }
            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            Anchor_Line = new double[AnchorNo, 7];//all cordination , force sequence data aboat each anchor
            Pen AnchorPen = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing anchors
            for (int i = 1; i <= AnchorNo; i++)//calculate anchors parameters and draw
            {
                Anchor_Line[i - 1, 0] = System.Convert.ToDouble(AnchorList[i - 1, 8]);//Sequence No.
                Anchor_Line[i - 1, 1] = All_Slope_Points[System.Convert.ToInt32(Anchor_Line[i - 1, 0]), 2] + DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 3])
                    / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180);//Anchor head X
                Anchor_Line[i - 1, 2] = All_Slope_Points[System.Convert.ToInt32(Anchor_Line[i - 1, 0]), 3] - DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 3]);//Anchor Head Y
                Anchor_Line[i - 1, 3] = Anchor_Line[i - 1, 1] + DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 5]) * Math.Cos(System.Convert.ToDouble(AnchorList[i - 1, 4]) * Math.PI / 180);//Anchor Point X
                Anchor_Line[i - 1, 4] = Anchor_Line[i - 1, 2] - DrawingScale * System.Convert.ToDouble(AnchorList[i - 1, 5]) * Math.Sin(System.Convert.ToDouble(AnchorList[i - 1, 4]) * Math.PI / 180);//Anchor Point Y
                Anchor_Line[i - 1, 5] = System.Convert.ToDouble(AnchorList[i - 1, 6]);//Anchor force
                Anchor_Line[i - 1, 6] = System.Convert.ToDouble(AnchorList[i - 1, 7]);// anchor yeild force
                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Anchors in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLine(AnchorPen,// to draw anchor cable
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4]));
                    g.DrawLine(AnchorPen,//to draw anchor Head
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] + 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] - 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] - 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] + 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)));
                    g.FillEllipse(Brushes.Black,// to draw anchor point
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3] - 6),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4] - 7),
                        12, 14);
                }
            }
            //until now we drawn all anchors
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            Pen ForceLine = new Pen(Color.FromArgb(255, 255, 215, 0), 3);// thick pen for drawing forces
            for (int i = 1; i <= ForceNo; i++)
            {
                if (ForceList[i - 1, 2] == "Point")
                {
                    using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Anchors in it's panel
                    {
                        g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 40));
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)) + 3,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 10));
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5])
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)) - 3,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * System.Convert.ToDouble(ForceList[i - 1, 5]) - 10));
                    }
                }
                if (ForceList[i - 1, 2] == "Uniform")
                {
                    using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Anchors in it's panel
                    {
                        g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                        for (int j = 0; j <= 5; j++)
                        {
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 40));
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180) + 3),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 10));
                            g.DrawLine(ForceLine,
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5)
                                 / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180) - 3),
                                 System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + j * (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])) / 5) - 10));
                        }
                        g.DrawLine(ForceLine,
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]))
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5])) - 40),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 2] + DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5])))
                             / Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(ForceList[i - 1, 8]) - 1, 19])) * Math.PI / 180)),
                             System.Convert.ToInt32(All_Slope_Points[System.Convert.ToInt32(ForceList[i - 1, 8]), 3] - DrawingScale * (System.Convert.ToDouble(ForceList[i - 1, 5]) + (System.Convert.ToDouble(ForceList[i - 1, 6]) - System.Convert.ToDouble(ForceList[i - 1, 5]))) - 40));
                    }
                }
            }
            //Untill Now we drew all forces
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            Pen WaterLine = new Pen(Color.FromArgb(255, 0, 0, 255), 5);// thick pen for drawing water line
            WaterLevel = new Point[6 * SequencesNo];
            double m_w = 0, m_f = 0, m_c = 0, X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

            for (int i = 1; i <= SequencesNo; i++)// water line for each slope
            {
                m_w = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 41])) * Math.PI / 180);//dip of water line
                m_c = Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);//dip of columns or slices
                m_f = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 19])) * Math.PI / 180);//dip of face

                WaterLevel[(i - 1) * 6 + 0].X = System.Convert.ToInt32(All_Slope_Points[i, 8]);
                WaterLevel[(i - 1) * 6 + 0].Y = System.Convert.ToInt32(All_Slope_Points[i, 9]);
                WaterLevel[(i - 1) * 6 + 1].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                WaterLevel[(i - 1) * 6 + 1].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);

                WaterLevel[(i - 1) * 6 + 2].Y = System.Convert.ToInt32(System.Convert.ToDouble(All_Slope_Points[i, 5])
                    + DrawingScale * System.Convert.ToDouble(SequenceList[i - 1, 39]));
                if (WaterLevel[(i - 1) * 6 + 2].Y >= 0)
                {
                    WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 2].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 6]);
                    WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                    WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                    WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                }
                else
                {
                    X1 = System.Convert.ToDouble(All_Slope_Points[i, 4]);
                    Y1 = System.Convert.ToDouble(All_Slope_Points[i, 5]);
                    Y2 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].Y);
                    WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(X1 + (Y2 - Y1) / m_c);


                    if (i < SequencesNo)//for Soil_Rock Model
                        if (SequenceList[i - 1, 6] == "Soil" && SequenceList[i, 6] == "Rock")
                        {
                            WaterLevel[(i - 1) * 6 + 2].X = System.Convert.ToInt32(X1 + (Y2 - Y1) /
                                (Math.Tan((System.Convert.ToDouble(SequenceList[i, 23])) * Math.PI / 180)));
                        }


                    X1 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].X);
                    Y1 = System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 2].Y);
                    Y2 = 0;
                    if (X1 + (Y2 - Y1) / m_w >= System.Convert.ToDouble(All_Slope_Points[i, 0])
                        && X1 + (Y2 - Y1) / m_w <= System.Convert.ToDouble(All_Slope_Points[i, 6]))
                    {
                        WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X1 + (Y2 - Y1) / m_w);
                        WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32(All_Slope_Points[i, 7]);
                        WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                        WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                        WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                    }
                    else
                    {
                        X2 = System.Convert.ToDouble(All_Slope_Points[i, 2]);
                        Y2 = System.Convert.ToDouble(All_Slope_Points[i, 3]);
                        if ((m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w) < 0 && (m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w) > Y2)
                        {
                            WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32((m_c * Y1 - m_w * Y2 + m_c * m_w * (X2 - X1)) / (m_c - m_w));
                            WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X2 + (System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 3].Y) - Y2) / m_c);
                            WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                            WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        }
                        else
                        {
                            WaterLevel[(i - 1) * 6 + 3].Y = System.Convert.ToInt32((m_f * Y1 - m_w * Y2 + m_f * m_w * (X2 - X1)) / (m_f - m_w));
                            WaterLevel[(i - 1) * 6 + 3].X = System.Convert.ToInt32(X2 + (System.Convert.ToDouble(WaterLevel[(i - 1) * 6 + 3].Y) - Y2) / m_f);
                            WaterLevel[(i - 1) * 6 + 4].X = System.Convert.ToInt32(All_Slope_Points[i, 2]);
                            WaterLevel[(i - 1) * 6 + 4].Y = System.Convert.ToInt32(All_Slope_Points[i, 3]);
                            WaterLevel[(i - 1) * 6 + 5].X = System.Convert.ToInt32(All_Slope_Points[i, 0]);
                            WaterLevel[(i - 1) * 6 + 5].Y = System.Convert.ToInt32(All_Slope_Points[i, 1]);
                        }
                    }
                }
            }

            using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw water level in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                g.DrawLines(WaterLine, WaterLevel);
            }
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            if (SequenceList[0, 6] == "Rock")//if we have fully rock slope or rock-soil slope-> count rocky slopes
            {
                RockySlopeNo = 0;
                for (int i = 0; i < SequencesNo; i++)
                    if (SequenceList[i, 6] == "Rock")
                        RockySlopeNo++;
                BasalPlanePoints = new Point[RockySlopeNo + 1];
                BasalPlanePoints[0].X = System.Convert.ToInt32(All_Slope_Points[1, 2]);
                BasalPlanePoints[0].Y = System.Convert.ToInt32(All_Slope_Points[1, 3]);
                double M_B = 0;
                double M_C = 0;
                for (int i = 1; i <= RockySlopeNo; i++)
                {
                    M_B = Math.Tan((180 - System.Convert.ToDouble(SequenceList[i - 1, 31])) * Math.PI / 180);
                    M_C = Math.Tan((System.Convert.ToDouble(SequenceList[i - 1, 23])) * Math.PI / 180);
                    X1 = BasalPlanePoints[i - 1].X;
                    Y1 = BasalPlanePoints[i - 1].Y;
                    X2 = All_Slope_Points[i, 4];
                    Y2 = All_Slope_Points[i, 5];
                    BasalPlanePoints[i].X = System.Convert.ToInt32((Y2 - Y1 + M_B * X1 - M_C * X2) / (M_B - M_C));
                    BasalPlanePoints[i].Y = System.Convert.ToInt32(Y1 + M_B * (System.Convert.ToDouble(BasalPlanePoints[i].X) - X1));
                }
                Pen BasalLine = new Pen(Color.FromArgb(112, 128, 144, 255), 3);// thick pen for drawing water line
                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Anchors in it's panel
                {
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLines(BasalLine, BasalPlanePoints);
                }
            }

            First_Crown_Pick = false;
        }

        private void Result_Visualizing_FOS_Animation(int Critical_Situ_No)
        {
            int X_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Height;//the height of drawing area
            int X_margine = 10;
            int Y_margine = 10;
            double[,] MaxMin_Column = new double[2, 10];

            Point[] Each_Slice_Color = new Point[4];
            Pen WaterLine = new Pen(Color.FromArgb(255, 0, 0, 255), 5);// thick pen for drawing water line
            Pen Blockies = new Pen(Color.FromArgb(255, 255, 0, 0), 5);// thick pen for drawing water line
            Pen AnchorPen = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing anchors
            Pen Slope_Crown = new Pen(Color.FromArgb(255, 255, 255, 0), 3);// thick pen for drawing water line

            using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
            {
                g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)
                {
                    Each_Slice_Color[0].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 4] * DrawingScale);//TR
                    Each_Slice_Color[0].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 5] * DrawingScale);//TR
                    Each_Slice_Color[1].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 0] * DrawingScale);//TL
                    Each_Slice_Color[1].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 1] * DrawingScale);//TL
                    Each_Slice_Color[2].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6] * DrawingScale);//BL
                    Each_Slice_Color[2].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7] * DrawingScale);//BL
                    Each_Slice_Color[3].X = System.Convert.ToInt16(All_Slope_Points[0, 4] + Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 10] * DrawingScale);//BR
                    Each_Slice_Color[3].Y = System.Convert.ToInt16(All_Slope_Points[0, 5] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 11] * DrawingScale);//BR
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 0)//Stable
                        g.FillPolygon(Brushes.Green, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 1)//Slide
                        g.FillPolygon(Brushes.RoyalBlue, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 2)//Topple
                        g.FillPolygon(Brushes.OrangeRed, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 3)//Flexure
                        g.FillPolygon(Brushes.Violet, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 4)//Shear
                        g.FillPolygon(Brushes.Salmon, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 5)//Unstable
                        g.FillPolygon(Brushes.Yellow, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 79] == 6)//Out of range
                        g.FillPolygon(Brushes.LightGray, Each_Slice_Color);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 1)//Rock
                        g.DrawLine(Pens.Black, Each_Slice_Color[0].X, Each_Slice_Color[0].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 2)//Soil
                        g.DrawLine(Pens.Salmon, Each_Slice_Color[0].X, Each_Slice_Color[0].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                    g.DrawLines(WaterLine, WaterLevel);
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 29] == 1 && Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 67] == 1)
                        g.DrawLine(Blockies, Each_Slice_Color[2].X, Each_Slice_Color[2].Y, Each_Slice_Color[3].X, Each_Slice_Color[3].Y);
                }


                for (int i = 1; i <= AnchorNo; i++)//draw anchors
                {
                    g.DrawLine(AnchorPen,// to draw anchor cable
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3]),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4]));
                    g.DrawLine(AnchorPen,//to draw anchor Head
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] + 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] - 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 1] - 10),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 2] + 10
                        * Math.Tan((System.Convert.ToDouble(SequenceList[System.Convert.ToInt32(Anchor_Line[i - 1, 0]) - 1, 19])) * Math.PI / 180)));
                    g.FillEllipse(Brushes.Black,// to draw anchor point
                        System.Convert.ToInt32(Anchor_Line[i - 1, 3] - 6),
                        System.Convert.ToInt32(Anchor_Line[i - 1, 4] - 7),
                        12, 14);
                }

                int X_Force_Height_Center = 0, Y_Force_Height_Center = 0;
                for (int Slice_Counter = SliceNo; Slice_Counter > 0; Slice_Counter--)//mark force hgeights
                {
                    if (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20] > 0)
                    {
                        X_Force_Height_Center = System.Convert.ToInt32(All_Slope_Points[0, 4] + DrawingScale * (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6]
                            - (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 74] / Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20]) *
                            (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 6] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 0])));
                        Y_Force_Height_Center = System.Convert.ToInt32(All_Slope_Points[0, 5] - DrawingScale * (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7]
                            - (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 74] / Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 20]) *
                            (Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 7] - Sorted_All_Model_Details[Critical_Situ_No, Slice_Counter - 1, 1])));
                        g.FillEllipse(Brushes.Black, X_Force_Height_Center - 2, Y_Force_Height_Center - 2, 4, 4);
                    }
                }


                for(int k=0;k<SliceNo;k++)
                {
                    Model_Points[0].X = Slices_FOS_Animation[k, 0];
                    Model_Points[0].Y = Slices_FOS_Animation[k, 1];
                    Model_Points[1].X = Slices_FOS_Animation[k, 2];
                    Model_Points[1].Y = Slices_FOS_Animation[k, 3];
                    Model_Points[2].X = Slices_FOS_Animation[k, 4];
                    Model_Points[2].Y = Slices_FOS_Animation[k, 5];
                    Model_Points[3].X = Slices_FOS_Animation[k, 6];
                    Model_Points[3].Y = Slices_FOS_Animation[k, 7];
                    Model_Points[4].X = Slices_FOS_Animation[k, 8];
                    Model_Points[4].Y = Slices_FOS_Animation[k, 9];
                    g.DrawPolygon(Slope_Crown, Model_Points);
                }

            }

        }

        private void Find_Critical_Buckling_ByAnimation()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            First_Crown_Pick = true;

            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = 0.001;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = 0.001;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.001;
                }
            }
            Draw_FOS_Calculation_Path();
            try
            { Result_Visualizing_FOS_Animation(0); }
            catch { }
            System.Threading.Thread.Sleep(FOS_Animation_Stop);


            while (FOS_Finding_Try < 10000 && FOS_Value > 0 && FOS_Value < 10)
            {
                FOS_Finding_Try++;
                FOS_Value += FOS_Step;
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));


                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                            * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
                    else
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                            / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height



//                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                            * FOS_Value) * 180 / Math.PI);//face angle
//                    else
//                        SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
//                            / FOS_Value) * 180 / Math.PI);//face angle



                    if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000)//check if phi value is not feasible 
                    {
                        if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                            MessageBox.Show("FOS calculation is not possible or is too High");
                        FOS_Text = "Error";
                        FOS_Value = -1;//Error Number
                        break;
                    }
                    if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000)//check if phi value is not feasible 
                    {
                        if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                            MessageBox.Show("FOS calculation is not possible or is too low");
                        FOS_Text = "Error";
                        FOS_Value = -1;//Error Number
                        break;
                    }
                }
                if (FOS_Text != "Error")
                {
                    if (Rad_Btn_Start.Checked == true)
                        FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                    Solve_For_FOS3();
                }
                Draw_FOS_Calculation_Path();
                try
                { Result_Visualizing_FOS_Animation(0); }
                catch { }
                System.Threading.Thread.Sleep(FOS_Animation_Stop);

                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);

                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }

                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == false)//is Stable asn Was UnStable
                        break;
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                        break;
                }
            }

        }

        private void Find_Critical_III_ByAnimation()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            First_Crown_Pick = true;

            Recalculate_FOS = false;
            Find_Critical_III_For_Sensitivity(SequenceList, ModelDetail);

            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                    SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

            for (int i = 0; i < 10; i++)
                ModelDetail[i] = Origin_ModelDetail[i];
            Solve_For_FOS3();

            FOS_Value = 1;
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = 0.001;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = 0.001;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.001;
                }
            }
            Draw_FOS_Calculation_Path();
            try
            { Result_Visualizing_FOS_Animation(0); }
            catch { }
            System.Threading.Thread.Sleep(FOS_Animation_Stop);

            while (FOS_Finding_Try < 10000 && FOS_Value > 0 && FOS_Value < 10)
            {
                FOS_Finding_Try++;
                FOS_Value += FOS_Step;
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                            * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
                    else
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                            / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height



//                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                            * FOS_Value) * 180 / Math.PI);//face angle
//                    else
//                        SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
//                            / FOS_Value) * 180 / Math.PI);//face angle

                    if (Recalculate_FOS == false)
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                    else
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) * FOS_Value) * 180 / Math.PI);

                    if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) > 90)//check if phi value is not feasible 
                    {
                        if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                            MessageBox.Show("FOS calculation is not possible or is too High");
                        FOS_Text = "Error";
                        FOS_Value = -1;//Error Number
                        break;
                    }
                    if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                    {
                        if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                            MessageBox.Show("FOS calculation is not possible or is too low");
                        FOS_Text = "Error";
                        FOS_Value = -1;//Error Number
                        break;
                    }
                }
                if (FOS_Text != "Error")
                {
                    if (Rad_Btn_Start.Checked == true)
                        FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                    Solve_For_FOS3();
                }
                Draw_FOS_Calculation_Path();
                try
                { Result_Visualizing_FOS_Animation(0); }
                catch { }
                System.Threading.Thread.Sleep(FOS_Animation_Stop);

                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }

                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == false)//is Stable asn Was UnStable
                        break;
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                        break;
                }
            }
        }

        private void Sensitivity_FOS_Calculation(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            FOS_Value = 1;

            if (Rad_Btn_Phi.Checked == true)
                Find_Critical_Phi_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Phi_B.Checked == true)
                Find_Critical_Phi_Basal_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Phi_Mat.Checked == true)
                Find_Critical_Phi_Material_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Phi_Int.Checked == true)
                Find_Critical_Phi_Internal_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_C.Checked == true)
                Find_Critical_C_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_C_B.Checked == true)
                Find_Critical_C_Basal_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_C_Mat.Checked == true)
                Find_Critical_C_Material_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_C_Int.Checked == true)
                Find_Critical_C_Internal_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Say_Base.Checked == true)
                Find_Critical_Say_Base_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Tensile.Checked == true)
                Find_Critical_Tensile_For_Sensitivity(temp_SequenceList, temp_ModelDetail);//in rock column

            if (Rad_Btn_Say_Face.Checked == true)
                Find_Critical_Say_Face_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Face_Height.Checked == true)
                Find_Critical_Slope_Height_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Unit_Weight.Checked == true)
                Find_Critical_Unit_Weight_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Column_Angle.Checked == true)
                Find_Critical_Say_Column_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_ColumnNo.Checked == true)
                Find_Critical_ColumnNo_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Kh.Checked == true)
                Find_Critical_Kh_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Kv.Checked == true)
                Find_Critical_Kv_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Kh_Kv.Checked == true)
                Find_Critical_Kh_Kv_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Shear.Checked == true)
                Find_Critical_Shear_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_Buckling.Checked == true)
                Find_Critical_Buckling_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            if (Rad_Btn_III.Checked == true)
                Find_Critical_III_For_Sensitivity(temp_SequenceList, temp_ModelDetail);

            Rad_Btn_Sensitivity_Analysis.Checked = false;
        }

        private List<double> Fill_Safety_Factor_List(double FOS, double FOS_By)
        {
            List<double> one_Step_SafetyBy_List = new List<double>();
            one_Step_SafetyBy_List.Clear();
            one_Step_SafetyBy_List.Add(FOS_By);
            one_Step_SafetyBy_List.Add(FOS);
            return one_Step_SafetyBy_List;
        }

        private void Find_Critical_III()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            Recalculate_FOS = false;

            double buckling_FOS = 0;

            buckling_FOS = Find_Critical_Buckling();


            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    else if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    else if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    else if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);//face angle
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                / FOS_Value) * 180 / Math.PI);//face angle


//                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                                * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
//                        else
//                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
//                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height


                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);



                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) > 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Recalculate_FOS_By_III()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            Recalculate_FOS = true;


            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);//face angle
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                / FOS_Value) * 180 / Math.PI);//face angle


//                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                                * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
//                        else
//                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
//                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height


                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) * FOS_Value) * 180 / Math.PI);


                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) > 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }
        
        private double Find_Critical_Buckling()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";

            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) 
                                * ((2*FOS_Value)/(1+FOS_Value)));//Slope Height
                        else
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20])
                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height



//                        if(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180) 
                                * FOS_Value) * 180 / Math.PI);//face angle
//                        else
//                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180)
//                                / FOS_Value) * 180 / Math.PI);//face angle



                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true && Rad_Btn_Buckling.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
            return (Math.Round(FOS_Value, 3));
        }

        private void Find_Critical_Say_Base()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 31] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]) * Math.PI / 180) 
                            / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 31]) < -10)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 31]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Kh()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[3]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[3]) <= -5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[3]) >= 5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[3])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Kv()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[5] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[5]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[5]) <= -5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[5]) >= 5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[5])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Kh_Kv()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value,3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[3]) * FOS_Value);
                        ModelDetail[5] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[5]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[3]) <= -5 || System.Convert.ToDouble(ModelDetail[5]) <= -5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[3]) >= 5 || System.Convert.ToDouble(ModelDetail[5]) >= 5)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[3])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Shear()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);//phi material
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) / FOS_Value);//c material

                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_ColumnNo()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable and Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to Column No. value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 21]) * FOS_Value));
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 21]) < 1)//check if Column No value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too High");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 21]) >= 10000)//check if phi value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too low");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        SliceNo = 0;
                        for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                        {
                            SliceNo += System.Convert.ToInt32(SequenceList[Seq_counter, 21]);
                        }
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 21])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
            SliceNo = 0;
            for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
            {
                SliceNo += System.Convert.ToInt32(Origin_SequenceList[Seq_counter, 21]);
            }

        }

        private void Find_Critical_Say_Column()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);

                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too High");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 23]) >= 90)//check if phi value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too low");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 23])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Unit_Weight()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 11]) * FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 11]) <= 0)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 20]) >= 200000)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 11])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Slope_Height()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else 
//            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }

                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) * FOS_Value);
                        else
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) / FOS_Value);



                        if (Seq_counter == 0 && System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 20]) >= 10000)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 20])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Say_Face()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180) 
                                * FOS_Value) * 180 / Math.PI);
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * Math.PI / 180) 
                                / FOS_Value) * 180 / Math.PI);

                        if (Seq_counter == 0 && System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 19])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Phi()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == true && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);

                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 90 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Phi_Basal()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 37]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 37]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 37])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Phi_Material()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Phi_Internal()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) >= 90)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 29])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_C()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) / FOS_Value);
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) / FOS_Value);
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) / FOS_Value);
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 27]) < 0 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 35]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 45]) < 0)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 27]) >= 10000000000 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 35]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 45]) >= 10000000000)//check if c value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 7])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_C_Basal()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 35]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 35]) >= 10000000000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 35])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_C_Material()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 7])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_C_Internal()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            //            if (Sorted_Critical_Situation_Charts[0, 1, 9] != null && Sorted_Critical_Situation_Charts[0, 1, 9] != "-----")
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) / FOS_Value);
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 27]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) <= 0)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too High");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 27]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 10000000000)//check if phi value is not feasible 
                        {
                            if (Rad_Btn_Start.Checked == true)
                                MessageBox.Show("FOS calculation is not possible or is too low");
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 27])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_Tensile()
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if (Rad_Btn_Start.Checked == true)
                        MessageBox.Show("FOS Determined Successfully");
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too High");
                    }
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if (Rad_Btn_Start.Checked == true)
                    {
                        Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                        Txt_Bx_Iteration.Refresh();
                        MessageBox.Show("FOS is too Low");
                    }
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 13] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 13]) / FOS_Value);
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 13]) < 0)//check if tensile strength value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too High");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 13]) >= 10000000000)//check if phi value is not feasible 
                            {
                                if (Rad_Btn_Start.Checked == true)
                                    MessageBox.Show("FOS calculation is not possible or is too low");
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 13])));
                        Solve_For_FOS3();
                    }
                }
                if (Rad_Btn_Start.Checked == true)
                {
                    Txt_Bx_Iteration.Text = System.Convert.ToString(FOS_Finding_Try);
                    Txt_Bx_Iteration.Refresh();
                    if (FOS_Value >= 1)
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 0, 255, 0);
                    else
                        Txt_Bx_SOF.ForeColor = Color.FromArgb(255, 255, 0, 0);
                    Txt_Bx_SOF.Text = FOS_Text;
                    Txt_Bx_SOF.Refresh();
                }
            }
        }

        private void Find_Critical_III_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            Recalculate_FOS = false;

            double buckling_FOS = 0;

            buckling_FOS = Find_Critical_Buckling_For_Sensitivity(temp_SequenceList, temp_ModelDetail);


            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                {
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    break;
                }

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    if ((buckling_FOS > 1 && buckling_FOS < Math.Round(FOS_Value, 3)) ||
                        (buckling_FOS < 1 && buckling_FOS > Math.Round(FOS_Value, 3)))
                        Recalculate_FOS_By_III();
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);//face angle
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                / FOS_Value) * 180 / Math.PI);//face angle


//                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
                                * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
//                        else
//                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
//                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height


                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);



                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) > 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Recalculate_FOS_By_III_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            Recalculate_FOS = true;


            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);//face angle
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                / FOS_Value) * 180 / Math.PI);//face angle


//                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
                                * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
//                        else
//                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
//                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height


                        SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 23]) * Math.PI / 180) * FOS_Value) * 180 / Math.PI);


                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) > 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000 || System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private double Find_Critical_Buckling_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";

            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is Unstable and was stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is stable and was Unstable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
                                * ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height
                        else
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20])
                                / ((2 * FOS_Value) / (1 + FOS_Value)));//Slope Height


//                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);//face angle
//                        else
//                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
//                                / FOS_Value) * 180 / Math.PI);//face angle


                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= -45 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) > 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 20]) > 10000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
            }
            return (Math.Round(FOS_Value, 3));
        }

        private void Find_Critical_Shear_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 7]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Say_Base_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 31] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 31]) * Math.PI / 180)
                            / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 31]) < -10)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 31]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 31])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Kh_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(temp_ModelDetail[3]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[3]) <= -5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[3]) >= 5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[3])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Kv_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[5] = System.Convert.ToString(System.Convert.ToDouble(temp_ModelDetail[5]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[5]) <= -5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[5]) >= 5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[5])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Kh_Kv_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(temp_ModelDetail[3]) * FOS_Value);
                        ModelDetail[5] = System.Convert.ToString(System.Convert.ToDouble(temp_ModelDetail[5]) * FOS_Value);
                        if (System.Convert.ToDouble(ModelDetail[3]) <= -5 || System.Convert.ToDouble(ModelDetail[5]) <= -5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(ModelDetail[3]) >= 5 || System.Convert.ToDouble(ModelDetail[5]) >= 5)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(ModelDetail[3])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_ColumnNo_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable and Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to Column No. value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 21]) * FOS_Value));
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 21]) < 1)//check if Column No value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 21]) >= 10000)//check if phi value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        SliceNo = 0;
                        for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                        {
                            SliceNo += System.Convert.ToInt32(SequenceList[Seq_counter, 21]);
                        }
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 21])));
                        Solve_For_FOS3();
                    }
                }
            }
            SliceNo = 0;
            for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
            {
                SliceNo += System.Convert.ToInt32(temp_SequenceList[Seq_counter, 21]);
            }
        }

        private void Find_Critical_Say_Column_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 23] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 23]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);

                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 23]) <= 0)//check if phi value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 23]) >= 90)//check if phi value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 23])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Unit_Weight_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 11]) * FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 11]) <= 0)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 20]) >= 200000)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 11])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Slope_Height_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }

                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) >= 0)
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) * FOS_Value);
                        else
                            SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 20]) / FOS_Value);



                        if (Seq_counter == 0 && System.Convert.ToDouble(SequenceList[Seq_counter, 20]) <= -1000)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 20]) >= 10000)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 20])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Say_Face_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) >= 0)
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                * FOS_Value) * 180 / Math.PI);
                        else
                            SequenceList[Seq_counter, 19] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 19]) * Math.PI / 180)
                                / FOS_Value) * 180 / Math.PI);

                        if (Seq_counter == 0 && System.Convert.ToDouble(SequenceList[Seq_counter, 19]) <= 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 19]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 19])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Phi_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {

                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 29]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 37]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 47]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);

                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 90 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 37]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Phi_Basal_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 37]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 37]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 37])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Phi_Material_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 9]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 9]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 9])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Phi_Internal_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 29]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(Math.Atan(Math.Tan(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 47]) * Math.PI / 180) / FOS_Value) * 180 / Math.PI);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 90 || System.Convert.ToDouble(SequenceList[Seq_counter, 47]) >= 90)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 29])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_C_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 7]) / FOS_Value);
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 27]) / FOS_Value);
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 35]) / FOS_Value);
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 45]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 27]) < 0 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 35]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 45]) < 0)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 27]) >= 10000000000 ||
                            System.Convert.ToDouble(SequenceList[Seq_counter, 35]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 45]) >= 10000000000)//check if c value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 7])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_C_Basal_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 35]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 35]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 35]) >= 10000000000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 35])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_C_Material_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 7]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 7]) >= 10000000000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 7])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_C_Internal_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 27]) / FOS_Value);
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 45]) / FOS_Value);
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 27]) < 0 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) < 0)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                        if (System.Convert.ToDouble(SequenceList[Seq_counter, 27]) >= 10000000000 || System.Convert.ToDouble(SequenceList[Seq_counter, 29]) >= 10000000000)//check if phi value is not feasible 
                        {
                            FOS_Text = "Error";
                            FOS_Value = -1;//Error Number
                            break;
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 27])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Find_Critical_Tensile_For_Sensitivity(string[,] temp_SequenceList, string[] temp_ModelDetail)
        {
            bool is_Stable = true;
            int FOS_Finding_Try = 0;
            string FOS_Text = "";
            if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)
            {
                is_Stable = true;
                FOS_Step = +1;
            }
            else
            {
                if (Exact_Surfase == false && ModelDetail[7] == "Soil")
                {
                    Exact_from = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 9]);
                    Exact_to = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 10]);
                    Exact_arc = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 5]);
                    Exact_TC = System.Convert.ToInt32(Sorted_Critical_Situation_Charts[0, 0, 11]);
                    Exact_Surfase = true;
                }
                if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0)//stable
                {
                    is_Stable = true;
                    FOS_Step = +1;
                }
                else
                {
                    is_Stable = false;
                    FOS_Step = -0.1;
                }
            }
            while (FOS_Finding_Try < 100 && FOS_Text != "Error")
            {
                FOS_Finding_Try++;
                if (Sorted_Critical_Situation_Charts.GetLength(0) == 0)//is stable
                {
                    if (is_Stable == true)//is stable and was Stable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if (is_Stable == false)//is Stable asn Was UnStable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                else
                {
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == true)//is and was Stable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == false))//is and was unstable
                    {
                        FOS_Value += FOS_Step;
                    }
                    if ((System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) > 0 && is_Stable == true)//is stable and was unstable
                        || (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, 1, 9]) == 0 && is_Stable == false))//is unstable and was Stable
                    {
                        FOS_Value -= FOS_Step;
                        FOS_Step /= 10;
                        FOS_Value += FOS_Step;
                    }
                }
                FOS_Text = System.Convert.ToString(Math.Round(FOS_Value, 3));
                if (FOS_Step == -0.0001 || FOS_Step == +0.0001)//FOS Searching finished Successfully
                    break;

                if (FOS_Value > 20)//FOS is to high
                {
                    FOS_Value = 20;
                    FOS_Text = "Max";
                    break;
                }
                if (FOS_Value < 0)//FOS is to low
                {
                    FOS_Value = 0;
                    FOS_Text = "Min";
                    break;
                }
                if (FOS_Text != "Max" && FOS_Text != "Min")
                {
                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                    {
                        if (SequenceList[Seq_counter, 6] == "Rock")
                        {
                            SequenceList[Seq_counter, 13] = System.Convert.ToString(System.Convert.ToDouble(temp_SequenceList[Seq_counter, 13]) / FOS_Value);
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 13]) < 0)//check if tensile strength value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                            if (System.Convert.ToDouble(SequenceList[Seq_counter, 13]) >= 10000000000)//check if phi value is not feasible 
                            {
                                FOS_Text = "Error";
                                FOS_Value = -1;//Error Number
                                break;
                            }
                        }
                    }
                    if (FOS_Text != "Error")
                    {
                        if (Rad_Btn_Start.Checked == true)
                            FOS_List.Add(Fill_Safety_Factor_List(FOS_Value, System.Convert.ToDouble(SequenceList[0, 13])));
                        Solve_For_FOS3();
                    }
                }
            }
        }

        private void Rad_Btn_Sensitivity_Analysis_Click(object sender, EventArgs e)
        {

            string ErrorTXT = "";
            Export_opp = false;

            if (Rad_Btn_Phi.Checked == false &&
                Rad_Btn_Phi_B.Checked == false &&
                Rad_Btn_Phi_Mat.Checked == false &&
                Rad_Btn_Phi_Int.Checked == false &&
                Rad_Btn_Tensile.Checked == false &&
                Rad_Btn_C.Checked == false &&
                Rad_Btn_C_B.Checked == false &&
                Rad_Btn_C_Mat.Checked == false &&
                Rad_Btn_C_Int.Checked == false &&
                Rad_Btn_Unit_Weight.Checked == false &&
                Rad_Btn_Kh.Checked == false &&
                Rad_Btn_Kv.Checked == false &&
                Rad_Btn_Kh_Kv.Checked == false &&
                Rad_Btn_ColumnNo.Checked == false &&
                Rad_Btn_Face_Height.Checked == false &&
                Rad_Btn_Say_Face.Checked == false &&
                Rad_Btn_Column_Angle.Checked == false &&
                Rad_Btn_Say_Base.Checked == false &&
                Rad_Btn_Shear.Checked == false &&
                Rad_Btn_Reserve.Checked == false &&
                Rad_Btn_Buckling.Checked == false &&
                Rad_Btn_III.Checked == false)
            {
                ////////////////for Article
                if (ModelDetail[7] == "Soil")
                {
                    Rad_Btn_Shear.Checked = true;
                }
                else
                {
                    Rad_Btn_Phi.Checked = true;
                }
                ////////////////for Article

//                ErrorTXT += "\n One of Determinidtic FOS Calculation Ways Should Be Selected";
//                Rad_Btn_Sensitivity_Analysis.Checked = false;
            }
            if (Rad_Btn_Phi_Sensitivity.Checked == false &&
                Rad_Btn_Phi_Base_Sensitivity.Checked == false &&
                Rad_Btn_Phi_Mat_Sensitivity.Checked == false &&
                Rad_Btn_Phi_int_Sensitivity.Checked == false &&
                Rad_Btn_c_Sensitivity.Checked == false &&
                Rad_Btn_c_Base_Sensitivity.Checked == false &&
                Rad_Btn_c_mat_Sensitivity.Checked == false &&
                Rad_Btn_c_int_Sensitivity.Checked == false &&
                Rad_Btn_Tensile_Sensitivity.Checked == false &&
                Rad_Btn_UntWgt_Sensitivity.Checked == false &&
                Rad_Btn_FaceHeight_Sensitivity.Checked == false &&
                Rad_Btn_kh_Sensitivity.Checked == false &&
                Rad_Btn_kv_Sensitivity.Checked == false &&
                Rad_Btn_ColumnNo_Sensitivity.Checked == false &&
                Rad_Btn_Face_angle_Sensitivity.Checked == false &&
                Rad_Btn_Column_Angle_Sensitivity.Checked == false &&
                Rad_Btn_Say_Base_Angle_Sensitivity.Checked == false)
            {
                ErrorTXT += "\n Select one variable for SenSitivity Analysis";
                Rad_Btn_Sensitivity_Analysis.Checked = false;
            }
            else
            {
                Excel_sheetNo = 0;
                Excel_Work = false;
                DGVProbabilisticResult.Visible = false;
                Pnl_Deterministic.Enabled = false;
                Pnl_Probabilistic.Enabled = false;
                Pnl_MainMenu.Enabled = false;

                Lbl_ElpsTime.Visible = false;

                Solve_For_FOS3();

                if (Chk_Bx_SensitivityByFOS.Checked == true)
                {
                    if (Rad_Btn_Phi_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Phi_ByFOS();
                    if (Rad_Btn_Phi_Base_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_Phi_ByFOS();
                    if (Rad_Btn_Phi_Mat_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Mat_Phi_ByFOS();
                    if (Rad_Btn_Phi_int_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Int_Phi_ByFOS();
                    if (Rad_Btn_c_Sensitivity.Checked == true)
                        Sensitivity_Analysis_c_ByFOS();
                    if (Rad_Btn_c_Base_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_c_ByFOS();
                    if (Rad_Btn_c_mat_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Mat_c_ByFOS();
                    if (Rad_Btn_c_int_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Int_c_ByFOS();
                    if (Rad_Btn_Tensile_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_TensileStrength_ByFOS();
                    if (Rad_Btn_UntWgt_Sensitivity.Checked == true)
                        Sensitivity_Analysis_UnitWeight_ByFOS();
                    if (Rad_Btn_FaceHeight_Sensitivity.Checked == true)
                        Sensitivity_Analysis_FaseHeight_ByFOS();
                    if (Rad_Btn_kh_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Kh_ByFOS();
                    if (Rad_Btn_kv_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Kv_ByFOS();
                    if (Rad_Btn_ColumnNo_Sensitivity.Checked == true)
                        Sensitivity_Analysis_ColumnNo_ByFOS();
                    if (Rad_Btn_Face_angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_FaceAngle_ByFOS();
                    if (Rad_Btn_Column_Angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_ColumnAngle_ByFOS();
                    if (Rad_Btn_Say_Base_Angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_BasalAngle_ByFOS();
                }
                else
                {
                    if (Rad_Btn_Phi_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Phi();
                    if (Rad_Btn_Phi_Base_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_Phi();
                    if (Rad_Btn_Phi_Mat_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Mat_Phi();
                    if (Rad_Btn_Phi_int_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Int_Phi();
                    if (Rad_Btn_c_Sensitivity.Checked == true)
                        Sensitivity_Analysis_c();
                    if (Rad_Btn_c_Base_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_c();
                    if (Rad_Btn_c_mat_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Mat_c();
                    if (Rad_Btn_c_int_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Int_c();
                    if (Rad_Btn_Tensile_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Basal_TensileStrength();
                    if (Rad_Btn_UntWgt_Sensitivity.Checked == true)
                        Sensitivity_Analysis_UnitWeight();
                    if (Rad_Btn_FaceHeight_Sensitivity.Checked == true)
                        Sensitivity_Analysis_FaseHeight();
                    if (Rad_Btn_kh_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Kh();
                    if (Rad_Btn_kv_Sensitivity.Checked == true)
                        Sensitivity_Analysis_Kv();
                    if (Rad_Btn_ColumnNo_Sensitivity.Checked == true)
                        Sensitivity_Analysis_ColumnNo();
                    if (Rad_Btn_Face_angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_FaceAngle();
                    if (Rad_Btn_Column_Angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_ColumnAngle();
                    if (Rad_Btn_Say_Base_Angle_Sensitivity.Checked == true)
                        Sensitivity_Analysis_BasalAngle();
                }



                ExtractDataFromDataBase();
                Pnl_Deterministic.Enabled = true;
                Pnl_Probabilistic.Enabled = true;
                Pnl_MainMenu.Enabled = true;


                Rad_Btn_Sensitivity_Analysis.Checked = false;
            }


            if(Export_opp == true)
            {
                if (ErrorTXT != "")
                {
                    MessageBox.Show(ErrorTXT);
                }
                else
                {
                    MessageBox.Show("Sensitivity Analysis Completed");
                }
            }

        }

        private void Sensitivity_Analysis_Phi()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) == 0)
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) == 0)
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) == 0)
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) == 0)
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 4, 9, 29, 37, 47));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }

            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Mat_Phi()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) == 0)
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 9, 9, 9, 9));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Int_Phi()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) == 0)
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) == 0)
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 2, 29, 47, 29, 29));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Basal_Phi()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) == 0)
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 37, 37, 37, 37));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_c()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) == 0)
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) == 0)
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) == 0)
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) == 0)
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) * System.Convert.ToDouble(SolveNo) / 100d);

                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 4, 7, 27, 35, 45));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Mat_c()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) == 0)
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) * System.Convert.ToDouble(SolveNo) / 100d);

                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 7, 7, 7, 7));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Int_c()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) == 0)
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) == 0)
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) * System.Convert.ToDouble(SolveNo) / 100d);

                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 2, 27, 45, 27, 27));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Basal_c()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) == 0)
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 35, 35, 35, 35));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Basal_TensileStrength()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 13]) == 0)
                        SequenceList[Seq_counter, 13] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 13] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 13]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 13, 13, 13, 13));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_UnitWeight()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 11]) == 0)
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(10000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 11]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 11, 11, 11, 11));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_FaseHeight()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) == 0)
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(100d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 20, 20, 20, 20));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Kh()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_ModelDetail[3]) == 0)
                        ModelDetail[3] = System.Convert.ToString(1d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[3]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, false, 1, 3, 3, 3, 3));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_Kv()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_ModelDetail[4]) == 0)
                        ModelDetail[4] = System.Convert.ToString(1d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        ModelDetail[4] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[4]) * System.Convert.ToDouble(SolveNo) / 100d);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, false, 1, 4, 4, 4, 4));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_ColumnNo()
        {
            int first_Unstable = 1;
            int UnStblclmNmbr = 1;
            int OrgClmNo = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 450; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (Origin_SequenceList[Seq_counter, 6] == "Rock")
                    {
                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 21]) == 0)
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(10d * System.Convert.ToDouble(SolveNo) / 100d));//0 to 90
                        else
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 21]) * System.Convert.ToDouble(SolveNo) / 100d));
                        if (SequenceList[Seq_counter, 21] == "0")
                            SequenceList[Seq_counter, 21] = "1";
                    }
                }
                SliceNo = 0;
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                {
                    SliceNo += System.Convert.ToInt32(SequenceList[Seq_counter, 21]);
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    UnStblclmNmbr = 0;
                    OrgClmNo = 0;
                    for (int Seq_Cntr = 0; Seq_Cntr < SequencesNo; Seq_Cntr++)
                    {
                        OrgClmNo += System.Convert.ToInt32(Origin_SequenceList[Seq_Cntr, 21]);
                        if (OrgClmNo < first_Unstable)
                        {
                            UnStblclmNmbr += System.Convert.ToInt32(SequenceList[Seq_Cntr, 21]);
                        }
                        else
                        {
                            UnStblclmNmbr += System.Convert.ToInt32(SequenceList[Seq_Cntr, 21]) * first_Unstable
                                / System.Convert.ToInt32(Origin_SequenceList[Seq_Cntr, 21]);
                            Seq_Cntr = SequencesNo;
                        }

                    }
                    if (UnStblclmNmbr == 0)
                        UnStblclmNmbr++;
                    try
                    {
                        Sensitivity_Chart.Add(Save_one_Step_Sensitivity(UnStblclmNmbr, true, 1, 21, 21, 21, 21));
                        Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                        Txt_Bx_ProbabilisticSolveNo.Refresh();
                    }
                    catch
                    {

                    }
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_FaceAngle()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) == 0)
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 19, 19, 19, 19));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_ColumnAngle()
        {
            bool ReachMax = false;
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

                /*
                                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                                {
                                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                                    {
                                        first_Unstable = Slice_cntr;
                                        Slice_cntr = SliceNo + 1;
                                    }
                                }
                */
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) == 0)
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 23, 23, 23, 23));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private void Sensitivity_Analysis_BasalAngle()
        {
            int first_Unstable = 1;
            double Max_Block_Height = 0;
            List<List<double>> one_Step_Sensitivity_List = new List<List<double>>();
            List<double> SensitivityBy_OneParameter_List = new List<double>();

            double Min_Basal_Angle = 0;
            double Basal_Search_Angle = 80;

            if(Origin_SequenceList[0, 6] == "Rock")
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[0, 23]) - Basal_Search_Angle / 2d;
            else if(Origin_SequenceList[SequencesNo, 6] == "Rock")
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[SequencesNo, 23]) - Basal_Search_Angle / 2d;
            else
            {
                Basal_Search_Angle = 0;
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[SequencesNo, 23]) - Basal_Search_Angle / 2d;
            }


            Sensitivity_Chart.Clear();

            if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
            {

                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }

/*
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, Slice_cntr, 9]) > 0)
                    {
                        first_Unstable = Slice_cntr;
                        Slice_cntr = SliceNo + 1;
                    }
                }
*/
            }
            else
            {
                for (int Slice_cntr = 1; Slice_cntr <= SliceNo; Slice_cntr++)// to find first unstable Slice or Block
                {
                    if (Analytical_Slice_Data[Slice_cntr - 1, 19] > Max_Block_Height)
                    {
                        first_Unstable = Slice_cntr;
                        Max_Block_Height = Analytical_Slice_Data[Slice_cntr - 1, 19];
                    }
                }
            }


            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    SequenceList[Seq_counter, 31] = System.Convert.ToString(Min_Basal_Angle + Basal_Search_Angle * System.Convert.ToDouble(SolveNo) / 1000d);

/*
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]) == 0)
                        SequenceList[Seq_counter, 31] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 31] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 170 - System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 31]))
                        ReachMax = true;
*/
                }
/*

                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }
*/
                Solve_For_FOS3();
                if (Sorted_Critical_Situation_Charts.GetLength(0) > 0)
                {
                    Sensitivity_Chart.Add(Save_one_Step_Sensitivity(first_Unstable, true, 1, 31, 31, 31, 31));
                    Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
                    Txt_Bx_ProbabilisticSolveNo.Refresh();
                }
            }
//            Draw_Calculation_Chart();
        }

        private List<List<double>> Save_one_Step_Sensitivity
            (int FirstUnStable
            , bool WhichArray
            , int ParameterNo
            , int Par1, int Par2, int Par3, int Par4)
        {

            List<List<double>> one_Step_SensitivityBy_List = new List<List<double>>();
            one_Step_SensitivityBy_List.Clear();
            for (int i = 0; i < SequencesNo; i++)
            {
                one_Step_SensitivityBy_List.Add(Save_SensitivityBy_OneParameter(i, FirstUnStable, WhichArray, ParameterNo, Par1, Par2, Par3, Par4));
            }
            return one_Step_SensitivityBy_List;
        }

        private List<double> Save_SensitivityBy_OneParameter
            (int i, int FirstUnStable
            , bool WhichArray
            , int ParameterNo
            , int Par1, int Par2, int Par3, int Par4)
        {
            int[] ParNmbrs = new int[4];
            ParNmbrs[0] = Par1;
            ParNmbrs[1] = Par2;
            ParNmbrs[2] = Par3;
            ParNmbrs[3] = Par4;
            List<double> SensitivityBy_OneParameter_List = new List<double>();
            SensitivityBy_OneParameter_List.Clear();
            SensitivityBy_OneParameter_List.Add(System.Convert.ToDouble(Sorted_Critical_Situation_Charts[0, FirstUnStable, 9]));

            if (WhichArray == true)//for parameters in SequenceList Array
                for (int j = 0; j < ParameterNo; j++)
                    SensitivityBy_OneParameter_List.Add(System.Convert.ToDouble(SequenceList[i, ParNmbrs[j]]));
            if (WhichArray == false)//for parameters in MaterialDetail Array
                for (int j = 0; j < ParameterNo; j++)
                    SensitivityBy_OneParameter_List.Add(System.Convert.ToDouble(ModelDetail[ParNmbrs[j]]));
            return SensitivityBy_OneParameter_List;
        }

        private void Sensitivity_Analysis_Phi_ByFOS()
        {
            double MinRng = 0, MaxRng = 90;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if(Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                            SequenceList[Seq_counter, 9] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng)/ System.Convert.ToDouble(TotalSteps - 1));

                            SequenceList[Seq_counter, 29] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                            SequenceList[Seq_counter, 37] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                            SequenceList[Seq_counter, 47] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 4, 9, 29, 37, 47);
                }
                Draw_Calculation_Chart("φ");
            }

            /*
                        bool ReachMax = false;
                        Sensitivity_Chart.Clear();

                        for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
                        {
                            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                    SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                            for (int i = 0; i < 10; i++)
                                ModelDetail[i] = Origin_ModelDetail[i];

                            for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                            {
                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) == 0)
                                    SequenceList[Seq_counter, 9] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    SequenceList[Seq_counter, 9] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo) / 100d);

                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) == 0)
                                    SequenceList[Seq_counter, 29] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    SequenceList[Seq_counter, 29] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo) / 100d);

                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) == 0)
                                    SequenceList[Seq_counter, 37] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    SequenceList[Seq_counter, 37] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo) / 100d);

                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) == 0)
                                    SequenceList[Seq_counter, 47] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    SequenceList[Seq_counter, 47] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo) / 100d);

                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                                    System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                                    System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                                    System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                                    ReachMax = true;
                            }
                            if (ReachMax == true)
                            {
                                SolveNo = 1001;// to finish solving
                                ReachMax = false;
                            }

                            FOS_For_Sensitivity_Analysis(true, 4, 9, 29, 37, 47);
                        }
            //            Draw_Calculation_Chart();
                        */
        }

        private void Sensitivity_Analysis_Mat_Phi_ByFOS()
        {
            double MinRng = 0, MaxRng = 90;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 9] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 9, 9, 9, 9);
                }
                Draw_Calculation_Chart("φ_Mat");
            }

            /*            
                        bool ReachMax = false;
                        Sensitivity_Chart.Clear();

                        for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
                        {
                            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                    SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                            for (int i = 0; i < 10; i++)
                                ModelDetail[i] = Origin_ModelDetail[i];

                            for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                            {
                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) == 0)
                                    SequenceList[Seq_counter, 9] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    SequenceList[Seq_counter, 9] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo) / 100d);

                                if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 9]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                                    ReachMax = true;
                            }
                            if (ReachMax == true)
                            {
                                SolveNo = 1001;// to finish solving
                                ReachMax = false;
                            }

                            FOS_For_Sensitivity_Analysis(true, 1, 9, 9, 9, 9);
                        }
            //            Draw_Calculation_Chart();
            */
        }

        private void Sensitivity_Analysis_Int_Phi_ByFOS()
        {
            double MinRng = 0, MaxRng = 90;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 2, 29, 47, 29, 29);
                }
                Draw_Calculation_Chart("φ_Int");
            }

            /*
            bool ReachMax = false;
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) == 0)
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 29] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) == 0)
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 47] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 29]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90 ||
                        System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 47]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }

                FOS_For_Sensitivity_Analysis(true, 2, 29, 47, 29, 29);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Basal_Phi_ByFOS()
        {
            double MinRng = 0, MaxRng = 90;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 37, 37, 37, 37);
                }
                Draw_Calculation_Chart("φ_Basal");
            }

            /*
            bool ReachMax = false;
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) == 0)
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 37] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 37]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }

                FOS_For_Sensitivity_Analysis(true, 1, 37, 37, 37, 37);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_c_ByFOS()
        {
            double MinRng = 0, MaxRng = 10000000000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 4, 7, 27, 35, 45);
                }
                Draw_Calculation_Chart("c");
            }
            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) == 0)
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) == 0)
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) == 0)
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) == 0)
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) * System.Convert.ToDouble(SolveNo) / 100d);

                }

                FOS_For_Sensitivity_Analysis(true, 4, 7, 27, 35, 45);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Mat_c_ByFOS()
        {
            double MinRng = 0, MaxRng = 10000000000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 7, 7, 7, 7);
                }
                Draw_Calculation_Chart("c_Mat");
            }
            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) == 0)
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 7] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 7]) * System.Convert.ToDouble(SolveNo) / 100d);

                }

                FOS_For_Sensitivity_Analysis(true, 1, 7, 7, 7, 7);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Int_c_ByFOS()
        {
            double MinRng = 0, MaxRng = 10000000000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 2, 27, 45, 27, 27);
                }
                Draw_Calculation_Chart("c_Int");
            }

            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) == 0)
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 27] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 27]) * System.Convert.ToDouble(SolveNo) / 100d);

                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) == 0)
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 45] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 45]) * System.Convert.ToDouble(SolveNo) / 100d);

                }

                FOS_For_Sensitivity_Analysis(true, 2, 27, 45, 27, 27);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Basal_c_ByFOS()
        {
            double MinRng = 0, MaxRng = 10000000000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 35, 35, 35, 35);
                }
                Draw_Calculation_Chart("c_Basal");
            }

            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) == 0)
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 35] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 35]) * System.Convert.ToDouble(SolveNo) / 100d);
                }

                FOS_For_Sensitivity_Analysis(true, 1, 35, 35, 35, 35);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Basal_TensileStrength_ByFOS()
        {
            double MinRng = 0, MaxRng = 10000000000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 13] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 13, 13, 13, 13);
                }
                Draw_Calculation_Chart("σt_Basal");
            }

            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 13]) == 0)
                        SequenceList[Seq_counter, 13] = System.Convert.ToString(1000000000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 13] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 13]) * System.Convert.ToDouble(SolveNo) / 100d);
                }

                FOS_For_Sensitivity_Analysis(true, 1, 13, 13, 13, 13);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_UnitWeight_ByFOS()
        {
            double MinRng = 0, MaxRng = 100000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 11, 11, 11, 11);
                }
                Draw_Calculation_Chart("W");
            }

            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 11]) == 0)
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(10000d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 11] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 11]) * System.Convert.ToDouble(SolveNo) / 100d);
                }

                FOS_For_Sensitivity_Analysis(true, 1, 11, 11, 11, 11);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_FaseHeight_ByFOS()
        {
            double MinRng = 0.01, MaxRng = 10000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 20, 20, 20, 20);
                }
                Draw_Calculation_Chart("h");
            }

            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];


                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) == 0)
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(100d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 20] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 20]) * System.Convert.ToDouble(SolveNo) / 100d);
                }


                FOS_For_Sensitivity_Analysis(true, 1, 20, 20, 20, 20);

            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Kh_ByFOS()
        {
            double MinRng = 0.001, MaxRng = 10;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 3] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(false, 1, 3, 3, 3, 3);
                }
                Draw_Calculation_Chart("kh");
            }
            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];


                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_ModelDetail[3]) == 0)
                        ModelDetail[3] = System.Convert.ToString(1d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        ModelDetail[3] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[3]) * System.Convert.ToDouble(SolveNo) / 100d);
                }

                FOS_For_Sensitivity_Analysis(false, 1, 3, 3, 3, 3);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_Kv_ByFOS()
        {
            double MinRng = 0.001, MaxRng = 10;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 4] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(false, 1, 4, 4, 4, 4);
                }
                Draw_Calculation_Chart("kv");
            }

            /*
                        Sensitivity_Chart.Clear();

                        for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
                        {
                            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                    SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                            for (int i = 0; i < 10; i++)
                                ModelDetail[i] = Origin_ModelDetail[i];

                            for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                            {
                                if (System.Convert.ToDouble(Origin_ModelDetail[4]) == 0)
                                    ModelDetail[4] = System.Convert.ToString(1d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                                else
                                    ModelDetail[4] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[4]) * System.Convert.ToDouble(SolveNo) / 100d);
                            }

                            FOS_For_Sensitivity_Analysis(false, 1, 4, 4, 4, 4);
                        }
            //            Draw_Calculation_Chart();
            */
        }

        private void Sensitivity_Analysis_ColumnNo_ByFOS()
        {
            double MinRng = 1, MaxRng = 1000;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 21] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 21, 21, 21, 21);
                }
                Draw_Calculation_Chart("Column No.");
            }
            /*
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (Origin_SequenceList[Seq_counter, 6] == "Rock")
                    {
                        if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 21]) == 0)
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(10d * System.Convert.ToDouble(SolveNo) / 100d));//0 to 90
                        else
                            SequenceList[Seq_counter, 21] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 21]) * System.Convert.ToDouble(SolveNo) / 100d));
                        if (SequenceList[Seq_counter, 21] == "0")
                            SequenceList[Seq_counter, 21] = "1";
                    }
                }
                SliceNo = 0;
                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi value of all Sequence
                {
                    SliceNo += System.Convert.ToInt32(SequenceList[Seq_counter, 21]);
                }

                FOS_For_Sensitivity_Analysis(true, 1, 21, 21, 21, 21);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_FaceAngle_ByFOS()
        {
            double MinRng = 1, MaxRng = 89;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 19, 19, 19, 19);
                }
                Draw_Calculation_Chart("ψ_Face");
            }

            /*
            bool ReachMax = false;
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) == 0)
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 19] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 19]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }

                FOS_For_Sensitivity_Analysis(true, 1, 19, 19, 19, 19);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_ColumnAngle_ByFOS()
        {
            double MinRng = 1, MaxRng = 89;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 23, 23, 23, 23);
                }
                Draw_Calculation_Chart("ψ_Column");
            }

            /*
            bool ReachMax = false;
            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) == 0)
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(9d * System.Convert.ToDouble(SolveNo) / 100d);//0 to 90
                    else
                        SequenceList[Seq_counter, 23] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * System.Convert.ToDouble(SolveNo) / 100d);
                    if (System.Convert.ToDouble(Origin_SequenceList[Seq_counter, 23]) * System.Convert.ToDouble(SolveNo + 1) / 100d >= 90)
                        ReachMax = true;
                }
                if (ReachMax == true)
                {
                    SolveNo = 1001;// to finish solving
                    ReachMax = false;
                }

                FOS_For_Sensitivity_Analysis(true, 1, 23, 23, 23, 23);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void Sensitivity_Analysis_BasalAngle_ByFOS()
        {
            double MinRng = -40, MaxRng = 89;
            Form3 frm3 = new Form3(MinRng, MaxRng);
            frm3.ShowDialog();
            if (Export_opp == true)
            {
                MinRng = Export_FromNo;
                MaxRng = Export_ToNo;
                int TotalSteps = 0;
                if (Export_ToNo - Export_FromNo <= 1000)
                    TotalSteps = System.Convert.ToInt32(Export_ToNo - Export_FromNo) + 1;
                else
                    TotalSteps = 1000;
                Sensitivity_Chart.Clear();

                for (int SolveNo = 0; SolveNo < TotalSteps; SolveNo++)
                {
                    for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                        for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                            SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                    for (int i = 0; i < 10; i++)
                        ModelDetail[i] = Origin_ModelDetail[i];

                    for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                    {
                        SequenceList[Seq_counter, 31] = System.Convert.ToString(MinRng + System.Convert.ToDouble(SolveNo) * (MaxRng - MinRng) / System.Convert.ToDouble(TotalSteps - 1));

                    }
                    FOS_For_Sensitivity_Analysis(true, 1, 31, 31, 31, 31);
                }
                Draw_Calculation_Chart("ψ_Basal");
            }

            /*
            double Min_Basal_Angle = 0;
            double Basal_Search_Angle = 80;

            if (Origin_SequenceList[0, 6] == "Rock")
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[0, 23]) - Basal_Search_Angle / 2d;
            else if (Origin_SequenceList[SequencesNo, 6] == "Rock")
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[SequencesNo, 23]) - Basal_Search_Angle / 2d;
            else
            {
                Basal_Search_Angle = 0;
                Min_Basal_Angle = 90d - System.Convert.ToDouble(Origin_SequenceList[SequencesNo, 23]) - Basal_Search_Angle / 2d;
            }

            Sensitivity_Chart.Clear();

            for (int SolveNo = 1; SolveNo <= 1000; SolveNo++)
            {
                for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                    for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                        SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                for (int i = 0; i < 10; i++)
                    ModelDetail[i] = Origin_ModelDetail[i];

                for (int Seq_counter = 0; Seq_counter < SequencesNo; Seq_counter++)// to chang phi
                {
                    SequenceList[Seq_counter, 31] = System.Convert.ToString(Min_Basal_Angle + Basal_Search_Angle * System.Convert.ToDouble(SolveNo) / 1000d);
                }

                FOS_For_Sensitivity_Analysis(true, 1, 31, 31, 31, 31);
            }
//            Draw_Calculation_Chart();
*/
        }

        private void FOS_For_Sensitivity_Analysis(
              bool WhichArray
            , int ParameterNo
            , int Par1, int Par2, int Par3, int Par4)
        {
            string[,] temp_SequenceList = new string[SequenceList.GetLength(0), SequenceList.GetLength(1)];
            string[] temp_ModelDetail = new string[ModelDetail.GetLength(0)];

            for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                    temp_SequenceList[RowCounter, ClmCounter] = SequenceList[RowCounter, ClmCounter];

            for (int i = 0; i < 10; i++)
                temp_ModelDetail[i] = ModelDetail[i];


            SliceNo = 0;
            for (int seq_No = 0; seq_No < SequencesNo; seq_No++)
                SliceNo += System.Convert.ToInt32(SequenceList[seq_No, 21]);
            Solve_For_FOS3();

            FOS_Value = 1;
            Sensitivity_FOS_Calculation(temp_SequenceList, temp_ModelDetail);

            Sensitivity_Chart.Add(Save_one_Step_Sensitivity2(WhichArray, ParameterNo, Par1, Par2, Par3, Par4 , temp_SequenceList, temp_ModelDetail));
            Txt_Bx_ProbabilisticSolveNo.Text = System.Convert.ToString(Sensitivity_Chart.Count);
            Txt_Bx_ProbabilisticSolveNo.Refresh();

        }

        private List<List<double>> Save_one_Step_Sensitivity2
            (bool WhichArray
            , int ParameterNo
            , int Par1, int Par2, int Par3, int Par4
            , string[,] temp_SequenceList 
            , string[] temp_ModelDetail)
        {

            List<List<double>> one_Step_SensitivityBy_List = new List<List<double>>();
            one_Step_SensitivityBy_List.Clear();
            for (int i = 0; i < SequencesNo; i++)
            {
                one_Step_SensitivityBy_List.Add(Save_SensitivityBy_OneParameter2(i, WhichArray, ParameterNo, Par1, Par2, Par3, Par4 , temp_SequenceList , temp_ModelDetail));
            }
            return one_Step_SensitivityBy_List;
        }

        private List<double> Save_SensitivityBy_OneParameter2
            (int i
            , bool WhichArray
            , int ParameterNo
            , int Par1, int Par2, int Par3, int Par4
            , string[,] temp_SequenceList
            , string[] temp_ModelDetail)
        {
            int[] ParNmbrs = new int[4];
            ParNmbrs[0] = Par1;
            ParNmbrs[1] = Par2;
            ParNmbrs[2] = Par3;
            ParNmbrs[3] = Par4;
            List<double> SensitivityBy_OneParameter_List = new List<double>();
            SensitivityBy_OneParameter_List.Clear();

            SensitivityBy_OneParameter_List.Add(FOS_Value);

            if (WhichArray == true)//for parameters in SequenceList Array
                for (int j = 0; j < ParameterNo; j++)
                    SensitivityBy_OneParameter_List.Add(System.Convert.ToDouble(temp_SequenceList[i, ParNmbrs[j]]));
            if (WhichArray == false)//for parameters in MaterialDetail Array
                for (int j = 0; j < ParameterNo; j++)
                    SensitivityBy_OneParameter_List.Add(System.Convert.ToDouble(temp_ModelDetail[ParNmbrs[j]]));
            return SensitivityBy_OneParameter_List;
        }

        private void Draw_Calculation_Chart(string analysParam)
        {
            int X_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Height;//the height of drawing area
            int X_margine = 75;
            int Y_margine = 75;
            int X_Cross_No = 10;
            int Y_Cross_No = 10;
            int X_Cross = 0;
            int Y_Cross = 0;
            double X_Scale = 0;
            double Y_Scale = 0;
//            double JumpFilter = 0.1;
            int D1 = 0, D2 = 0, D3 = 0;
            double Max_X = 0, Max_Y = 0, Min_X = 0, Min_Y = 0;

            Pen Axis = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing Axis
            Pen Crossesthin = new Pen(Color.FromArgb(255, 0, 0, 0), 1);// thick pen for drawing Axis
            Pen ChartCurve = new Pen(Color.FromArgb(255, 255, 0, 0), 2);// thick pen for drawing Axis
            Font ChartFont = new Font("Arial", 12, FontStyle.Bold);
            Font ChartFont2 = new Font("Arial", 15, FontStyle.Bold);

            try
            {
                D1 = Sensitivity_Chart.Count;
                D2 = Sensitivity_Chart[0].Count;
                D3 = Sensitivity_Chart[0][0].Count;

                for (int i = 0; i < D1; i++)
                {
                    for (int j = 0; j < D2; j++)
                    {
                        if (i == 0 && j == 0)
                        {
                            Max_Y = Sensitivity_Chart[0][0][0];
                            Min_Y = Sensitivity_Chart[0][0][0];
                        }

                        else
                        {
                            if (Sensitivity_Chart[i][j][0] > Max_Y)
                            {
//                                if (i > 0)
//                                    if (Sensitivity_Chart[i][j][0] < (1d + JumpFilter) * Sensitivity_Chart[i - 1][j][0] &&
//                                       Sensitivity_Chart[i][j][0] > (1d - JumpFilter) * Sensitivity_Chart[i - 1][j][0])
                                        Max_Y = Sensitivity_Chart[i][j][0];

                            }
                            if (Sensitivity_Chart[i][j][0] < Min_Y)
                            {
//                                if (i > 0)
//                                    if (Sensitivity_Chart[i][j][0] < (1d + JumpFilter) * Sensitivity_Chart[i - 1][j][0] &&
//                                       Sensitivity_Chart[i][j][0] > (1d - JumpFilter) * Sensitivity_Chart[i - 1][j][0])
                                        Min_Y = Sensitivity_Chart[i][j][0];
                            }
                        }

                        for (int k = 1; k < D3; k++)
                        {
                            if (i == 0 && j == 0 && k == 1)
                            {
                                Max_X = Sensitivity_Chart[0][0][1];
                                Min_X = Sensitivity_Chart[0][0][1];
                            }
                            else
                            {
                                if (Sensitivity_Chart[i][j][k] > Max_X)
                                    Max_X = Sensitivity_Chart[i][j][k];
                                if (Sensitivity_Chart[i][j][k] < Min_X)
                                    Min_X = Sensitivity_Chart[i][j][k];
                            }
                        }
                    }
                }

                Point[] CurvPoints = new Point[D1];

                if ((Max_X - Min_X) == 0)
                    X_Scale = 0;
                else
                    X_Scale = System.Convert.ToDouble(X_DrawWindow - X_margine - 30) / (Max_X - Min_X);
                if ((Max_Y - Min_Y) == 0)
                    Y_Scale = 0;
                else
                    Y_Scale = System.Convert.ToDouble(Y_DrawWindow - Y_margine - 30) / (Max_Y - Min_Y);

                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                {
                    Pnl_ProbabilisticDeterminidtic_Chart.Refresh();
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLine(Axis, 10 - X_margine, 0, X_DrawWindow - X_margine - 10, 0);//X Axis
                    g.DrawLine(Axis, 0, Y_margine - 10, 0, -Y_DrawWindow + Y_margine + 10);//Y axis

                    for (int YCRS = 0; YCRS <= Y_Cross_No; YCRS++)
                    {
                        try
                        {
                            Y_Cross = System.Convert.ToInt32((Max_Y - Min_Y) * Y_Scale * System.Convert.ToDouble(YCRS) / System.Convert.ToDouble(Y_Cross_No));
                            g.DrawLine(Crossesthin, -5, -Y_Cross, 5, -Y_Cross);//Y axis
                            if ((Max_Y - Min_Y) > 0)
                                g.DrawString(ToSientific(System.Convert.ToString(Min_Y + (Max_Y - Min_Y) * System.Convert.ToDouble(YCRS) / System.Convert.ToDouble(Y_Cross_No)))
                                    , ChartFont, Brushes.Black, -X_margine, -Y_Cross - 18);
                        }
                        catch
                        {
                        }
                    }
                    if ((Max_Y - Min_Y) == 0)
                        g.DrawString(ToSientific(System.Convert.ToString((Max_Y))), ChartFont, Brushes.Black, -X_margine, -Y_Cross - 18);
                    for (int XCRS = 0; XCRS <= X_Cross_No; XCRS++)
                    {
                        X_Cross = System.Convert.ToInt32((Max_X - Min_X) * X_Scale * System.Convert.ToDouble(XCRS) / System.Convert.ToDouble(X_Cross_No));
                        g.DrawLine(Crossesthin, X_Cross, -5, X_Cross, 5);//Y axis
                        if ((Max_X - Min_X) > 0)
                        {
                            if (XCRS % 2 == 0)
                                g.DrawString(ToSientific(System.Convert.ToString(Min_X + (Max_X - Min_X) * System.Convert.ToDouble(XCRS) / System.Convert.ToDouble(X_Cross_No)))
                                    , ChartFont, Brushes.Black, X_Cross - 25, 5);
                            else
                                g.DrawString(ToSientific(System.Convert.ToString(Min_X + (Max_X - Min_X) * System.Convert.ToDouble(XCRS) / System.Convert.ToDouble(X_Cross_No)))
                                    , ChartFont, Brushes.Black, X_Cross - 25, 15);
                        }
                    }
                    if ((Max_X - Min_X) == 0)
                        g.DrawString(ToSientific(System.Convert.ToString((Max_X))), ChartFont, Brushes.Black, X_Cross - 25, 5);
                }

                for (int j = 0; j < D2; j++)
                {
                    for (int k = 1; k < D3; k++)
                    {
                        for (int i = 0; i < D1; i++)
                        {
                            try
                            {
                                CurvPoints[i].X = System.Convert.ToInt32((Sensitivity_Chart[i][j][k] - Min_X) * X_Scale);
                                CurvPoints[i].Y = System.Convert.ToInt32(-((Sensitivity_Chart[i][j][0] - Min_Y) * Y_Scale));
//                                if (i > 0)
//                                    if (Sensitivity_Chart[i][j][0] > (1d + JumpFilter) * Sensitivity_Chart[i - 1][j][0] ||
//                                       Sensitivity_Chart[i][j][0] < (1d - JumpFilter) * Sensitivity_Chart[i - 1][j][0])
//                                        CurvPoints[i].Y = CurvPoints[i - 1].Y;
                            }
                            catch
                            {

                            }
                        }
                        using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                        {
                            g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                            g.DrawCurve(ChartCurve, CurvPoints);

                            g.DrawString(analysParam, ChartFont2, Brushes.Black, X_DrawWindow - X_margine - 130, 30);
                            g.DrawString("FOS", ChartFont2, Brushes.Black, 3, -Y_DrawWindow + Y_margine + 10);
                        }
                    }
                    
                    
                }

            }
            catch
            {
                MessageBox.Show("No Unstable Model Found");

            }
        }

        private void MainForm_Activated(object sender, EventArgs e)
        {
            if (SequenceList != null)
            {
                if (Sorted_Critical_Situation_Charts != null)
                {
                    if (Sorted_Critical_Situation_Charts.GetLength(0) > 0 && RadBtnProbabilisticAnalysis.Checked == false)
                    {
                        Draw_Model();
                        try
                        {
                            Result_Visualizing(0);

                        }
                        catch
                        {

                        }
                    }
                }
            }
        }

        private void RadBtnModelDefinition_Click(object sender, EventArgs e)
        {
            Pnl_NewModel.Enabled = true;
            Pnl_ModelDefinittion.Enabled = true;
            Pnl_NewModel.Visible = true;
            Pnl_ModelDefinittion.Visible = true;

            if (SequenceList != null)
                Draw_Model();
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM"
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name]"
                + "WHERE [Model Name] = '" + ComBx_SelectModel.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_SelectSlope.BindingContext = new BindingContext();
            ComBx_SelectSlope.DataSource = dt_Slope;
            ComBx_SelectSlope.ValueMember = "Id_Slope";
            ComBx_SelectSlope.DisplayMember = "Slope Name";


        }

        private void RadBtnJointStudy_Click(object sender, EventArgs e)
        {
            if (SequenceList != null)
                Draw_Model();
        }

        private void RadBtnExternalForces_Click(object sender, EventArgs e)
        {
            Pnl_ForceDefinition.Visible = true;
            Pnl_ExternalForces.Visible = true;
            Pnl_ForceDefinition.Enabled = true;
            Pnl_ExternalForces.Enabled = true;

            if (SequenceList != null)
                Draw_Model();

            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM"
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] "
                + "WHERE [Model Name] = '" + ComBx_Model_PointLoad.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_Slope_PointLoad.BindingContext = new BindingContext();
            ComBx_Slope_PointLoad.DataSource = dt_Slope;
            ComBx_Slope_PointLoad.ValueMember = "Id_Slope";
            ComBx_Slope_PointLoad.DisplayMember = "Slope Name";


            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM"
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] "
                + "WHERE [Model Name] = '" + ComBx_Model_UniFormLoad.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_Slope_UniFormLoad.BindingContext = new BindingContext();
            ComBx_Slope_UniFormLoad.DataSource = dt_Slope;
            ComBx_Slope_UniFormLoad.ValueMember = "Id_Slope";
            ComBx_Slope_UniFormLoad.DisplayMember = "Slope Name";



        }

        private void RadBtnMaterialDefinition_Click(object sender, EventArgs e)
        {
            Pnl_MaterialInput.Enabled = true;
            Pnl_MaterialDefinition.Enabled = true;
            Pnl_MaterialInput.Visible = true;
            Pnl_MaterialDefinition.Visible = true;
            Pnl_Joint.SendToBack();
            Pnl_Kinematic.SendToBack();
            Pnl_SlopeDefinition.SendToBack();
            Pnl_ForceDefinition.SendToBack();
            Pnl_ModelDefinittion.SendToBack();


            if (SequenceList != null)
                Draw_Model();
        }

        private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            app.Quit();//to close EXCEL
            System.Runtime.InteropServices.Marshal.ReleaseComObject(app);
            probabilistic_Running = false;

        }

        private void Chk_Bx_Basal_All_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            if (Chk_Bx_Basal_All_Probabilistic.Text == "Select All")
            {
                Chk_Bx_Basal_Phi_Probabilistic.Checked = true;
                Chk_Bx_Mat_Phi_Probabilistic.Checked = true;
                Chk_Bx_Joints_Phi_Probabilistic.Checked = true;
                Chk_Bx_Int_Phi_Probabilistic.Checked = true;
                Chk_Bx_Basal_c_Probabilistic.Checked = true;
                Chk_Bx_Mat_c_Probabilistic.Checked = true;
                Chk_Bx_Joints_c_Probabilistic.Checked = true;
                Chk_Bx_Int_c_Probabilistic.Checked = true;
                Chk_Bx_Tensile_Probabilistic.Checked = true;
                Chk_Bx_UnitWeight_Probabilistic.Checked = true;
                Chk_Bx_Kh_Probabilistic.Checked = true;
                Chk_Bx_Kv_Probabilistic.Checked = true;
                Chk_Bx_ClmnNo_Probabilistic.Checked = true;
                Chk_Bx_ClmnAng_Probabilistic.Checked = true;
                Chk_Bx_BasalAng_Probabilistic.Checked = true;
                Chk_Bx_Blockiness_Probabilistic.Checked = true;
                Chk_Bx_WaterLevel_Probabilistic.Checked = true;
                Chk_Bx_WaterAng_Probabilistic.Checked = true;
                Chk_Bx_Basal_All_Probabilistic.Text = "Deselect All";
            }
            else
            {
                Chk_Bx_Basal_Phi_Probabilistic.Checked = false;
                Chk_Bx_Mat_Phi_Probabilistic.Checked = false;
                Chk_Bx_Joints_Phi_Probabilistic.Checked = false;
                Chk_Bx_Int_Phi_Probabilistic.Checked = false;
                Chk_Bx_Basal_c_Probabilistic.Checked = false;
                Chk_Bx_Mat_c_Probabilistic.Checked = false;
                Chk_Bx_Joints_c_Probabilistic.Checked = false;
                Chk_Bx_Int_c_Probabilistic.Checked = false;
                Chk_Bx_Tensile_Probabilistic.Checked = false;
                Chk_Bx_UnitWeight_Probabilistic.Checked = false;
                Chk_Bx_Kh_Probabilistic.Checked = false;
                Chk_Bx_Kv_Probabilistic.Checked = false;
                Chk_Bx_ClmnNo_Probabilistic.Checked = false;
                Chk_Bx_ClmnAng_Probabilistic.Checked = false;
                Chk_Bx_BasalAng_Probabilistic.Checked = false;
                Chk_Bx_Blockiness_Probabilistic.Checked = false;
                Chk_Bx_WaterLevel_Probabilistic.Checked = false;
                Chk_Bx_WaterAng_Probabilistic.Checked = false;
                Chk_Bx_Basal_All_Probabilistic.Text = "Select All";
            }
        }

        private void Select_Deselect()
        {
            if (Chk_Bx_Basal_Phi_Probabilistic.Checked == true &&
                Chk_Bx_Mat_Phi_Probabilistic.Checked == true &&
                Chk_Bx_Joints_Phi_Probabilistic.Checked == true &&
                Chk_Bx_Int_Phi_Probabilistic.Checked == true &&
                Chk_Bx_Basal_c_Probabilistic.Checked == true &&
                Chk_Bx_Mat_c_Probabilistic.Checked == true &&
                Chk_Bx_Joints_c_Probabilistic.Checked == true &&
                Chk_Bx_Int_c_Probabilistic.Checked == true &&
                Chk_Bx_Tensile_Probabilistic.Checked == true &&
                Chk_Bx_UnitWeight_Probabilistic.Checked == true &&
                Chk_Bx_Kh_Probabilistic.Checked == true &&
                Chk_Bx_Kv_Probabilistic.Checked == true &&
                Chk_Bx_ClmnNo_Probabilistic.Checked == true &&
                Chk_Bx_ClmnAng_Probabilistic.Checked == true &&
                Chk_Bx_BasalAng_Probabilistic.Checked == true &&
                Chk_Bx_Blockiness_Probabilistic.Checked == true &&
                Chk_Bx_WaterLevel_Probabilistic.Checked == true &&
                Chk_Bx_WaterAng_Probabilistic.Checked == true)
                {
                    Chk_Bx_Basal_All_Probabilistic.Text = "Deselect All";
                }
            else
                Chk_Bx_Basal_All_Probabilistic.Text = "Select All";

        }

        private void ComBx_JointCohesiveStrength_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_JointCohesiveStrength_Dist.SelectedItem) != "K")
            {
                Lbl_JointCohesiveStrength_Dev.Visible = false;
                TxtBx_JointCohesiveStrength_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_JointCohesiveStrength_Dev.Text = "0";
            }
            else
            {
                Lbl_JointCohesiveStrength_Dev.Visible = true;
                TxtBx_JointCohesiveStrength_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_JointCohesiveStrength_Dev.Text = "";
            }
        }

        private void ComBx_JointFrictionAngle_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_JointFrictionAngle_Dist.SelectedItem) != "K")
            {
                Lbl_JointFrictionAngle_Dev.Visible = false;
                TxtBx_JointFrictionAngle_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_JointFrictionAngle_Dev.Text = "0";
            }
            else
            {
                Lbl_JointFrictionAngle_Dev.Visible = true;
                TxtBx_JointFrictionAngle_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_JointFrictionAngle_Dev.Text = "";
            }
        }

        private void ComBx_FaceColumnNo_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_FaceColumnNo_Dist.SelectedItem) != "K")
            {
                Lbl_FaceColumnNo_Dev.Visible = false;
                TxtBx_FaceColumnNo_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_FaceColumnNo_Dev.Text = "0";

            }
            else
            {
                Lbl_FaceColumnNo_Dev.Visible = true;
                TxtBx_FaceColumnNo_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_FaceColumnNo_Dev.Text = "";

            }
        }

        private void ComBx_ColumnAngle_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_ColumnAngle_Dist.SelectedItem) != "K")
            {
                Lbl_ColumnAngle_Dev.Visible = false;
                TxtBx_ColumnAngle_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_ColumnAngle_Dev.Text = "0";
            }
            else
            {
                Lbl_ColumnAngle_Dev.Visible = true;
                TxtBx_ColumnAngle_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_ColumnAngle_Dev.Text = "";

            }
        }

        private void ComBx_BasalPlaneAngle_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_BasalPlaneAngle_Dist.SelectedItem) != "K")
            {
                Lbl_BasalPlaneAngle_Dev.Visible = false;
                TxtBx_BasalPlaneAngle_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_BasalPlaneAngle_Dev.Text = "0";
            }
            else
            {
                Lbl_BasalPlaneAngle_Dev.Visible = true;
                TxtBx_BasalPlaneAngle_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_BasalPlaneAngle_Dev.Text = "";
            }

        }

        private void ComBx_TopWaterLevel_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_TopWaterLevel_Dist.SelectedItem) != "K")
            {
                Lbl_TopWaterLevel_Dev.Visible = false;
                TxtBx_TopWaterLevel_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_TopWaterLevel_Dev.Text = "0";
            }
            else
            {
                Lbl_TopWaterLevel_Dev.Visible = true;
                TxtBx_TopWaterLevel_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_TopWaterLevel_Dev.Text = "";
            }
        }

        private void ComBx_WaterLevelAngle_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_WaterLevelAngle_Dist.SelectedItem) != "K")
            {
                Lbl_WaterLevelAngle_Dev.Visible = false;
                TxtBx_WaterLevelAngle_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_WaterLevelAngle_Dev.Text = "0";
            }
            else
            {
                Lbl_WaterLevelAngle_Dev.Visible = true;
                TxtBx_WaterLevelAngle_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_WaterLevelAngle_Dev.Text = "";
            }
        }

        private void ComBx_ColumnBlockyness_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_ColumnBlockyness_Dist.SelectedItem) != "K")
            {
                Lbl_ColumnBlockyness_Dev.Visible = false;
                TxtBx_ColumnBlockyness_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_ColumnBlockyness_Dev.Text = "0";
            }
            else
            {
                Lbl_ColumnBlockyness_Dev.Visible = true;
                TxtBx_ColumnBlockyness_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_ColumnBlockyness_Dev.Text = "";
            }
        }

        private void ComBx_CohesiveStrength_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_CohesiveStrength_Dist.SelectedItem) != "K")
            {
                Lbl_CohesiveStrength_Dev.Visible = false;
                TxtBx_CohesiveStrength_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_CohesiveStrength_Dev.Text = "0";
            }
            else
            {
                Lbl_CohesiveStrength_Dev.Visible = true;
                TxtBx_CohesiveStrength_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_CohesiveStrength_Dev.Text = "";
            }
        }

        private void ComBx_FrictionAngle_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_FrictionAngle_Dist.SelectedItem) != "K")
            {
                Lbl_FrictionAngle_Dev.Visible = false;
                TxtBx_FrictionAngle_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_FrictionAngle_Dev.Text = "0";
            }
            else
            {
                Lbl_FrictionAngle_Dev.Visible = true;
                TxtBx_FrictionAngle_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_FrictionAngle_Dev.Text = "";
            }
        }

        private void ComBx_UnitWeight_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_UnitWeight_Dist.SelectedItem) != "K")
            {
                Lbl_UnitWeight_Dev.Visible = false;
                TxtBx_UnitWeight_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_UnitWeight_Dev.Text = "0";
            }
            else
            {
                Lbl_UnitWeight_Dev.Visible = true;
                TxtBx_UnitWeight_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_UnitWeight_Dev.Text = "";
            }
        }

        private void ComBx_TensileStrength_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_TensileStrength_Dist.SelectedItem) != "K")
            {
                Lbl_TensileStrength_Dev.Visible = false;
                TxtBx_TensileStrength_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_TensileStrength_Dev.Text = "0";
            }
            else
            {
                Lbl_TensileStrength_Dev.Visible = true;
                TxtBx_TensileStrength_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_TensileStrength_Dev.Text = "";
            }
        }

        private void ComBx_HorizontalAcceleration_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_HorizontalAcceleration_Dist.SelectedItem) != "K")
            {
                Lbl_HorizontalAcceleration_Dev.Visible = false;
                TxtBx_HorizontalAcceleration_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_HorizontalAcceleration_Dev.Text = "0";
            }
            else
            {
                Lbl_HorizontalAcceleration_Dev.Visible = true;
                TxtBx_HorizontalAcceleration_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_HorizontalAcceleration_Dev.Text = "";
            }
        }

        private void ComBx_VerticalAcceleration_Dist_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) == "Exact Value" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Uniform" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Normal" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "Log Normal" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "T Student" &&
               System.Convert.ToString(ComBx_VerticalAcceleration_Dist.SelectedItem) != "K")
            {
                Lbl_VerticalAcceleration_Dev.Visible = false;
                TxtBx_VerticalAcceleration_Dev.Visible = false;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_VerticalAcceleration_Dev.Text = "0";
            }
            else
            {
                Lbl_VerticalAcceleration_Dev.Visible = true;
                TxtBx_VerticalAcceleration_Dev.Visible = true;
                if (RadBtnDatabaseView.Checked == false)
                    TxtBx_VerticalAcceleration_Dev.Text = "";
            }
        }

        private void Num_UpDwn_CriticalNo_ValueChanged(object sender, EventArgs e)
        {
            if (Num_UpDwn_CriticalNo.Enabled == true)
            {
                DGVAnalytical_Output.Rows.Clear();//reset master output grid
                DGVAnalytical_Output.DataSource = null;
                DGVAnalytical_Report.Rows.Clear();// reset report grid
                DGVAnalytical_Report.DataSource = null;
                DGVAnalytical_Report.Rows.Add();
                //                if (RadBtnAnalyticalSolution.Checked == true)
                    Pnl_ModelDraw.Refresh();
                    Draw_Model();
//                if (Submit_Flag == true)
//                {
//                }
                Update_Result_DGV(System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value) - 1);
                Result_Visualizing(System.Convert.ToInt32(Num_UpDwn_CriticalNo.Value) - 1);
            }
        }

        private void Rad_Btn_Start_Probabilistic_Click(object sender, EventArgs e)
        {
            string hh = "", mm = "", ss = "";
            string ErrorTXT = "";

            Lbl_ElpsTime.Visible = true;

            if (Rad_Btn_Phi.Checked == false &&
                Rad_Btn_Phi_B.Checked == false &&
                Rad_Btn_Phi_Mat.Checked == false &&
                Rad_Btn_Phi_Int.Checked == false &&
                Rad_Btn_Tensile.Checked == false &&
                Rad_Btn_C.Checked == false &&
                Rad_Btn_C_B.Checked == false &&
                Rad_Btn_C_Mat.Checked == false &&
                Rad_Btn_C_Int.Checked == false &&
                Rad_Btn_Unit_Weight.Checked == false &&
                Rad_Btn_Kh.Checked == false &&
                Rad_Btn_Kv.Checked == false &&
                Rad_Btn_Kh_Kv.Checked == false &&
                Rad_Btn_ColumnNo.Checked == false &&
                Rad_Btn_Face_Height.Checked == false &&
                Rad_Btn_Say_Face.Checked == false &&
                Rad_Btn_Column_Angle.Checked == false &&
                Rad_Btn_Say_Base.Checked == false &&
                Rad_Btn_Shear.Checked == false &&
                Rad_Btn_Reserve.Checked == false &&
                Rad_Btn_Buckling.Checked == false &&
                Rad_Btn_III.Checked == false)
            {
                ////////////////for Article
                if (ModelDetail[7] == "Soil")
                {
                    Rad_Btn_Shear.Checked = true;
                }
                else
                {
                    Rad_Btn_Phi.Checked = true;
                }
                ////////////////for Article

                //                ErrorTXT += "\n One of Determinidtic FOS Calculation Ways Should Be Selected";
                //                Rad_Btn_End_Probabilistic.Checked = true;
            }
            if (Chk_Bx_Basal_Phi_Probabilistic.Checked == false &&
                Chk_Bx_Mat_Phi_Probabilistic.Checked == false &&
                Chk_Bx_Joints_Phi_Probabilistic.Checked == false &&
                Chk_Bx_Int_Phi_Probabilistic.Checked == false &&
                Chk_Bx_Basal_c_Probabilistic.Checked == false &&
                Chk_Bx_Mat_c_Probabilistic.Checked == false &&
                Chk_Bx_Joints_c_Probabilistic.Checked == false &&
                Chk_Bx_Int_c_Probabilistic.Checked == false &&
                Chk_Bx_Tensile_Probabilistic.Checked == false &&
                Chk_Bx_UnitWeight_Probabilistic.Checked == false &&
                Chk_Bx_Kh_Probabilistic.Checked == false &&
                Chk_Bx_ClmnNo_Probabilistic.Checked == false &&
                Chk_Bx_BasalAng_Probabilistic.Checked == false &&
                Chk_Bx_Blockiness_Probabilistic.Checked == false &&
                Chk_Bx_Kv_Probabilistic.Checked == false &&
                Chk_Bx_ClmnAng_Probabilistic.Checked == false &&
                Chk_Bx_WaterLevel_Probabilistic.Checked == false &&
                Chk_Bx_WaterAng_Probabilistic.Checked == false)
            {
                ErrorTXT += "\n at least Select one variable for Probabilistic Analysis";
                Rad_Btn_End_Probabilistic.Checked = true;
            }
            else
            {
                int MaxProbabilitySolve = 1000;
                int StableCount = 0;
                probabilistic_Running = true;
                Probability_FOS.Clear();

                Probabilistic_SequenceList.Clear();
                Probabilistic_ModelDetail.Clear();

                StartTime = DateTime.Now;//store Start Time

                new Thread(() =>
                {
                    Rad_Btn_Start_Probabilistic.Invoke(new MethodInvoker(delegate {
                        Rad_Btn_Start_Probabilistic.Text = "Probabilistic FOS Analysis is Running";
                        Rad_Btn_Start_Probabilistic.Refresh();
                    }));
                    Pnl_Deterministic.Invoke(new MethodInvoker(delegate {
                        Pnl_Deterministic.Enabled = false;
                    }));
                    Pnl_Sensitivity.Invoke(new MethodInvoker(delegate {
                        Pnl_Sensitivity.Enabled = false;
                    }));
                    Pnl_MainMenu.Invoke(new MethodInvoker(delegate {
                        Pnl_MainMenu.Enabled = false;
                    }));
                    Pnl_Probabilistic_item.Invoke(new MethodInvoker(delegate {
                        Pnl_Probabilistic_item.Enabled = false;
                    }));

                    if(ModelDetail[7] == "Rock")
                    {
                        Exact_Surfase = true;
                    }


                    Solve_For_FOS3();

                    for (int ProbabilitySolveNo = 1; ProbabilitySolveNo <= MaxProbabilitySolve; ProbabilitySolveNo++)
                    {
                        for (int RowCounter = 0; RowCounter < SequencesNo; RowCounter++)
                            for (int ClmCounter = 0; ClmCounter < 67; ClmCounter++)
                                SequenceList[RowCounter, ClmCounter] = Origin_SequenceList[RowCounter, ClmCounter];

                        for (int i = 0; i < 10; i++)
                            ModelDetail[i] = Origin_ModelDetail[i];

                        FOS_Value = 1;

                        GenerateRandomModel();

                        SliceNo = 0;
                        for (int seq_No = 0; seq_No < SequencesNo; seq_No++)
                            SliceNo += System.Convert.ToInt32(SequenceList[seq_No, 21]);
                        if (ModelDetail[7] == "Rock")
                        {
                            Exact_Surfase = true;
                        }
                        Solve_For_FOS3();

                        Probabilistic_ModelDetail.Add(SaveModelDetail());
                        Probabilistic_SequenceList.Add(SaveSeqList());

                        if(ModelDetail[7] == "Soil")
                        {
                            Probability_FOS.Add(Sorted_All_Slip_Surfase_FOS[0]);
                        }
                        else
                        {
                            Deterministic_FOS_Calculation();
                            Probability_FOS.Add(FOS_Value);
                        }

                        if (FOS_Value >= 1)
                            StableCount++;

                        Draw_Statistical_Chart();

                        Generate_Probabilistic_Report();


                        try
                        {
                            NowTime = DateTime.Now;
                            EllapsedTime = NowTime.Subtract(StartTime);
                            hh = System.Convert.ToString(EllapsedTime.Hours);
                            mm = System.Convert.ToString(EllapsedTime.Minutes);
                            ss = System.Convert.ToString(EllapsedTime.Seconds);
                            if (System.Convert.ToInt32(hh) < 10)
                                hh = "0" + hh;
                            if (System.Convert.ToInt32(mm) < 10)
                                mm = "0" + mm;
                            if (System.Convert.ToInt32(ss) < 10)
                                ss = "0" + ss;

                            Lbl_ElpsTime.Invoke(new MethodInvoker(delegate {
                                Lbl_ElpsTime.Text = "Elapsed Time: " + hh + ":" + mm + ":" + ss;
                            }));
                            TxtBx_ProbabilisticSolveNo.Invoke(new MethodInvoker(delegate {
                                TxtBx_ProbabilisticSolveNo.Text = System.Convert.ToString(ProbabilitySolveNo);
                                TxtBx_ProbabilisticSolveNo.Refresh();

                            }));
                            TxtBx_Probabilistic_FOS.Invoke(new MethodInvoker(delegate {
                                if (ModelDetail[7] == "Soil")
                                {
                                    if (Sorted_All_Slip_Surfase_FOS[0] >= 1)
                                        TxtBx_Probabilistic_FOS.ForeColor = Color.FromArgb(255, 0, 255, 0);
                                    else
                                        TxtBx_Probabilistic_FOS.ForeColor = Color.FromArgb(255, 255, 0, 0);
                                    TxtBx_Probabilistic_FOS.Text = System.Convert.ToString(Sorted_All_Slip_Surfase_FOS[0]);
                                    TxtBx_Probabilistic_FOS.Refresh();
                                }
                                else
                                {
                                    if (FOS_Value >= 1)
                                        TxtBx_Probabilistic_FOS.ForeColor = Color.FromArgb(255, 0, 255, 0);
                                    else
                                        TxtBx_Probabilistic_FOS.ForeColor = Color.FromArgb(255, 255, 0, 0);
                                    TxtBx_Probabilistic_FOS.Text = System.Convert.ToString(FOS_Value);
                                    TxtBx_Probabilistic_FOS.Refresh();
                                }

                            }));
                        }
                        catch
                        {
                        }
                        End_Recognizer(ProbabilitySolveNo);

                        if (probabilistic_Running == false)
                            ProbabilitySolveNo = MaxProbabilitySolve + 1;

                    }
                    try
                    {
                        Rad_Btn_Start_Probabilistic.Invoke(new MethodInvoker(delegate {
                            Rad_Btn_Start_Probabilistic.Text = "START Probabilistic FOS Analysis";
                        }));
                        Rad_Btn_Start_Probabilistic.Invoke(new MethodInvoker(delegate {
                            Rad_Btn_Start_Probabilistic.Refresh();
                        }));
                        Pnl_Deterministic.Invoke(new MethodInvoker(delegate {
                            Pnl_Deterministic.Enabled = true;
                        }));
                        Pnl_Sensitivity.Invoke(new MethodInvoker(delegate {
                            Pnl_Sensitivity.Enabled = true;
                        }));
                        Pnl_MainMenu.Invoke(new MethodInvoker(delegate {
                            Pnl_MainMenu.Enabled = true;
                        }));
                        Pnl_Probabilistic_item.Invoke(new MethodInvoker(delegate {
                            Pnl_Probabilistic_item.Enabled = true;
                        }));
                        Rad_Btn_End_Probabilistic.Invoke(new MethodInvoker(delegate {
                            Rad_Btn_End_Probabilistic.Checked = true;
                        }));
                    }
                    catch
                    {

                    }

                    MessageBox.Show("Probabilistic Analysis Completed");

                }).Start();
            }
            if (ErrorTXT != "")
            {
                MessageBox.Show(ErrorTXT);
            }
        }

        private void End_Recognizer(int Try_Nmbr)
        {
            double Sum_Av = 0, Sum_Dev = 0;
            double Dev_Aver = 0, Dev_Dev = 0;
            for (int i = End_Prob_Calc.GetLength(1) - 1; i > 0; i--)
            {
                End_Prob_Calc[0, i] = End_Prob_Calc[0, i - 1];
                End_Prob_Calc[1, i] = End_Prob_Calc[1, i - 1];
                Sum_Av += End_Prob_Calc[0, i];
                Sum_Dev += End_Prob_Calc[1, i];
            }
            End_Prob_Calc[0, 0] = Probabilistic_Report[2];//Average FOS
            End_Prob_Calc[1, 0] = Probabilistic_Report[4];//Deviation FOS
            Sum_Av += End_Prob_Calc[0, 0];
            Sum_Dev += End_Prob_Calc[1, 0];
            Sum_Av = Sum_Av / System.Convert.ToDouble(End_Prob_Calc.GetLength(1));//Average of average
            Sum_Dev = Sum_Dev / System.Convert.ToDouble(End_Prob_Calc.GetLength(1));//Average of Deviation

            for (int i = 0; i < End_Prob_Calc.GetLength(1); i++)
            {
                Dev_Aver = Math.Pow(End_Prob_Calc[0, i] - Sum_Av, 2);
                Dev_Dev = Math.Pow(End_Prob_Calc[1, i] - Sum_Dev, 2);
            }
            Dev_Aver = Math.Sqrt(Dev_Aver / System.Convert.ToDouble(End_Prob_Calc.GetLength(1)));//Average of average
            Dev_Dev = Math.Sqrt(Dev_Dev / System.Convert.ToDouble(End_Prob_Calc.GetLength(1)));//Average of Deviation

            /*            TEST_Prob_Calc[0, Try_Nmbr - 1] = Probabilistic_Report[2];
                        TEST_Prob_Calc[1, Try_Nmbr - 1] = Probabilistic_Report[4];

                        TEST_Prob_Calc[2, Try_Nmbr - 1] = Dev_Aver;
                        TEST_Prob_Calc[3, Try_Nmbr - 1] = Dev_Dev;
            */
            if (Dev_Aver < 0.0002 && Dev_Dev < 0.0002 && Try_Nmbr > End_Prob_Calc.GetLength(1))
                end_Reach++;
            else
                end_Reach = 0;
            if (end_Reach == 10)
                probabilistic_Running = false;
        }

        private void Generate_Probabilistic_Report()
        {
            int D1 = 0;
            int Stable_Counter = 0;
            double FOS_Sum = 0;
            D1 = Probability_FOS.Count;
            List<double> Soreted_FOS = new List<double>();
            int L95 = 0, U95 = 0, L90 = 0, U90 = 0;

            for (int i = 0; i < D1; i++)
                FOS_Sum += Probability_FOS[i];
            Probabilistic_Report[2] = FOS_Sum / System.Convert.ToInt32(D1);//FOS Average
            FOS_Sum = 0;
            for (int i = 0; i < D1; i++)
            {
                FOS_Sum += Math.Pow(Probability_FOS[i] - Probabilistic_Report[2], 2);
                if (Probability_FOS[i] >= 1)
                    Stable_Counter++;
            }
            Probabilistic_Report[4] = Math.Sqrt(FOS_Sum / System.Convert.ToInt32(D1));//FOS Deviation
            Probabilistic_Report[9] = Stable_Counter;//Number of Stable Model found
            Probabilistic_Report[10] = 100d * System.Convert.ToDouble(Stable_Counter) / System.Convert.ToDouble(D1);///Persent of Stable Model
            D1 = Probability_FOS.Count;
            Soreted_FOS.Clear();
            for (int i = 0; i < D1; i++)
            {
                FOS_Sum += Math.Pow(Probability_FOS[i] - Probabilistic_Report[2], 2);
                if (Probability_FOS[i] >= 1)
                    Stable_Counter++;
                Soreted_FOS.Add(Probability_FOS[i]);
            }
            Soreted_FOS.Sort();
            try
            {
                DGVProbabilisticResult.Invoke(new MethodInvoker(delegate {
                    DGVProbabilisticResult.Visible = true;

                    L95 = System.Convert.ToInt32(System.Convert.ToDouble(D1) * 0.025d);
                    U95 = System.Convert.ToInt32(System.Convert.ToDouble(D1) * 0.975d);
                    L90 = System.Convert.ToInt32(System.Convert.ToDouble(D1) * 0.050d);
                    U90 = System.Convert.ToInt32(System.Convert.ToDouble(D1) * 0.950d);
                    if (U95 >= D1)
                        U95--;
                    if (U90 >= D1)
                        U90--;

                    DGVProbabilisticResult.Rows.Clear();
                    DGVProbabilisticResult.Rows.Add();
                    Probabilistic_Report[5] = Soreted_FOS[L95];
                    Probabilistic_Report[6] = Soreted_FOS[U95];
                    Probabilistic_Report[7] = Soreted_FOS[L90];
                    Probabilistic_Report[8] = Soreted_FOS[U90];

                    DGVProbabilisticResult.Rows[0].Cells[0].Value = Probabilistic_Report[0];//Min FOS
                    if (Probabilistic_Report[0] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[0].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[0].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[1].Value = Probabilistic_Report[1];//Max FOS
                    if (Probabilistic_Report[1] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[1].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[1].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[2].Value = Probabilistic_Report[2];//Average FOS
                    if (Probabilistic_Report[2] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[2].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[2].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    //                    DGVProbabilisticResult.Rows[0].Cells[3].Value = Probabilistic_Report[3];//Expected FOS Value
                    DGVProbabilisticResult.Rows[0].Cells[3].Value = Probabilistic_Report[4];//Deviation
                    DGVProbabilisticResult.Rows[0].Cells[4].Value = Probabilistic_Report[5];//95Lower
                    if (Probabilistic_Report[5] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[4].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[4].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[5].Value = Probabilistic_Report[6];//95Upper
                    if (Probabilistic_Report[6] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[5].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[5].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[6].Value = Probabilistic_Report[7];//90Lower
                    if (Probabilistic_Report[7] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[6].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[6].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[7].Value = Probabilistic_Report[8];//90Upper
                    if (Probabilistic_Report[8] >= 1)
                        DGVProbabilisticResult.Rows[0].Cells[7].Style.BackColor = Color.FromArgb(255, 155, 255, 155);
                    else
                        DGVProbabilisticResult.Rows[0].Cells[7].Style.BackColor = Color.FromArgb(255, 255, 155, 155);

                    DGVProbabilisticResult.Rows[0].Cells[8].Value = Probabilistic_Report[9];//Stabled No
                    DGVProbabilisticResult.Rows[0].Cells[9].Value = System.Convert.ToString(Math.Round(Probabilistic_Report[10], 2)) + "%";//Stabled %
                        DGVProbabilisticResult.Rows[0].Cells[9].Style.BackColor = Color.FromArgb(255, 155, 255, 155);

                    DGVProbabilisticResult.Rows[0].Cells[10].Value = System.Convert.ToString(Math.Round(100d - Probabilistic_Report[10], 2)) + "%";//Stabled %
                        DGVProbabilisticResult.Rows[0].Cells[10].Style.BackColor = Color.FromArgb(255, 255, 155, 155);
                }));

            }
            catch
            {

            }
        }

        private void Draw_Statistical_Chart()
        {
            int X_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Width;//the width of drawing area
            int Y_DrawWindow = Pnl_ProbabilisticDeterminidtic_Chart.Size.Height;//the height of drawing area
            int X_margine = 50;
            int Y_margine = 50;
            int Y_Cross_No = 10;
            int Max_Y_Cross = 0;
            int X_Cross = 0;
            int Y_Cross = 0;
            double X_Scale = 0;
            double Y_Scale = 0;
            //            double JumpFilter = 0.1;
            int D1 = 0;
            int ClusterNo = 20;
            int[] Cluster_Frequency = new int[ClusterNo];
            double[] Cluster_Bound = new double[ClusterNo + 1];

            double Min_X = 0, Max_X = 0, Max_Ferq = 0; ;

            Pen Axis = new Pen(Color.FromArgb(255, 0, 0, 0), 3);// thick pen for drawing Axis
            Pen Crossesthin = new Pen(Color.FromArgb(255, 0, 0, 0), 1);// thick pen for drawing Axis
            Pen ChartCurve = new Pen(Color.FromArgb(255, 255, 0, 0), 2);// thick pen for drawing Axis
            Pen BarsPen = new Pen(Color.FromArgb(255, 0, 0, 255), 2);// thick pen for drawing Axis
            Font ChartFont = new Font("Arial", 8, FontStyle.Bold);
            Font BarFont = new Font("Arial", 12, FontStyle.Bold);


            D1 = Probability_FOS.Count;

            for (int i = 0; i < D1; i++)//find max and min of FOS
            {
                if (i == 0)
                {
                    Max_X = Probability_FOS[i];
                    Min_X = Probability_FOS[i];
                }
                else
                {
                    if (Probability_FOS[i] > Max_X)
                        Max_X = Probability_FOS[i];
                    if (Probability_FOS[i] < Min_X)
                        Min_X = Probability_FOS[i];
                }
            }

            Probabilistic_Report[0] = Min_X;//min of FOS
            Probabilistic_Report[1] = Max_X;//Max of FOS

            for (int i = 0; i <= ClusterNo; i++)//Set Boundaries
            {
                Cluster_Bound[i] = Min_X + System.Convert.ToDouble(i) * ((Max_X - Min_X) / System.Convert.ToDouble(ClusterNo));
            }

            for (int i = 0; i < D1; i++)//Clustring
            {
                for (int j = 0; j < ClusterNo; j++)
                {
                    if (Probability_FOS[i] <= Cluster_Bound[j + 1])
                    {
                        Cluster_Frequency[j]++;
                        j = ClusterNo + 1;
                    }
                }
            }

            for (int i = 0; i < ClusterNo; i++)//find max Ferequency of FOS in clusters
            {
                if (i == 0)
                {
                    Max_Ferq = Cluster_Frequency[i];
                }
                else
                {
                    if (Cluster_Frequency[i] > Max_Ferq)
                        Max_Ferq = Cluster_Frequency[i];
                }
            }


            if ((Max_X - Min_X) == 0)
                X_Scale = 0;
            else
                X_Scale = System.Convert.ToDouble(X_DrawWindow - X_margine - 30) / (Max_X - Min_X);


            if (Max_Ferq == 0)
                Y_Scale = 0;
            else
                Y_Scale = System.Convert.ToDouble(Y_DrawWindow - Y_margine - 30 - 70) / Max_Ferq;
            try
            {
                using (Graphics g = Pnl_ProbabilisticDeterminidtic_Chart.CreateGraphics())//draw Model in it's panel
                {

                    Pnl_ProbabilisticDeterminidtic_Chart.Invoke(new MethodInvoker(delegate {
                        Pnl_ProbabilisticDeterminidtic_Chart.Refresh();
                    }));
                    g.TranslateTransform(X_margine, Y_DrawWindow - Y_margine); // to Move center of coordination System
                    g.DrawLine(Axis, 10 - X_margine, 0, X_DrawWindow - X_margine - 10, 0);//X Axis
                    g.DrawLine(Axis, 0, Y_margine - 10, 0, -Y_DrawWindow + Y_margine + 10);//Y axis

                    Max_Y_Cross = System.Convert.ToInt32((Max_Ferq + 10) / 10);



                    for (int YCRS = 0; YCRS <= Y_Cross_No; YCRS++)
                    {
                        Y_Cross = System.Convert.ToInt16(Y_Scale * System.Convert.ToDouble(Max_Y_Cross * YCRS));
                        if (Y_Cross <= Y_DrawWindow - Y_margine - 10)
                        {
                            g.DrawLine(Crossesthin, -5, -Y_Cross, 5, -Y_Cross);//Y axis
                            if (Max_Ferq > 0)
                                g.DrawString(System.Convert.ToString(System.Convert.ToInt32(Max_Y_Cross * System.Convert.ToDouble(YCRS)))
                                    , ChartFont, Brushes.Black, 20 - X_margine, -Y_Cross - 15);
                        }

                    }
                    if (Max_Ferq == 0)
                        g.DrawString(System.Convert.ToString((Max_Ferq)), ChartFont, Brushes.Black, 20 - X_margine, -Y_Cross - 15);



                    for (int XCRS = 0; XCRS <= ClusterNo; XCRS++)
                    {
                        X_Cross = System.Convert.ToInt16((Cluster_Bound[XCRS] - Cluster_Bound[0]) * X_Scale);
                        g.DrawLine(Crossesthin, X_Cross, -5, X_Cross, 5);//Y axis
                        if ((Max_X - Min_X) > 0)
                        {
                            if (XCRS % 2 == 0)
                            {
                                g.DrawString(System.Convert.ToString(Math.Round(Cluster_Bound[XCRS],3))
                                    , ChartFont, Brushes.Black, X_Cross - 25, 5);

                            }
                            else
                                g.DrawString(System.Convert.ToString(Math.Round(Cluster_Bound[XCRS],3))
                                    , ChartFont, Brushes.Black, X_Cross - 25, 15);
                        }
                    }

                    g.DrawString("FOS", ChartFont, Brushes.Black, X_DrawWindow - X_margine - 30, 20);
                    g.DrawString("Frequency", ChartFont, Brushes.Black, 5, -Y_DrawWindow + Y_margine);

                    if ((Max_X - Min_X) == 0)
                        g.DrawString(System.Convert.ToString((Max_X)), ChartFont, Brushes.Black, X_Cross - 25, 5);

                    for (int i = 0; i < ClusterNo; i++)
                    {
                        if(Math.Round(Cluster_Bound[i],3)>=1)
                            g.FillRectangle(Brushes.Green,
                                System.Convert.ToInt32((Cluster_Bound[i] - Cluster_Bound[0]) * X_Scale),
                                System.Convert.ToInt32(-Cluster_Frequency[i] * Y_Scale),
                                System.Convert.ToInt32((Cluster_Bound[i + 1] - Cluster_Bound[i]) * X_Scale),
                                System.Convert.ToInt32(Cluster_Frequency[i] * Y_Scale));
                        else
                            g.FillRectangle(Brushes.Red,
                                System.Convert.ToInt32((Cluster_Bound[i] - Cluster_Bound[0]) * X_Scale),
                                System.Convert.ToInt32(-Cluster_Frequency[i] * Y_Scale),
                                System.Convert.ToInt32((Cluster_Bound[i + 1] - Cluster_Bound[i]) * X_Scale),
                                System.Convert.ToInt32(Cluster_Frequency[i] * Y_Scale));

                        g.DrawRectangle(Crossesthin,
                            System.Convert.ToInt32((Cluster_Bound[i] - Cluster_Bound[0]) * X_Scale),
                            System.Convert.ToInt32(-Cluster_Frequency[i] * Y_Scale),
                            System.Convert.ToInt32((Cluster_Bound[i + 1] - Cluster_Bound[i]) * X_Scale),
                            System.Convert.ToInt32(Cluster_Frequency[i] * Y_Scale));
                        g.DrawString(System.Convert.ToString(Cluster_Frequency[i]), BarFont, Brushes.Black,
                            System.Convert.ToInt32((Cluster_Bound[i] - Cluster_Bound[0]) * X_Scale) + 5,
                            System.Convert.ToInt32(-Cluster_Frequency[i] * Y_Scale) - 20);
                    }
                }

            }
            catch
            {

            }
            Probabilistic_Report[3] = 0;
            for (int i = 0; i < ClusterNo; i++)
            {
                Probabilistic_Report[3] += (Cluster_Bound[i] + Cluster_Bound[i + 1]) * Cluster_Frequency[i] / (2d * D1);//expected FOS value

            }


        }

        private List<List<string>> SaveSeqList()
        {
            List<List<string>> one_SequenceList = new List<List<string>>();
            one_SequenceList.Clear();
            for (int i = 0; i < SequencesNo; i++)
            {
                one_SequenceList.Add(Save_oneSeqList(i));
            }
            return one_SequenceList;
        }

        private List<string> Save_oneSeqList(int Seq_No)
        {
            List<string> SaveoneSlopeProperty = new List<string>();
            SaveoneSlopeProperty.Clear();
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 1]);//SequenceNo
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 6]);//Material Type
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 7]);//material c
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 9]);//material phi
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 11]);//material Unit weight
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 13]);//Material tensile strength
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 21]);//column No.
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 23]);//column Angle
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 27]);//column Joint c
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 29]);//column joint phi
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 31]);// basal plain angle
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 35]);//basal joint c
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 37]);//basal joint phi
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 39]);//top water level
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 41]);//water angle
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 45]);//seq joint c
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 47]);//seq joint phi
            SaveoneSlopeProperty.Add(SequenceList[Seq_No, 49]);//blockiness
            return SaveoneSlopeProperty;
        }

        private List<string> SaveModelDetail()
        {
            List<string> SaveoneModelDetil = new List<string>();
            SaveoneModelDetil.Clear();
            SaveoneModelDetil.Add(ModelDetail[2]);//Model Name
            SaveoneModelDetil.Add(ModelDetail[3]);//Kh
            SaveoneModelDetil.Add(ModelDetail[5]);//Kv
            return SaveoneModelDetil;
        }

        private void GenerateRandomModel()
        {
            for (int Seq_No = 0; Seq_No < SequencesNo; Seq_No++)
            {
                if (Chk_Bx_Basal_Phi_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 38]) != 0)
                    Randomize(true, Seq_No, 37, 38, 61);
                if (Chk_Bx_Mat_Phi_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 10]) != 0)
                    Randomize(true, Seq_No, 9, 10, 52);
                if (Chk_Bx_Joints_Phi_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 30]) != 0)
                    Randomize(true, Seq_No, 29, 30, 58);
                if (Chk_Bx_Int_Phi_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 48]) != 0)
                    Randomize(true, Seq_No, 47, 48, 65);

                if (Chk_Bx_Basal_c_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 36]) != 0)
                    Randomize(true, Seq_No, 35, 36, 60);
                if (Chk_Bx_Mat_c_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 8]) != 0)
                    Randomize(true, Seq_No, 7, 8, 51);
                if (Chk_Bx_Joints_c_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 28]) != 0)
                    Randomize(true, Seq_No, 27, 28, 57);
                if (Chk_Bx_Int_c_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 46]) != 0)
                    Randomize(true, Seq_No, 45, 46, 64);

                if (Chk_Bx_Tensile_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 14]) != 0)
                    Randomize(true, Seq_No, 13, 14, 54);
                if (Chk_Bx_UnitWeight_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 12]) != 0)
                    Randomize(true, Seq_No, 11, 12, 53);

                if (Chk_Bx_Kh_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_ModelDetail[4]) != 0)
                    Randomize(false, Seq_No, 3, 4, 8);
                if (Chk_Bx_ClmnNo_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 22]) != 0 && Origin_SequenceList[Seq_No, 6] == "Rock")
                    Randomize(true, Seq_No, 21, 22, 55);
                if (Chk_Bx_BasalAng_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 32]) != 0 && Origin_SequenceList[Seq_No, 6] == "Rock")
                    Randomize(true, Seq_No, 31, 32, 59);
                if (Chk_Bx_Blockiness_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 50]) != 0)
                    Randomize(true, Seq_No, 49, 50, 66);

                if (Chk_Bx_Kv_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_ModelDetail[6]) != 0)
                    Randomize(false, Seq_No, 5, 6, 9);
                if (Chk_Bx_ClmnAng_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 24]) != 0)
                    Randomize(true, Seq_No, 23, 24, 56);
                if (Chk_Bx_WaterLevel_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 40]) != 0)
                    Randomize(true, Seq_No, 39, 40, 62);
                if (Chk_Bx_WaterAng_Probabilistic.Checked == true && System.Convert.ToDouble(Origin_SequenceList[Seq_No, 42]) != 0)
                    Randomize(true, Seq_No, 41, 42, 63);
            }

        }

        private void Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            if (Array_Select == true)
            {
                if (Origin_SequenceList[Seq_No, Dist_Type_Index] == "Uniform")
                    Uniform_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_SequenceList[Seq_No, Dist_Type_Index] == "Normal")
                    Normal_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_SequenceList[Seq_No, Dist_Type_Index] == "Log Normal")
                    LogNormal_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_SequenceList[Seq_No, Dist_Type_Index] == "T Student")
                    TStudent_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_SequenceList[Seq_No, Dist_Type_Index] == "K")
                    K_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
            }
            else
            {
                if (Origin_ModelDetail[Dist_Type_Index] == "Uniform" && Seq_No == 0)
                    Uniform_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_ModelDetail[Dist_Type_Index] == "Normal" && Seq_No == 0)
                    Normal_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_ModelDetail[Dist_Type_Index] == "Log Normal" && Seq_No == 0)
                    LogNormal_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_ModelDetail[Dist_Type_Index] == "T Student" && Seq_No == 0)
                    TStudent_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
                if (Origin_ModelDetail[Dist_Type_Index] == "K" && Seq_No == 0)
                    K_Randomize(Array_Select, Seq_No, Mean_Value_index, Dev_Value_Index, Dist_Type_Index);
            }



        }

        private void Uniform_Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            Random RND = new System.Random();
            double Random_Value = RND.NextDouble(); //returns floating point 0.0-1.0
            if (Array_Select == true)
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_No, Mean_Value_index])
                    + (2d * Random_Value - 1) * System.Convert.ToDouble(Origin_SequenceList[Seq_No, Dev_Value_Index]));
            }
            else
            {
                ModelDetail[Mean_Value_index] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[Mean_Value_index])
                    + (2d * Random_Value - 1) * System.Convert.ToDouble(Origin_ModelDetail[Dev_Value_Index]));
            }

            if (Mean_Value_index == 21)//column Number Edit
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(SequenceList[Seq_No, Mean_Value_index])));
                if (System.Convert.ToInt32(SequenceList[Seq_No, Mean_Value_index]) <= 0)
                    SequenceList[Seq_No, Mean_Value_index] = "1";
            }
            System.Threading.Thread.Sleep(3);//for beter work of random function
        }

        private void Normal_Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            double[,] NrmlStndrd_Dist_Chart = new double[,]
            {
//                           0         1         2        3         4         5         6         7         8         9
//                          -0.1     -0.09     -0.08     -0.07     -0.06     -0.05     -0.04     -0.03     -0.02     -0.01
/*-3.9*/                { 0.000033, 0.000034, 0.000036, 0.000037, 0.000039, 0.000041, 0.000042, 0.000044, 0.000046, 0.000048},//0
/*-3.8*/                { 0.000050, 0.000052, 0.000054, 0.000057, 0.000059, 0.000062, 0.000064, 0.000067, 0.000069, 0.000072},//1 
/*-3.7*/                { 0.000075, 0.000078, 0.000082, 0.000085, 0.000088, 0.000092, 0.000096, 0.000100, 0.000100, 0.000110},//2
/*-3.6*/                { 0.000110, 0.000120, 0.000120, 0.000130, 0.000130, 0.000140, 0.000140, 0.000150, 0.000150, 0.000160},//3 
/*-3.5*/                { 0.000170, 0.000170, 0.000180, 0.000190, 0.000190, 0.000200, 0.000210, 0.000220, 0.000220, 0.000230},//4 
/*-3.4*/                { 0.000240, 0.000250, 0.000260, 0.000270, 0.000280, 0.000290, 0.000300, 0.000310, 0.000320, 0.000340},//5 
/*-3.3*/                { 0.000350, 0.000360, 0.000380, 0.000390, 0.000400, 0.000420, 0.000430, 0.000450, 0.000470, 0.000480},//6 
/*-3.2*/                { 0.000500, 0.000520, 0.000540, 0.000560, 0.000580, 0.000600, 0.000620, 0.000640, 0.000660, 0.000690},//7 
/*-3.1*/                { 0.000710, 0.000740, 0.000760, 0.000790, 0.000820, 0.000840, 0.000870, 0.000900, 0.000940, 0.000970},//8 
/*-3.0*/                { 0.001000, 0.001040, 0.001070, 0.001110, 0.001140, 0.001180, 0.001220, 0.001260, 0.001310, 0.001350},//9 
/*-2.9*/                { 0.001400, 0.001400, 0.001500, 0.001500, 0.001600, 0.001600, 0.001700, 0.001800, 0.001800, 0.001900},//10 
/*-2.8*/                { 0.001900, 0.002000, 0.002100, 0.002100, 0.002200, 0.002300, 0.002300, 0.002400, 0.002500, 0.002600},//11 
/*-2.7*/                { 0.002600, 0.002700, 0.002800, 0.002900, 0.003000, 0.003100, 0.003200, 0.003300, 0.003400, 0.003500},//12 
/*-2.6*/                { 0.003600, 0.003700, 0.003800, 0.003900, 0.004000, 0.004100, 0.004300, 0.004400, 0.004500, 0.004700},//13
/*-2.5*/                { 0.004800, 0.004900, 0.005100, 0.005200, 0.005400, 0.005500, 0.005700, 0.005900, 0.006000, 0.006200},//14
/*-2.4*/                { 0.006400, 0.006600, 0.006800, 0.006900, 0.007100, 0.007300, 0.007500, 0.007800, 0.008000, 0.008200},//15
/*-2.3*/                { 0.008400, 0.008700, 0.008900, 0.009100, 0.009400, 0.009600, 0.009900, 0.010200, 0.010400, 0.010700},//16
/*-2.2*/                { 0.011000, 0.011300, 0.011600, 0.011900, 0.012200, 0.012500, 0.012900, 0.013200, 0.013600, 0.013900},//17
/*-2.1*/                { 0.014300, 0.014600, 0.015000, 0.015400, 0.015800, 0.016200, 0.016600, 0.017000, 0.017400, 0.017900},//18
/*-2.0*/                { 0.018300, 0.018800, 0.019200, 0.019700, 0.020200, 0.020700, 0.021200, 0.021700, 0.022200, 0.022800},//19
/*-1.9*/                { 0.023300, 0.023900, 0.024400, 0.025000, 0.025600, 0.026200, 0.026800, 0.027400, 0.028100, 0.028700},//20
/*-1.8*/                { 0.029400, 0.030100, 0.030700, 0.031400, 0.032200, 0.032900, 0.033600, 0.034400, 0.035100, 0.035900},//21
/*-1.7*/                { 0.036700, 0.037500, 0.038400, 0.039200, 0.040100, 0.040900, 0.041800, 0.042700, 0.043600, 0.044600},//22
/*-1.6*/                { 0.045500, 0.046500, 0.047500, 0.048500, 0.049500, 0.050500, 0.051600, 0.052600, 0.053700, 0.054800},//23
/*-1.5*/                { 0.055900, 0.057100, 0.058200, 0.059400, 0.060600, 0.061800, 0.063000, 0.064300, 0.065500, 0.066800},//24
/*-1.4*/                { 0.068100, 0.069400, 0.070800, 0.072100, 0.073500, 0.074900, 0.076400, 0.077800, 0.079300, 0.080800},//25
/*-1.3*/                { 0.082300, 0.083800, 0.085300, 0.086900, 0.088500, 0.090100, 0.091800, 0.093400, 0.095100, 0.096800},//26
/*-1.2*/                { 0.098500, 0.100300, 0.102000, 0.103800, 0.105600, 0.107500, 0.109300, 0.111200, 0.113100, 0.115100},//27
/*-1.1*/                { 0.117000, 0.119000, 0.121000, 0.123000, 0.125100, 0.127100, 0.129200, 0.131400, 0.133500, 0.135700},//28
/*-1.0*/                { 0.137900, 0.140100, 0.142300, 0.144600, 0.146900, 0.149200, 0.151500, 0.153900, 0.156200, 0.158700},//29
/*-0.9*/                { 0.161100, 0.163500, 0.166000, 0.168500, 0.171100, 0.173600, 0.176200, 0.178800, 0.181400, 0.184100},//30
/*-0.8*/                { 0.186700, 0.189400, 0.192200, 0.194900, 0.197700, 0.200500, 0.203300, 0.206100, 0.209000, 0.211900},//31
/*-0.7*/                { 0.214800, 0.217700, 0.220600, 0.223600, 0.226600, 0.229600, 0.232700, 0.235800, 0.238900, 0.242000},//32
/*-0.6*/                { 0.245100, 0.248300, 0.251400, 0.254600, 0.257800, 0.261100, 0.264300, 0.267600, 0.270900, 0.274300},//33
/*-0.5*/                { 0.277600, 0.281000, 0.284300, 0.287700, 0.291200, 0.294600, 0.298100, 0.301500, 0.305000, 0.308500},//34
/*-0.4*/                { 0.312100, 0.315600, 0.319200, 0.322800, 0.326400, 0.330000, 0.333600, 0.337200, 0.340900, 0.344600},//35
/*-0.3*/                { 0.348300, 0.352000, 0.355700, 0.359400, 0.363200, 0.366900, 0.370700, 0.374500, 0.378300, 0.382100},//36
/*-0.2*/                { 0.385900, 0.389700, 0.393600, 0.397400, 0.401300, 0.405200, 0.409000, 0.412900, 0.416800, 0.420700},//37
/*-0.1*/                { 0.424700, 0.428600, 0.432500, 0.436400, 0.440400, 0.444300, 0.448300, 0.452200, 0.456200, 0.460200},//38
/*-0.0*/                { 0.464100, 0.468100, 0.472100, 0.476100, 0.480100, 0.484000, 0.488000, 0.492000, 0.496000, 0.500000},//39
//                           0.00      0.1      0.2      0.03      0.04      0.05      0.06      0.07      0.08      0.09
/*+0.0*/                { 0.504000, 0.508000, 0.512000, 0.516000, 0.519900, 0.523900, 0.527900, 0.531900, 0.535900, 0.539800},//40
/*+0.1*/                { 0.543800, 0.547800, 0.551700, 0.555700, 0.559600, 0.563600, 0.567500, 0.571400, 0.575300, 0.579300},//41
/*+0.2*/                { 0.583200, 0.587100, 0.591000, 0.594800, 0.598700, 0.602600, 0.606400, 0.610300, 0.614100, 0.617900},//42
/*+0.3*/                { 0.621700, 0.625500, 0.629300, 0.633100, 0.636800, 0.640600, 0.644300, 0.648000, 0.651700, 0.655400},//43
/*+0.4*/                { 0.659100, 0.662800, 0.666400, 0.670000, 0.673600, 0.677200, 0.680800, 0.684400, 0.687900, 0.691500},//44
/*+0.5*/                { 0.695000, 0.698500, 0.701900, 0.705400, 0.708800, 0.712300, 0.715700, 0.719000, 0.722400, 0.725700},//45
/*+0.6*/                { 0.729100, 0.732400, 0.735700, 0.738900, 0.742200, 0.745400, 0.748600, 0.751700, 0.754900, 0.758000},//46
/*+0.7*/                { 0.761100, 0.764200, 0.767300, 0.770400, 0.773400, 0.776400, 0.779400, 0.782300, 0.785200, 0.788100},//47
/*+0.8*/                { 0.791000, 0.793900, 0.796700, 0.799500, 0.802300, 0.805100, 0.807800, 0.810600, 0.813300, 0.815900},//48
/*+0.9*/                { 0.818600, 0.821200, 0.823800, 0.826400, 0.828900, 0.831500, 0.834000, 0.836500, 0.838900, 0.841300},//49
/*+1.0*/                { 0.843800, 0.846100, 0.848500, 0.850800, 0.853100, 0.855400, 0.857700, 0.859900, 0.862100, 0.864300},//50
/*+1.1*/                { 0.866500, 0.868600, 0.870800, 0.872900, 0.874900, 0.877000, 0.879000, 0.881000, 0.883000, 0.884900},//51
/*+1.2*/                { 0.886900, 0.888800, 0.890700, 0.892500, 0.894400, 0.896200, 0.898000, 0.899700, 0.901500, 0.903200},//52
/*+1.3*/                { 0.904900, 0.906600, 0.908200, 0.909900, 0.911500, 0.913100, 0.914700, 0.916200, 0.917700, 0.919200},//53
/*+1.4*/                { 0.920700, 0.922200, 0.923600, 0.925100, 0.926500, 0.927900, 0.929200, 0.930600, 0.931900, 0.933200},//54
/*+1.5*/                { 0.934500, 0.935700, 0.937000, 0.938200, 0.939400, 0.940600, 0.941800, 0.942900, 0.944100, 0.945200},//55
/*+1.6*/                { 0.946300, 0.947400, 0.948400, 0.949500, 0.950500, 0.951500, 0.952500, 0.953500, 0.954500, 0.955400},//56
/*+1.7*/                { 0.956400, 0.957300, 0.958200, 0.959100, 0.959900, 0.960800, 0.961600, 0.962500, 0.963300, 0.964100},//57
/*+1.8*/                { 0.964900, 0.965600, 0.966400, 0.967100, 0.967800, 0.968600, 0.969300, 0.969900, 0.970600, 0.971300},//58
/*+1.9*/                { 0.971900, 0.972600, 0.973200, 0.973800, 0.974400, 0.975000, 0.975600, 0.976100, 0.976700, 0.977200},//59
/*+2.0*/                { 0.977800, 0.978300, 0.978800, 0.979300, 0.979800, 0.980300, 0.980800, 0.981200, 0.981700, 0.982100},//60
/*+2.1*/                { 0.982600, 0.983000, 0.983400, 0.983800, 0.984200, 0.984600, 0.985000, 0.985400, 0.985700, 0.986100},//61
/*+2.2*/                { 0.986400, 0.986800, 0.987100, 0.987500, 0.987800, 0.988100, 0.988400, 0.988700, 0.989000, 0.989300},//62
/*+2.3*/                { 0.989600, 0.989800, 0.990100, 0.990400, 0.990600, 0.990900, 0.991100, 0.991300, 0.991600, 0.991800},//63
/*+2.4*/                { 0.992000, 0.992200, 0.992500, 0.992700, 0.992900, 0.993100, 0.993200, 0.993400, 0.993600, 0.993800},//64
/*+2.5*/                { 0.994000, 0.994100, 0.994300, 0.994500, 0.994600, 0.994800, 0.994900, 0.995100, 0.995200, 0.995300},//65
/*+2.6*/                { 0.995500, 0.995600, 0.995700, 0.995900, 0.996000, 0.996100, 0.996200, 0.996300, 0.996400, 0.996500},//66
/*+2.7*/                { 0.996600, 0.996700, 0.996800, 0.996900, 0.997000, 0.997100, 0.997200, 0.997300, 0.997400, 0.997400},//67
/*+2.8*/                { 0.997500, 0.997600, 0.997700, 0.997700, 0.997800, 0.997900, 0.997900, 0.998000, 0.998100, 0.998100},//68
/*+2.9*/                { 0.998200, 0.998200, 0.998300, 0.998400, 0.998400, 0.998500, 0.998500, 0.998600, 0.998600, 0.998650},//69
/*+3.0*/                { 0.998690, 0.998740, 0.998780, 0.998820, 0.998860, 0.998890, 0.998930, 0.998960, 0.999000, 0.999030},//70
/*+3.1*/                { 0.999060, 0.999100, 0.999130, 0.999160, 0.999180, 0.999210, 0.999240, 0.999260, 0.999290, 0.999310},//71
/*+3.2*/                { 0.999340, 0.999360, 0.999380, 0.999400, 0.999420, 0.999440, 0.999460, 0.999480, 0.999500, 0.999520},//72
/*+3.2*/                { 0.999530, 0.999550, 0.999570, 0.999580, 0.999600, 0.999610, 0.999620, 0.999640, 0.999650, 0.999660},//73
/*+3.4*/                { 0.999680, 0.999690, 0.999700, 0.999710, 0.999720, 0.999730, 0.999740, 0.999750, 0.999760, 0.999770},//74
/*+3.5*/                { 0.999780, 0.999780, 0.999790, 0.999800, 0.999810, 0.999810, 0.999820, 0.999830, 0.999830, 0.999840},//75
/*+3.6*/                { 0.999850, 0.999850, 0.999860, 0.999860, 0.999870, 0.999870, 0.999880, 0.999880, 0.999890, 0.999890},//76
/*+3.7*/                { 0.999900, 0.999900, 0.999900, 0.999910, 0.999910, 0.999920, 0.999920, 0.999920, 0.999920, 0.999930},//77
/*+3.8*/                { 0.999930, 0.999930, 0.999940, 0.999940, 0.999940, 0.999940, 0.999950, 0.999950, 0.999950, 0.999950},//78
/*+3.9*/                { 0.999950, 0.999960, 0.999960, 0.999960, 0.999960, 0.999960, 0.999960, 0.999970, 0.999970, 1.000000}//79
            };

            Random RND = new System.Random();
            double Random_Value = RND.NextDouble(); //returns floating point 0.0-1.0
            double Z_V = 0;
            for (int i = 0; i < 80; i++)
            {
                if (Random_Value <= NrmlStndrd_Dist_Chart[i, 9])
                {
                    for (int j = 0; j < 10; j++)
                    {
                        if (Random_Value <= NrmlStndrd_Dist_Chart[i, j])
                        {
                            Z_V = -3.9 + System.Convert.ToDouble(i - 1) * 0.1d + System.Convert.ToDouble(j) * 0.01d;
                            i = 81;
                            j = 11;
                        }
                    }
                }
            }


            if (Array_Select == true)
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToDouble(Origin_SequenceList[Seq_No, Mean_Value_index])
                    + Z_V * System.Convert.ToDouble(Origin_SequenceList[Seq_No, Dev_Value_Index]));
            }
            else
            {
                Origin_ModelDetail[Mean_Value_index] = System.Convert.ToString(System.Convert.ToDouble(Origin_ModelDetail[Mean_Value_index])
                    + Z_V * System.Convert.ToDouble(Origin_ModelDetail[Dev_Value_Index]));
            }

            if (Mean_Value_index == 21)//column Number Must be Integer
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(SequenceList[Seq_No, Mean_Value_index])));
                if (System.Convert.ToInt32(SequenceList[Seq_No, Mean_Value_index]) <= 0)
                    SequenceList[Seq_No, Mean_Value_index] = "1";
            }
            System.Threading.Thread.Sleep(3);//for beter work of random function
        }

        private void LogNormal_Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            if (Array_Select == true)
            {
                CenterSpace.NMath.Core.RandGenLogNormal RND = new CenterSpace.NMath.Core.RandGenLogNormal(
                    System.Convert.ToDouble(Origin_SequenceList[Seq_No, Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_SequenceList[Seq_No, Dev_Value_Index]), 2));
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }
            else
            {
                CenterSpace.NMath.Core.RandGenLogNormal RND = new CenterSpace.NMath.Core.RandGenLogNormal(
                    System.Convert.ToDouble(Origin_ModelDetail[Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_ModelDetail[Dev_Value_Index]), 2));
                Origin_ModelDetail[Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }

            if (Mean_Value_index == 21)//column Number Must be Integer
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(SequenceList[Seq_No, Mean_Value_index])));
                if (System.Convert.ToInt32(SequenceList[Seq_No, Mean_Value_index]) <= 0)
                    SequenceList[Seq_No, Mean_Value_index] = "1";
            }
            System.Threading.Thread.Sleep(3);//for beter work of random function
        }

        private void TStudent_Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            if (Array_Select == true)
            {
                CenterSpace.NMath.Core.RandGenUniform RND = new CenterSpace.NMath.Core.RandGenUniform(
                    System.Convert.ToDouble(Origin_SequenceList[Seq_No, Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_SequenceList[Seq_No, Dev_Value_Index]), 2));
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }
            else
            {
                CenterSpace.NMath.Core.RandGenUniform RND = new CenterSpace.NMath.Core.RandGenUniform(
                    System.Convert.ToDouble(Origin_ModelDetail[Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_ModelDetail[Dev_Value_Index]), 2));
                Origin_ModelDetail[Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }

            if (Mean_Value_index == 21)//column Number Must be Integer
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(SequenceList[Seq_No, Mean_Value_index])));
                if (System.Convert.ToInt32(SequenceList[Seq_No, Mean_Value_index]) <= 0)
                    SequenceList[Seq_No, Mean_Value_index] = "1";
            }
            System.Threading.Thread.Sleep(3);//for beter work of random function
        }

        private void K_Randomize
            (bool Array_Select
            , int Seq_No
            , int Mean_Value_index
            , int Dev_Value_Index
            , int Dist_Type_Index)
        {
            if (Array_Select == true)
            {
                CenterSpace.NMath.Core.RandGenUniform RND = new CenterSpace.NMath.Core.RandGenUniform(
                    System.Convert.ToDouble(Origin_SequenceList[Seq_No, Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_SequenceList[Seq_No, Dev_Value_Index]), 2));
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }
            else
            {
                CenterSpace.NMath.Core.RandGenUniform RND = new CenterSpace.NMath.Core.RandGenUniform(
                    System.Convert.ToDouble(Origin_ModelDetail[Mean_Value_index]),
                    Math.Pow(System.Convert.ToDouble(Origin_ModelDetail[Dev_Value_Index]), 2));
                Origin_ModelDetail[Mean_Value_index] = System.Convert.ToString(RND.NextDouble());
            }

            if (Mean_Value_index == 21)//column Number Must be Integer
            {
                SequenceList[Seq_No, Mean_Value_index] = System.Convert.ToString(System.Convert.ToInt32(System.Convert.ToDouble(SequenceList[Seq_No, Mean_Value_index])));
                if (System.Convert.ToInt32(SequenceList[Seq_No, Mean_Value_index]) <= 0)
                    SequenceList[Seq_No, Mean_Value_index] = "1";
            }
            System.Threading.Thread.Sleep(3);//for beter work of random function
        }

        private void Test_Uniform_Dist()
        {
            double[] Test_Uniform_D = new double[5000];
            Random RND = new System.Random();

            double Random_Value;

            for (int k = 0; k < Test_Uniform_D.GetLength(0); k++)
            {
                Random_Value = RND.NextDouble(); //returns floating point 0.0-1.0
                Test_Uniform_D[k] = Random_Value;
                System.Threading.Thread.Sleep(3);//for beter work of random function
            }
            XCL_Distribution_Test("Uniform Distribution", Test_Uniform_D);
        }

        private void Test_Normal_Dist()
        {
            double[] Test_N_D = new double[5000];
            double[,] NrmlStndrd_Dist_Chart = new double[,]
            {
//                           0         1         2        3         4         5         6         7         8         9
//                          -0.1     -0.09     -0.08     -0.07     -0.06     -0.05     -0.04     -0.03     -0.02     -0.01
/*-3.9*/                { 0.000033, 0.000034, 0.000036, 0.000037, 0.000039, 0.000041, 0.000042, 0.000044, 0.000046, 0.000048},//0
/*-3.8*/                { 0.000050, 0.000052, 0.000054, 0.000057, 0.000059, 0.000062, 0.000064, 0.000067, 0.000069, 0.000072},//1 
/*-3.7*/                { 0.000075, 0.000078, 0.000082, 0.000085, 0.000088, 0.000092, 0.000096, 0.000100, 0.000100, 0.000110},//2
/*-3.6*/                { 0.000110, 0.000120, 0.000120, 0.000130, 0.000130, 0.000140, 0.000140, 0.000150, 0.000150, 0.000160},//3 
/*-3.5*/                { 0.000170, 0.000170, 0.000180, 0.000190, 0.000190, 0.000200, 0.000210, 0.000220, 0.000220, 0.000230},//4 
/*-3.4*/                { 0.000240, 0.000250, 0.000260, 0.000270, 0.000280, 0.000290, 0.000300, 0.000310, 0.000320, 0.000340},//5 
/*-3.3*/                { 0.000350, 0.000360, 0.000380, 0.000390, 0.000400, 0.000420, 0.000430, 0.000450, 0.000470, 0.000480},//6 
/*-3.2*/                { 0.000500, 0.000520, 0.000540, 0.000560, 0.000580, 0.000600, 0.000620, 0.000640, 0.000660, 0.000690},//7 
/*-3.1*/                { 0.000710, 0.000740, 0.000760, 0.000790, 0.000820, 0.000840, 0.000870, 0.000900, 0.000940, 0.000970},//8 
/*-3.0*/                { 0.001000, 0.001040, 0.001070, 0.001110, 0.001140, 0.001180, 0.001220, 0.001260, 0.001310, 0.001350},//9 
/*-2.9*/                { 0.001400, 0.001400, 0.001500, 0.001500, 0.001600, 0.001600, 0.001700, 0.001800, 0.001800, 0.001900},//10 
/*-2.8*/                { 0.001900, 0.002000, 0.002100, 0.002100, 0.002200, 0.002300, 0.002300, 0.002400, 0.002500, 0.002600},//11 
/*-2.7*/                { 0.002600, 0.002700, 0.002800, 0.002900, 0.003000, 0.003100, 0.003200, 0.003300, 0.003400, 0.003500},//12 
/*-2.6*/                { 0.003600, 0.003700, 0.003800, 0.003900, 0.004000, 0.004100, 0.004300, 0.004400, 0.004500, 0.004700},//13
/*-2.5*/                { 0.004800, 0.004900, 0.005100, 0.005200, 0.005400, 0.005500, 0.005700, 0.005900, 0.006000, 0.006200},//14
/*-2.4*/                { 0.006400, 0.006600, 0.006800, 0.006900, 0.007100, 0.007300, 0.007500, 0.007800, 0.008000, 0.008200},//15
/*-2.3*/                { 0.008400, 0.008700, 0.008900, 0.009100, 0.009400, 0.009600, 0.009900, 0.010200, 0.010400, 0.010700},//16
/*-2.2*/                { 0.011000, 0.011300, 0.011600, 0.011900, 0.012200, 0.012500, 0.012900, 0.013200, 0.013600, 0.013900},//17
/*-2.1*/                { 0.014300, 0.014600, 0.015000, 0.015400, 0.015800, 0.016200, 0.016600, 0.017000, 0.017400, 0.017900},//18
/*-2.0*/                { 0.018300, 0.018800, 0.019200, 0.019700, 0.020200, 0.020700, 0.021200, 0.021700, 0.022200, 0.022800},//19
/*-1.9*/                { 0.023300, 0.023900, 0.024400, 0.025000, 0.025600, 0.026200, 0.026800, 0.027400, 0.028100, 0.028700},//20
/*-1.8*/                { 0.029400, 0.030100, 0.030700, 0.031400, 0.032200, 0.032900, 0.033600, 0.034400, 0.035100, 0.035900},//21
/*-1.7*/                { 0.036700, 0.037500, 0.038400, 0.039200, 0.040100, 0.040900, 0.041800, 0.042700, 0.043600, 0.044600},//22
/*-1.6*/                { 0.045500, 0.046500, 0.047500, 0.048500, 0.049500, 0.050500, 0.051600, 0.052600, 0.053700, 0.054800},//23
/*-1.5*/                { 0.055900, 0.057100, 0.058200, 0.059400, 0.060600, 0.061800, 0.063000, 0.064300, 0.065500, 0.066800},//24
/*-1.4*/                { 0.068100, 0.069400, 0.070800, 0.072100, 0.073500, 0.074900, 0.076400, 0.077800, 0.079300, 0.080800},//25
/*-1.3*/                { 0.082300, 0.083800, 0.085300, 0.086900, 0.088500, 0.090100, 0.091800, 0.093400, 0.095100, 0.096800},//26
/*-1.2*/                { 0.098500, 0.100300, 0.102000, 0.103800, 0.105600, 0.107500, 0.109300, 0.111200, 0.113100, 0.115100},//27
/*-1.1*/                { 0.117000, 0.119000, 0.121000, 0.123000, 0.125100, 0.127100, 0.129200, 0.131400, 0.133500, 0.135700},//28
/*-1.0*/                { 0.137900, 0.140100, 0.142300, 0.144600, 0.146900, 0.149200, 0.151500, 0.153900, 0.156200, 0.158700},//29
/*-0.9*/                { 0.161100, 0.163500, 0.166000, 0.168500, 0.171100, 0.173600, 0.176200, 0.178800, 0.181400, 0.184100},//30
/*-0.8*/                { 0.186700, 0.189400, 0.192200, 0.194900, 0.197700, 0.200500, 0.203300, 0.206100, 0.209000, 0.211900},//31
/*-0.7*/                { 0.214800, 0.217700, 0.220600, 0.223600, 0.226600, 0.229600, 0.232700, 0.235800, 0.238900, 0.242000},//32
/*-0.6*/                { 0.245100, 0.248300, 0.251400, 0.254600, 0.257800, 0.261100, 0.264300, 0.267600, 0.270900, 0.274300},//33
/*-0.5*/                { 0.277600, 0.281000, 0.284300, 0.287700, 0.291200, 0.294600, 0.298100, 0.301500, 0.305000, 0.308500},//34
/*-0.4*/                { 0.312100, 0.315600, 0.319200, 0.322800, 0.326400, 0.330000, 0.333600, 0.337200, 0.340900, 0.344600},//35
/*-0.3*/                { 0.348300, 0.352000, 0.355700, 0.359400, 0.363200, 0.366900, 0.370700, 0.374500, 0.378300, 0.382100},//36
/*-0.2*/                { 0.385900, 0.389700, 0.393600, 0.397400, 0.401300, 0.405200, 0.409000, 0.412900, 0.416800, 0.420700},//37
/*-0.1*/                { 0.424700, 0.428600, 0.432500, 0.436400, 0.440400, 0.444300, 0.448300, 0.452200, 0.456200, 0.460200},//38
/*-0.0*/                { 0.464100, 0.468100, 0.472100, 0.476100, 0.480100, 0.484000, 0.488000, 0.492000, 0.496000, 0.500000},//39
//                           0.00      0.1      0.2      0.03      0.04      0.05      0.06      0.07      0.08      0.09
/*+0.0*/                { 0.504000, 0.508000, 0.512000, 0.516000, 0.519900, 0.523900, 0.527900, 0.531900, 0.535900, 0.539800},//40
/*+0.1*/                { 0.543800, 0.547800, 0.551700, 0.555700, 0.559600, 0.563600, 0.567500, 0.571400, 0.575300, 0.579300},//41
/*+0.2*/                { 0.583200, 0.587100, 0.591000, 0.594800, 0.598700, 0.602600, 0.606400, 0.610300, 0.614100, 0.617900},//42
/*+0.3*/                { 0.621700, 0.625500, 0.629300, 0.633100, 0.636800, 0.640600, 0.644300, 0.648000, 0.651700, 0.655400},//43
/*+0.4*/                { 0.659100, 0.662800, 0.666400, 0.670000, 0.673600, 0.677200, 0.680800, 0.684400, 0.687900, 0.691500},//44
/*+0.5*/                { 0.695000, 0.698500, 0.701900, 0.705400, 0.708800, 0.712300, 0.715700, 0.719000, 0.722400, 0.725700},//45
/*+0.6*/                { 0.729100, 0.732400, 0.735700, 0.738900, 0.742200, 0.745400, 0.748600, 0.751700, 0.754900, 0.758000},//46
/*+0.7*/                { 0.761100, 0.764200, 0.767300, 0.770400, 0.773400, 0.776400, 0.779400, 0.782300, 0.785200, 0.788100},//47
/*+0.8*/                { 0.791000, 0.793900, 0.796700, 0.799500, 0.802300, 0.805100, 0.807800, 0.810600, 0.813300, 0.815900},//48
/*+0.9*/                { 0.818600, 0.821200, 0.823800, 0.826400, 0.828900, 0.831500, 0.834000, 0.836500, 0.838900, 0.841300},//49
/*+1.0*/                { 0.843800, 0.846100, 0.848500, 0.850800, 0.853100, 0.855400, 0.857700, 0.859900, 0.862100, 0.864300},//50
/*+1.1*/                { 0.866500, 0.868600, 0.870800, 0.872900, 0.874900, 0.877000, 0.879000, 0.881000, 0.883000, 0.884900},//51
/*+1.2*/                { 0.886900, 0.888800, 0.890700, 0.892500, 0.894400, 0.896200, 0.898000, 0.899700, 0.901500, 0.903200},//52
/*+1.3*/                { 0.904900, 0.906600, 0.908200, 0.909900, 0.911500, 0.913100, 0.914700, 0.916200, 0.917700, 0.919200},//53
/*+1.4*/                { 0.920700, 0.922200, 0.923600, 0.925100, 0.926500, 0.927900, 0.929200, 0.930600, 0.931900, 0.933200},//54
/*+1.5*/                { 0.934500, 0.935700, 0.937000, 0.938200, 0.939400, 0.940600, 0.941800, 0.942900, 0.944100, 0.945200},//55
/*+1.6*/                { 0.946300, 0.947400, 0.948400, 0.949500, 0.950500, 0.951500, 0.952500, 0.953500, 0.954500, 0.955400},//56
/*+1.7*/                { 0.956400, 0.957300, 0.958200, 0.959100, 0.959900, 0.960800, 0.961600, 0.962500, 0.963300, 0.964100},//57
/*+1.8*/                { 0.964900, 0.965600, 0.966400, 0.967100, 0.967800, 0.968600, 0.969300, 0.969900, 0.970600, 0.971300},//58
/*+1.9*/                { 0.971900, 0.972600, 0.973200, 0.973800, 0.974400, 0.975000, 0.975600, 0.976100, 0.976700, 0.977200},//59
/*+2.0*/                { 0.977800, 0.978300, 0.978800, 0.979300, 0.979800, 0.980300, 0.980800, 0.981200, 0.981700, 0.982100},//60
/*+2.1*/                { 0.982600, 0.983000, 0.983400, 0.983800, 0.984200, 0.984600, 0.985000, 0.985400, 0.985700, 0.986100},//61
/*+2.2*/                { 0.986400, 0.986800, 0.987100, 0.987500, 0.987800, 0.988100, 0.988400, 0.988700, 0.989000, 0.989300},//62
/*+2.3*/                { 0.989600, 0.989800, 0.990100, 0.990400, 0.990600, 0.990900, 0.991100, 0.991300, 0.991600, 0.991800},//63
/*+2.4*/                { 0.992000, 0.992200, 0.992500, 0.992700, 0.992900, 0.993100, 0.993200, 0.993400, 0.993600, 0.993800},//64
/*+2.5*/                { 0.994000, 0.994100, 0.994300, 0.994500, 0.994600, 0.994800, 0.994900, 0.995100, 0.995200, 0.995300},//65
/*+2.6*/                { 0.995500, 0.995600, 0.995700, 0.995900, 0.996000, 0.996100, 0.996200, 0.996300, 0.996400, 0.996500},//66
/*+2.7*/                { 0.996600, 0.996700, 0.996800, 0.996900, 0.997000, 0.997100, 0.997200, 0.997300, 0.997400, 0.997400},//67
/*+2.8*/                { 0.997500, 0.997600, 0.997700, 0.997700, 0.997800, 0.997900, 0.997900, 0.998000, 0.998100, 0.998100},//68
/*+2.9*/                { 0.998200, 0.998200, 0.998300, 0.998400, 0.998400, 0.998500, 0.998500, 0.998600, 0.998600, 0.998650},//69
/*+3.0*/                { 0.998690, 0.998740, 0.998780, 0.998820, 0.998860, 0.998890, 0.998930, 0.998960, 0.999000, 0.999030},//70
/*+3.1*/                { 0.999060, 0.999100, 0.999130, 0.999160, 0.999180, 0.999210, 0.999240, 0.999260, 0.999290, 0.999310},//71
/*+3.2*/                { 0.999340, 0.999360, 0.999380, 0.999400, 0.999420, 0.999440, 0.999460, 0.999480, 0.999500, 0.999520},//72
/*+3.2*/                { 0.999530, 0.999550, 0.999570, 0.999580, 0.999600, 0.999610, 0.999620, 0.999640, 0.999650, 0.999660},//73
/*+3.4*/                { 0.999680, 0.999690, 0.999700, 0.999710, 0.999720, 0.999730, 0.999740, 0.999750, 0.999760, 0.999770},//74
/*+3.5*/                { 0.999780, 0.999780, 0.999790, 0.999800, 0.999810, 0.999810, 0.999820, 0.999830, 0.999830, 0.999840},//75
/*+3.6*/                { 0.999850, 0.999850, 0.999860, 0.999860, 0.999870, 0.999870, 0.999880, 0.999880, 0.999890, 0.999890},//76
/*+3.7*/                { 0.999900, 0.999900, 0.999900, 0.999910, 0.999910, 0.999920, 0.999920, 0.999920, 0.999920, 0.999930},//77
/*+3.8*/                { 0.999930, 0.999930, 0.999940, 0.999940, 0.999940, 0.999940, 0.999950, 0.999950, 0.999950, 0.999950},//78
/*+3.9*/                { 0.999950, 0.999960, 0.999960, 0.999960, 0.999960, 0.999960, 0.999960, 0.999970, 0.999970, 1.000000}//79
            };

            Random RND = new System.Random();
            double Z_V = 0;

            double Random_Value;

            for (int k = 0; k < Test_N_D.GetLength(0); k++)
            {
                Random_Value = RND.NextDouble(); //returns floating point 0.0-1.0
                for (int i = 0; i < 80; i++)
                {
                    if (Random_Value <= NrmlStndrd_Dist_Chart[i, 9])
                    {
                        for (int j = 0; j < 10; j++)
                        {
                            if (Random_Value <= NrmlStndrd_Dist_Chart[i, j])
                            {
                                Z_V = -3.9 + System.Convert.ToDouble(i - 1) * 0.1d + System.Convert.ToDouble(j) * 0.01d;
                                i = 81;
                                j = 11;
                            }
                        }
                    }
                }
                Test_N_D[k] = Z_V;
                System.Threading.Thread.Sleep(3);//for beter work of random function
            }
            XCL_Distribution_Test("Normal Standard Distribution", Test_N_D);
        }

        private void Test_LogNormal_Dist()
        {
            double[] Test_Uniform_D = new double[5000];
            double Random_Value = 0;
            CenterSpace.NMath.Core.RandGenLogNormal RND = new CenterSpace.NMath.Core.RandGenLogNormal(0.5, 0.8 * 0.8);
            for (int k = 0; k < Test_Uniform_D.GetLength(0); k++)
            {
                Random_Value = RND.NextDouble(); //returns floating point 0.0-1.0
                Test_Uniform_D[k] = Random_Value;
                System.Threading.Thread.Sleep(3);//for beter work of random function
            }
            XCL_Distribution_Test("LogNormal Distribution", Test_Uniform_D);
        }

        private void XCL_Distribution_Test(string DistType, double[] Test_N_D)
        {
            string Excel_Path = "C:\\Topple2\\";
            string print_date;

            Excel.Application app = new Excel.Application();
            Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
            Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;

            print_date = System.Convert.ToString(DateTime.Now.Day) + "_"
                + System.Convert.ToString(DateTime.Now.Month) + "_"
                + System.Convert.ToString(DateTime.Now.Year) + "___"
                + System.Convert.ToString(DateTime.Now.Hour) + "_"
                + System.Convert.ToString(DateTime.Now.Minute) + "_"
                + System.Convert.ToString(DateTime.Now.Second);

            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            Excel_Path = "C:\\Topple2//Output Files\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2//Output Files\\" + DistType + "\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            app.Visible = true;

            worksheet = workbook.Sheets["Sheet" + System.Convert.ToString(1)];
            worksheet = workbook.ActiveSheet;
            worksheet.Name = "Analaysis Results " + System.Convert.ToString(1);

            for (int i = 0; i < Test_N_D.GetLength(0); i++)
            {
                worksheet.Cells[i + 1, 1] = System.Convert.ToString(i + 1);
                worksheet.Cells[i + 1, 2] = System.Convert.ToString(Test_N_D[i]);

            }

            workbook.SaveAs(Excel_Path + "Test " + ModelDetail[2] + print_date + ".xlsx"
                , Missing.Value, Missing.Value
                , Missing.Value, Missing.Value, Missing.Value, Excel.XlSaveAsAccessMode.xlNoChange
                , Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value);
            workbook.Close(true, Missing.Value, Missing.Value);

            app.Visible = false;

        }

        private void Btn_Export_ProbabilisticFOSAnalysis_Click(object sender, EventArgs e)
        {
            int D1 = 0, D2 = 0, D3 = 0;
            char ascii = 'A';
            string Sheet_Column = "";
            int Sheet_Column_No = 0;

            string Excel_Path = "C:\\Topple2\\";
            string print_date;

            ProgBar_ExcelExport.Visible = true;
            D1 = Probabilistic_SequenceList.Count;
            D2 = Probabilistic_SequenceList[0].Count;
            D3 = Probabilistic_SequenceList[0][0].Count;



            Sheet_Column_No = D2 * (D3) + 5;
            while (Sheet_Column_No > 0)
            {
                ascii = System.Convert.ToChar(64 + Sheet_Column_No % 26);
                if (ascii == '@')
                    ascii = 'z';
                Sheet_Column = ascii + Sheet_Column;
                Sheet_Column_No = (Sheet_Column_No - Sheet_Column_No % 26) / 26;
            }

            Excel.Application app = new Excel.Application();
            Excel.Workbook workbook = app.Workbooks.Add(Missing.Value);
            Excel.Worksheet worksheet = workbook.Worksheets[1] as Excel.Worksheet;

            print_date = System.Convert.ToString(DateTime.Now.Day) + "_"
                + System.Convert.ToString(DateTime.Now.Month) + "_"
                + System.Convert.ToString(DateTime.Now.Year) + "___"
                + System.Convert.ToString(DateTime.Now.Hour) + "_"
                + System.Convert.ToString(DateTime.Now.Minute) + "_"
                + System.Convert.ToString(DateTime.Now.Second);

            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            Excel_Path = "C:\\Topple2\\Output Files\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\Probabilistic FOS Analysis\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);
            Excel_Path = "C:\\Topple2\\Output Files\\Probabilistic FOS Analysis\\" + ModelDetail[2] + "\\";
            if (!Directory.Exists(Excel_Path))
                Directory.CreateDirectory(Excel_Path);

            app.Visible = true;

            worksheet = workbook.Sheets["Sheet" + System.Convert.ToString(1)];
            worksheet = workbook.ActiveSheet;
            worksheet.Name = "Analaysis Results " + System.Convert.ToString(1);



            Excel.Range range = worksheet.Range["A4:" + Sheet_Column + System.Convert.ToString(D1 + 4)];

            worksheet.Cells.Style.HorizontalAlignment = Excel.XlHAlign.xlHAlignCenter;//center horizontaly 
            worksheet.Cells.Style.VerticalAlignment = Excel.XlVAlign.xlVAlignCenter;//center vertically
            worksheet.Range["A4:" + Sheet_Column + "4"].Cells.WrapText = true;

            range = worksheet.Range["F1:P1"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.CornflowerBlue;

            range = worksheet.Range["F2:P2"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.PaleGoldenrod;

            worksheet.Cells[1, 6] = "Min\nFOS";
            worksheet.Cells[1, 7] = "Max\nFOS";
            worksheet.Cells[1, 8] = "Average\nFOS";
            worksheet.Cells[1, 9] = "Expected\nFOS\nValue";
            worksheet.Cells[1, 10] = "Deviation\nFOS";
            worksheet.Cells[1, 11] = "Lower\nBound\n95%";
            worksheet.Cells[1, 12] = "Upper\nBound\n95%";
            worksheet.Cells[1, 13] = "Lower\nBound\n90%";
            worksheet.Cells[1, 14] = "Upper\nBound\n90%";
            worksheet.Cells[1, 15] = "Stable\nModels\nNo.";
            worksheet.Cells[1, 16] = "Probability\nof\nStability";

            worksheet.Cells[2, 6] = Probabilistic_Report[0];
            worksheet.Cells[2, 7] = Probabilistic_Report[1];
            worksheet.Cells[2, 8] = Probabilistic_Report[2];
            worksheet.Cells[2, 9] = Probabilistic_Report[3];
            worksheet.Cells[2, 10] = Probabilistic_Report[4];
            worksheet.Cells[2, 11] = Probabilistic_Report[5];
            worksheet.Cells[2, 12] = Probabilistic_Report[6];
            worksheet.Cells[2, 13] = Probabilistic_Report[7];
            worksheet.Cells[2, 14] = Probabilistic_Report[8];
            worksheet.Cells[2, 15] = Probabilistic_Report[9];
            worksheet.Cells[2, 16] = Probabilistic_Report[10];


            range = worksheet.Range["A4:" + Sheet_Column + "4"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.CornflowerBlue;

            range = worksheet.Range["F3:" + Sheet_Column + "3"];
            range.Borders.LineStyle = Excel.XlLineStyle.xlDouble;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.GreenYellow;

            range = worksheet.Range["A5:A" + System.Convert.ToString(D1 + 4)];
            range.Borders.LineStyle = Excel.XlLineStyle.xlLineStyleNone;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.OrangeRed;

            range = worksheet.Range["B5:" + Sheet_Column + System.Convert.ToString(D1 + 4)];
            range.Borders.LineStyle = Excel.XlLineStyle.xlSlantDashDot;
            range.Borders.Weight = 3;
            range.Interior.Color = Color.PaleGoldenrod;

            for (int j = 0; j < D2; j++)
            {
                worksheet.Cells[3, j * D3 + 6] = "Slope No. " + System.Convert.ToString(j + 1);
                worksheet.Range[worksheet.Cells[3, j * D3 + 6], worksheet.Cells[3, j * D3 + 23]].Merge();
            }


            worksheet.Cells[4, 1] = "Try No";
            worksheet.Cells[4, 2] = "FOS";
            worksheet.Cells[4, 3] = "Model Name";
            worksheet.Cells[4, 4] = "Kh";
            worksheet.Cells[4, 5] = "Kv";
            for (int j = 0; j < D2; j++)
            {
                worksheet.Cells[4, j * D3 + 6] = "Sequence\nNo.";
                worksheet.Cells[4, j * D3 + 7] = "Material\nType";
                worksheet.Cells[4, j * D3 + 8] = "Material\nc";
                worksheet.Cells[4, j * D3 + 9] = "Material\nPhi";
                worksheet.Cells[4, j * D3 + 10] = "Material\nUnit\nweight";
                worksheet.Cells[4, j * D3 + 11] = "Material\nTensile\nStrength";
                worksheet.Cells[4, j * D3 + 12] = "Column\nNo.";
                worksheet.Cells[4, j * D3 + 13] = "Column\nAngle";
                worksheet.Cells[4, j * D3 + 14] = "Column\nJoint\nc";
                worksheet.Cells[4, j * D3 + 15] = "Column\nJoint\nPhi";
                worksheet.Cells[4, j * D3 + 16] = "Basal\nPlain\nAngle";
                worksheet.Cells[4, j * D3 + 17] = "Basal\nJoint\nc";
                worksheet.Cells[4, j * D3 + 18] = "Basal\nJoint\nPhi";
                worksheet.Cells[4, j * D3 + 19] = "Top\nWater\nLevel";
                worksheet.Cells[4, j * D3 + 20] = "Water\nAngle";
                worksheet.Cells[4, j * D3 + 21] = "Intersection\nc";
                worksheet.Cells[4, j * D3 + 22] = "Intersection\nPhi";
                worksheet.Cells[4, j * D3 + 23] = "Blockiness";
            }



            for (int i = 0; i < D1; i++)
            {
                worksheet.Cells[i + 5, 1] = i + 1;
                worksheet.Cells[i + 5, 2] = Probability_FOS[i];
                worksheet.Cells[i + 5, 3] = Probabilistic_ModelDetail[i][0];
                worksheet.Cells[i + 5, 4] = Probabilistic_ModelDetail[i][1];
                worksheet.Cells[i + 5, 5] = Probabilistic_ModelDetail[i][2];

                /*
                                worksheet.Cells[i + 5, 43] = TEST_Prob_Calc[0, i];
                                worksheet.Cells[i + 5, 44] = TEST_Prob_Calc[1, i];
                                worksheet.Cells[i + 5, 45] = TEST_Prob_Calc[2, i];
                                worksheet.Cells[i + 5, 46] = TEST_Prob_Calc[3, i];
                */

                for (int j = 0; j < D2; j++)
                {
                    for (int k = 0; k < D3; k++)
                    {
                        worksheet.Cells[i + 5, j * D3 + k + 6] = Probabilistic_SequenceList[i][j][k];
                    }
                }
                ProgBar_ExcelExport.Value = System.Convert.ToInt16((100d * System.Convert.ToDouble(i) / System.Convert.ToDouble(D1)));
                ProgBar_ExcelExport.Refresh();
            }

            range = worksheet.Range["A1:" + Sheet_Column + System.Convert.ToString(D1 + 6)];
            range.Columns.AutoFit();

            range = worksheet.Range["B5:B" + System.Convert.ToString(D1 + 4)];
            var dataBar = range.FormatConditions.AddDatabar();
            dataBar.BarColor.Color = Color.Red;

            for (int i = 4; i <= D2 * D3 + 5; i++)
            {
                Sheet_Column_No = i;
                Sheet_Column = "";
                while (Sheet_Column_No > 0)
                {
                    ascii = System.Convert.ToChar(64 + Sheet_Column_No % 26);
                    if (ascii == '@')
                        ascii = 'z';
                    Sheet_Column = ascii + Sheet_Column;
                    Sheet_Column_No = (Sheet_Column_No - Sheet_Column_No % 26) / 26;
                }
                range = worksheet.Range[Sheet_Column + "5:" + Sheet_Column + System.Convert.ToString(D1 + 4)];
                dataBar = range.FormatConditions.AddDatabar();
                dataBar.BarColor.Color = Color.Red;
            }
            try
            {
                Excel.Range myCell = (Excel.Range)worksheet.Cells[7, 2];
                myCell = (Excel.Range)worksheet.Cells[5, 2];
                myCell.Activate();
                myCell.Application.ActiveWindow.FreezePanes = true;
            }
            catch
            {

            }

            workbook.SaveAs(Excel_Path + "Probabilistic FOS Analysis " + ModelDetail[2] + print_date + ".xlsx"
                , Missing.Value, Missing.Value
                , Missing.Value, Missing.Value, Missing.Value, Excel.XlSaveAsAccessMode.xlNoChange
                , Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value);
            workbook.Close(true, Missing.Value, Missing.Value);

            app.Visible = false;
            ProgBar_ExcelExport.Visible = false;

        }

        private void Rad_Btn_End_Probabilistic_Click(object sender, EventArgs e)
        {
            probabilistic_Running = false;
        }

        private void Rad_Btn_DB_Material_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = true;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = false;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_AddMaterial.Visible = false;




            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material]";
            DataTable dt_Material = new DataTable();
            dt_Material.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Material);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Material;
            ComBx_EditDeleteSelect.ValueMember = "Id_Material";
            ComBx_EditDeleteSelect.DisplayMember = "Material Name";

        }

        private void Rad_Btn_DB_Slope_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = true;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = false;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_DefineSlope.Visible = false;


            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
            DataTable dt_Slope = new DataTable();
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Slope;
            ComBx_EditDeleteSelect.ValueMember = "Id_Slope";
            ComBx_EditDeleteSelect.DisplayMember = "Slope Name";
        }

        private void Rad_Btn_DB_Forces_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = true;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = false;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_UniformLoad.Visible = false;
            Btn_PointLoad.Visible = false;

            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force]";
            DataTable dt_Forces = new DataTable();
            dt_Forces.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Forces);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Forces;
            ComBx_EditDeleteSelect.ValueMember = "Id_Force";
            ComBx_EditDeleteSelect.DisplayMember = "Force Name";
        }

        private void Rad_Btn_DB_Joints_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = true;
            Pnl_NewModel.Visible = false;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_DefineJoint.Visible = false;

            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint]";
            DataTable dt_Joints = new DataTable();
            dt_Joints.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Joints);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Joints;
            ComBx_EditDeleteSelect.ValueMember = "Id_joint";
            ComBx_EditDeleteSelect.DisplayMember = "Joint Name";
        }

        private void Rad_Btn_DB_Models_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = true;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_AddSequence.Visible = false;
            Btn_CreatModel.Visible = false;
            Btn_DefineAnchor.Visible = false;


            Pnl_NewModelInput.Visible = true;
            Pnl_ModelSequenceInput.Visible = false;
            Pnl_AnchorInput.Visible = false;

            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
            DataTable dt_Models = new DataTable();
            dt_Models.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Models);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Models;
            ComBx_EditDeleteSelect.ValueMember = "Id_Model";
            ComBx_EditDeleteSelect.DisplayMember = "Model Name";
        }

        private void Rad_Btn_DB_Sequences_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = true;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_AddSequence.Visible = false;
            Btn_CreatModel.Visible = false;
            Btn_DefineAnchor.Visible = false;

            Pnl_NewModelInput.Visible = false;
            Pnl_ModelSequenceInput.Visible = true;
            Pnl_AnchorInput.Visible = false;


            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
            DataTable dt_Models = new DataTable();
            dt_Models.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Models);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Models;
            ComBx_EditDeleteSelect.ValueMember = "Id_Model";
            ComBx_EditDeleteSelect.DisplayMember = "Model Name";
        }

        private void Rad_Btn_DB_Anchors_Click(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = false;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = true;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_AddSequence.Visible = false;
            Btn_CreatModel.Visible = false;
            Btn_DefineAnchor.Visible = false;

            Pnl_NewModelInput.Visible = false;
            Pnl_ModelSequenceInput.Visible = false;
            Pnl_AnchorInput.Visible = true;


            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Anchor]";
            DataTable dt_Anchors = new DataTable();
            dt_Anchors.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Anchors);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Anchors;
            ComBx_EditDeleteSelect.ValueMember = "Id_Anchor";
            ComBx_EditDeleteSelect.DisplayMember = "Anchor Name";
        }

        private void ComBx_EditDeleteSelect_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (Rad_Btn_DB_Anchors.Checked == true)
            {
                Retrieve_Anchors_Data();
            }
            if (Rad_Btn_DB_Forces.Checked == true)
            {
                Retrieve_Forces_Data();
            }
            if (Rad_Btn_DB_Joints.Checked == true)
            {
                Retrieve_Joints_Data();
            }
            if (Rad_Btn_DB_Material.Checked == true)
            {
                Retrieve_Material_Data();
            }
            if (Rad_Btn_DB_Models.Checked == true)
            {
                Retrieve_Models_Data();
            }
            if (Rad_Btn_DB_Sequences.Checked == true)
            {
                Retrieve_Sequence_Data(1);
            }
            if (Rad_Btn_DB_Slope.Checked == true)
            {
                Retrieve_Slopes_Data();
            }
        }

        private void Retrieve_Anchors_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Anchor = new DataTable();
            DataTable dt_Models = new DataTable();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Anchor] Where [Anchor Name] = '"
                + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Anchor.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Anchor);
            Connection.Close();
            if (dt_Anchor.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Anchor.Rows[0].ItemArray[0]);

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();

                ComBx_SelectSlope.BindingContext = new BindingContext();
                ComBx_SelectSlope.DataSource = dt_Slope;
                ComBx_SelectSlope.ValueMember = "Id_Slope";
                ComBx_SelectSlope.DisplayMember = "Slope Name";

                for (int i = 0; i < dt_Slope.Rows.Count; i++)
                {
                    if (System.Convert.ToInt32(dt_Anchor.Rows[0].ItemArray[2]) == System.Convert.ToInt32(dt_Slope.Rows[i].ItemArray[0]))
                    {
                        ComBx_SelectSlope.Text = System.Convert.ToString(dt_Slope.Rows[i].ItemArray[1]);
                    }
                }

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
                dt_Models.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Models);
                Connection.Close();

                ComBx_SelectModel.BindingContext = new BindingContext();
                ComBx_SelectModel.DataSource = dt_Models;
                ComBx_SelectModel.ValueMember = "Id_Model";
                ComBx_SelectModel.DisplayMember = "Model Name";

                for (int i = 0; i < dt_Models.Rows.Count; i++)
                {
                    if (System.Convert.ToInt32(dt_Anchor.Rows[0].ItemArray[3]) == System.Convert.ToInt32(dt_Models.Rows[i].ItemArray[0]))
                    {
                        ComBx_SelectModel.Text = System.Convert.ToString(dt_Models.Rows[i].ItemArray[1]);
                    }
                }
                TxtBx_AnchorName.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[1]);
                TxtBx_AnchorHeight.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[4]);
                TxtBx_AnchorAngle.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[5]);
                TxtBx_AnchorLength.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[6]);
                TxtBx_AnchorForce.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[7]);
                TxtBx_AnchorYeild.Text = System.Convert.ToString(dt_Anchor.Rows[0].ItemArray[8]);
            }


        }

        private void Retrieve_Forces_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Force = new DataTable();
            DataTable dt_Models = new DataTable();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force] Where [Force Name] = '" + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Force.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Force);
            Connection.Close();

            if (dt_Force.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Force.Rows[0].ItemArray[0]);
                if (System.Convert.ToString(dt_Force.Rows[0].ItemArray[2]) == "Point")
                {
                    Pnl_PointLoad.Visible = true;
                    Pnl_UniformLoad.Visible = false;

                    Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
                    dt_Models.Clear();
                    Query.Connection = Connection;
                    Connection.Open();
                    DataAdapter.SelectCommand = Query;
                    DataAdapter.SelectCommand.Connection = Connection;
                    DataAdapter.Fill(dt_Models);
                    Connection.Close();

                    ComBx_Model_PointLoad.BindingContext = new BindingContext();
                    ComBx_Model_PointLoad.DataSource = dt_Models;
                    ComBx_Model_PointLoad.ValueMember = "Id_Model";
                    ComBx_Model_PointLoad.DisplayMember = "Model Name";

                    for (int i = 0; i < dt_Models.Rows.Count; i++)
                    {
                        if (System.Convert.ToInt32(dt_Force.Rows[0].ItemArray[3]) == System.Convert.ToInt32(dt_Models.Rows[i].ItemArray[0]))
                        {
                            ComBx_Model_PointLoad.Text = System.Convert.ToString(dt_Models.Rows[i].ItemArray[1]);
                        }
                    }

                    Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
                    dt_Slope.Clear();
                    Query.Connection = Connection;
                    Connection.Open();
                    DataAdapter.SelectCommand = Query;
                    DataAdapter.SelectCommand.Connection = Connection;
                    DataAdapter.Fill(dt_Slope);
                    Connection.Close();

                    ComBx_Slope_PointLoad.BindingContext = new BindingContext();
                    ComBx_Slope_PointLoad.DataSource = dt_Slope;
                    ComBx_Slope_PointLoad.ValueMember = "Id_Slope";
                    ComBx_Slope_PointLoad.DisplayMember = "Slope Name";

                    for (int i = 0; i < dt_Slope.Rows.Count; i++)
                    {
                        if (System.Convert.ToInt32(dt_Force.Rows[0].ItemArray[4]) == System.Convert.ToInt32(dt_Slope.Rows[i].ItemArray[0]))
                        {
                            ComBx_Slope_PointLoad.Text = System.Convert.ToString(dt_Slope.Rows[i].ItemArray[1]);

                        }
                    }

                    TxtBx_ForceName_PointLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[1]);
                    TxtBx_HeighinFace_PointLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[5]);
                    TxtBx_Force_PointLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[7]);
                }

                if (System.Convert.ToString(dt_Force.Rows[0].ItemArray[2]) == "Uniform")
                {
                    Pnl_PointLoad.Visible = false;
                    Pnl_UniformLoad.Visible = true;

                    Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
                    dt_Models.Clear();
                    Query.Connection = Connection;
                    Connection.Open();
                    DataAdapter.SelectCommand = Query;
                    DataAdapter.SelectCommand.Connection = Connection;
                    DataAdapter.Fill(dt_Models);
                    Connection.Close();

                    ComBx_Model_UniFormLoad.BindingContext = new BindingContext();
                    ComBx_Model_UniFormLoad.DataSource = dt_Models;
                    ComBx_Model_UniFormLoad.ValueMember = "Id_Model";
                    ComBx_Model_UniFormLoad.DisplayMember = "Model Name";

                    for (int i = 0; i < dt_Models.Rows.Count; i++)
                    {
                        if (System.Convert.ToInt32(dt_Force.Rows[0].ItemArray[3]) == System.Convert.ToInt32(dt_Models.Rows[i].ItemArray[0]))
                        {
                            ComBx_Model_UniFormLoad.Text = System.Convert.ToString(dt_Models.Rows[i].ItemArray[1]);
                        }
                    }

                    Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
                    dt_Slope.Clear();
                    Query.Connection = Connection;
                    Connection.Open();
                    DataAdapter.SelectCommand = Query;
                    DataAdapter.SelectCommand.Connection = Connection;
                    DataAdapter.Fill(dt_Slope);
                    Connection.Close();

                    ComBx_Slope_UniFormLoad.BindingContext = new BindingContext();
                    ComBx_Slope_UniFormLoad.DataSource = dt_Slope;
                    ComBx_Slope_UniFormLoad.ValueMember = "Id_Slope";
                    ComBx_Slope_UniFormLoad.DisplayMember = "Slope Name";

                    for (int i = 0; i < dt_Slope.Rows.Count; i++)
                    {
                        if (System.Convert.ToInt32(dt_Force.Rows[0].ItemArray[4]) == System.Convert.ToInt32(dt_Slope.Rows[i].ItemArray[0]))
                        {
                            ComBx_Slope_UniFormLoad.Text = System.Convert.ToString(dt_Slope.Rows[i].ItemArray[1]);
                        }
                    }

                    TxtBx_ForceName_UniFormLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[1]);
                    TxtBx_FromHeighinFace_UniFormLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[5]);
                    TxtBx_ToHeighinFace_UniFormLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[6]);
                    TxtBx_Force_UniFormLoad.Text = System.Convert.ToString(dt_Force.Rows[0].ItemArray[7]);

                }

            }

        }

        private void Retrieve_Joints_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Joint = new DataTable();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint] Where [Joint Name] = '" + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Joint.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Joint);
            Connection.Close();

            if (dt_Joint.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Joint.Rows[0].ItemArray[0]);
                TxtBx_JointName.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[1]);
                TxtBx_JointCohesiveStrength.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[2]);
                TxtBx_JointCohesiveStrength_Dev.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[3]);
                TxtBx_JointFrictionAngle.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[4]);
                TxtBx_JointFrictionAngle_Dev.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[5]);
                ComBx_JointCohesiveStrength_Dist.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[6]);
                ComBx_JointFrictionAngle_Dist.Text = System.Convert.ToString(dt_Joint.Rows[0].ItemArray[7]);
            }
        }

        private void Retrieve_Material_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Material = new DataTable();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material] Where [Material Name] = '" + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Material.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Material);
            Connection.Close();

            if (dt_Material.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Material.Rows[0].ItemArray[0]);

                TxtBx_MaterialName.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[1]);
                CmbBx_MaterialType.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[2]);
                TxtBx_CohesiveStrength.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[3]);
                TxtBx_CohesiveStrength_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[4]);
                TxtBx_FrictionAngle.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[5]);
                TxtBx_FrictionAngle_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[6]);
                TxtBx_UnitWeight.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[7]);
                TxtBx_UnitWeight_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[8]);
                TxtBx_TensileStrength.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[9]);
                TxtBx_TensileStrength_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[10]);
                TxtBx_YoungModulus.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[11]);
                TxtBx_YoungModulus_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[12]);
                TxtBx_PoissonRatio.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[13]);
                TxtBx_PoissonRatio_Dev.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[14]);
                ComBx_CohesiveStrength_Dist.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[15]);
                ComBx_FrictionAngle_Dist.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[16]);
                ComBx_UnitWeight_Dist.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[17]);
                ComBx_TensileStrength_Dist.Text = System.Convert.ToString(dt_Material.Rows[0].ItemArray[18]);
            }

        }

        private void Retrieve_Models_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Model = new DataTable();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '" + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Model.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Model);
            Connection.Close();

            if (dt_Model.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Model.Rows[0].ItemArray[0]);
                TxtBx_NewModelName.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[1]);
                TxtBx_HorizontalAcceleration.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[2]);
                TxtBx_HorizontalAcceleration_Dev.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[3]);
                TxtBx_VerticalAcceleration.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[4]);
                TxtBx_VerticalAcceleration_Dev.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[5]);
                ComBx_HorizontalAcceleration_Dist.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[7]);
                ComBx_VerticalAcceleration_Dist.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[8]);
            }
        }

        private void Retrieve_Sequence_Data(int SeqNo)
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Joint = new DataTable();
            DataTable dt_Sequence = new DataTable();
            DataTable dt_Model = new DataTable();
            DataTable dt_Slope = new DataTable();
            int Max_SeqNo = 0;

            TxtBx_MdlNam.Visible = true;
            NumUpDwn_SeqNo.Visible = true;


            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name] Where [Model Name] = '" + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Model.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Model);
            Connection.Close();
            if (dt_Model.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Model.Rows[0].ItemArray[0]);

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope_Sequence] Where [Id_Model] = '" + System.Convert.ToString(DB_Id) + "'";//read column joints information of slopes
                dt_Sequence.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Sequence);
                Connection.Close();

                if (dt_Sequence.Rows.Count > 0)
                {
                    TxtBx_MdlNam.Text = System.Convert.ToString(dt_Model.Rows[0].ItemArray[1]);
                    for (int i = 0; i < dt_Sequence.Rows.Count; i++)
                    {
                        if (System.Convert.ToInt32(dt_Sequence.Rows[i].ItemArray[4]) > Max_SeqNo)
                            Max_SeqNo = System.Convert.ToInt32(dt_Sequence.Rows[i].ItemArray[4]);


                        if (SeqNo == System.Convert.ToInt32(dt_Sequence.Rows[i].ItemArray[4]))
                        {
                            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
                            dt_Slope.Clear();
                            Query.Connection = Connection;
                            Connection.Open();
                            DataAdapter.SelectCommand = Query;
                            DataAdapter.SelectCommand.Connection = Connection;
                            DataAdapter.Fill(dt_Slope);
                            Connection.Close();

                            ComBx_SelectSlope_Sequence.BindingContext = new BindingContext();
                            ComBx_SelectSlope_Sequence.DataSource = dt_Slope;
                            ComBx_SelectSlope_Sequence.ValueMember = "Id_Slope";
                            ComBx_SelectSlope_Sequence.DisplayMember = "Slope Name";

                            for (int j = 0; j < dt_Slope.Rows.Count; j++)
                            {
                                if (System.Convert.ToInt32(dt_Sequence.Rows[i].ItemArray[2]) == System.Convert.ToInt32(dt_Slope.Rows[j].ItemArray[0]))
                                {
                                    ComBx_SelectSlope_Sequence.Text = System.Convert.ToString(dt_Slope.Rows[j].ItemArray[1]);
                                }
                            }

                            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint]";
                            dt_Joint.Clear();
                            Query.Connection = Connection;
                            Connection.Open();
                            DataAdapter.SelectCommand = Query;
                            DataAdapter.SelectCommand.Connection = Connection;
                            DataAdapter.Fill(dt_Joint);
                            Connection.Close();

                            ComBx_SelectJoint_Sequence.BindingContext = new BindingContext();
                            ComBx_SelectJoint_Sequence.DataSource = dt_Joint;
                            ComBx_SelectJoint_Sequence.ValueMember = "Id_Joint";
                            ComBx_SelectJoint_Sequence.DisplayMember = "Joint Name";

                            for (int j = 0; j < dt_Joint.Rows.Count; j++)
                            {
                                if (System.Convert.ToInt32(dt_Sequence.Rows[i].ItemArray[3]) == System.Convert.ToInt32(dt_Joint.Rows[j].ItemArray[0]))
                                {
                                    ComBx_SelectJoint_Sequence.Text = System.Convert.ToString(dt_Joint.Rows[j].ItemArray[1]);
                                }
                            }
                        }
                    }
                    Pnl_ModelSequenceInput.Visible = true;
                    NumUpDwn_SeqNo.Maximum = Max_SeqNo;
                    NumUpDwn_SeqNo.Value = SeqNo;
                    NumUpDwn_SeqNo.Refresh();
                }
                else
                {
                    Pnl_ModelSequenceInput.Visible = false;
                    MessageBox.Show("No Sequence was define for this Model");
                }
            }
        }

        private void Retrieve_Slopes_Data()
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Joint = new DataTable();
            DataTable dt_Slope = new DataTable();
            DataTable dt_Material = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] Where [Slope Name] = '"
                + ComBx_EditDeleteSelect.Text + "'";//read column joints information of slopes
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            if (dt_Slope.Rows.Count > 0)
            {
                DB_Id = System.Convert.ToInt32(dt_Slope.Rows[0].ItemArray[0]);


                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material]";
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();

                ComBx_SelectMaterial.BindingContext = new BindingContext();
                ComBx_SelectMaterial.DataSource = dt_Material;
                ComBx_SelectMaterial.ValueMember = "Id_Material";
                ComBx_SelectMaterial.DisplayMember = "Material Name";

                for (int i = 0; i < dt_Material.Rows.Count; i++)
                {
                    if (System.Convert.ToInt32(dt_Slope.Rows[0].ItemArray[2]) == System.Convert.ToInt32(dt_Material.Rows[i].ItemArray[0]))
                    {
                        ComBx_SelectMaterial.Text = System.Convert.ToString(dt_Material.Rows[i].ItemArray[1]);
                    }
                }





                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint]";
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                ComBx_SelectColumnJoint.BindingContext = new BindingContext();
                ComBx_SelectColumnJoint.DataSource = dt_Joint;
                ComBx_SelectColumnJoint.ValueMember = "Id_Joint";
                ComBx_SelectColumnJoint.DisplayMember = "Joint Name";
                ComBx_SelectBasalPlaneJoint.BindingContext = new BindingContext();
                ComBx_SelectBasalPlaneJoint.DataSource = dt_Joint;
                ComBx_SelectBasalPlaneJoint.ValueMember = "Id_Joint";
                ComBx_SelectBasalPlaneJoint.DisplayMember = "Joint Name";

                for (int i = 0; i < dt_Joint.Rows.Count; i++)
                {
                    if (System.Convert.ToInt32(dt_Slope.Rows[0].ItemArray[9]) == System.Convert.ToInt32(dt_Joint.Rows[i].ItemArray[0]))
                    {
                        ComBx_SelectColumnJoint.Text = System.Convert.ToString(dt_Joint.Rows[i].ItemArray[1]);
                    }
                    if (System.Convert.ToInt32(dt_Slope.Rows[0].ItemArray[12]) == System.Convert.ToInt32(dt_Joint.Rows[i].ItemArray[0]))
                    {
                        ComBx_SelectBasalPlaneJoint.Text = System.Convert.ToString(dt_Joint.Rows[i].ItemArray[1]);
                    }
                }
                TxtBx_SlopeName.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[1]);
                TxtBx_FaceAngle.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[3]);
                TxtBx_FaceHeight.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[4]);
                TxtBx_FaceColumnNo.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[5]);
                TxtBx_FaceColumnNo_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[6]);
                TxtBx_ColumnAngle.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[7]);
                TxtBx_ColumnAngle_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[8]);
                TxtBx_BasalPlaneAngle.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[10]);
                TxtBx_BasalPlaneAngle_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[11]);
                TxtBx_TopWaterLevel.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[13]);
                TxtBx_TopWaterLevel_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[14]);
                TxtBx_WaterLevelAngle.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[15]);
                TxtBx_WaterLevelAngle_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[16]);
                TxtBx_ColumnBlockyness.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[17]);
                TxtBx_ColumnBlockyness_Dev.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[18]);
                ComBx_FaceColumnNo_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[20]);
                ComBx_ColumnAngle_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[21]);
                ComBx_BasalPlaneAngle_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[22]);
                ComBx_TopWaterLevel_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[23]);
                ComBx_WaterLevelAngle_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[24]);
                ComBx_ColumnBlockyness_Dist.Text = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[25]);
            }
        }

        private void Rad_Btn_DB_Material_CheckedChanged(object sender, EventArgs e)
        {
            Pnl_MaterialDefinition.Visible = true;
            Pnl_SlopeDefinition.Visible = false;
            Pnl_ExternalForces.Visible = false;
            Pnl_Joint.Visible = false;
            Pnl_NewModel.Visible = false;
            Pnl_KinematicAnalysis.Visible = false;
            Pnl_AnalyticalSolution.Visible = false;
            Pnl_ProbabilisticAnalysis.Visible = false;
            Pnl_DataBaseView.Visible = true;
            Pnl_Refferences.Visible = false;

            Btn_AddMaterial.Visible = false;




            SqlCommand Query = new SqlCommand();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material]";
            DataTable dt_Material = new DataTable();
            dt_Material.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Material);
            Connection.Close();

            ComBx_EditDeleteSelect.BindingContext = new BindingContext();
            ComBx_EditDeleteSelect.DataSource = dt_Material;
            ComBx_EditDeleteSelect.ValueMember = "Id_Material";
            ComBx_EditDeleteSelect.DisplayMember = "Material Name";
        }

        private void NumUpDwn_SeqNo_ValueChanged(object sender, EventArgs e)
        {
            Retrieve_Sequence_Data(System.Convert.ToInt32(NumUpDwn_SeqNo.Value));
        }

        private void Btn_Edit_Click(object sender, EventArgs e)
        {
            try
            {
                if (Rad_Btn_DB_Anchors.Checked == true)
                {
                    Edit_DB_Anchor();
                }
                if (Rad_Btn_DB_Forces.Checked == true)
                {
                    if (Pnl_PointLoad.Visible == true && Pnl_UniformLoad.Visible == false)
                        Edit_DB_PointLoad();
                    if (Pnl_PointLoad.Visible == false && Pnl_UniformLoad.Visible == true)
                        Edit_DB_UniformLoad();
                }
                if (Rad_Btn_DB_Joints.Checked == true)
                {
                    Edit_DB_Joint();
                }
                if (Rad_Btn_DB_Material.Checked == true)
                {
                    Edit_DB_Material();
                }
                if (Rad_Btn_DB_Models.Checked == true)
                {
                    Edit_DB_Model();
                }
                if (Rad_Btn_DB_Sequences.Checked == true)
                {
                    Edit_DB_Sequence();
                }
                if (Rad_Btn_DB_Slope.Checked == true)
                {
                    Edit_DB_Slope();
                }
            }
            catch
            {
            }
        }

        private void Edit_DB_Anchor()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Anchor Edited Successfully";
            SqlCommand Query = new SqlCommand();

            ERROR_Anchor_DB();

            if (Error == false)
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Anchor] SET [Anchor Name] = @AnchorName"
                    + ", Id_Slope = (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '" + ComBx_SelectSlope.Text
                    + "'), Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '" + ComBx_SelectModel.Text
                    + "'), [Height in Face] = @HeightinFace, [Anchor Angle] = @AnchorAngle"
                    + ", [Anchor Length] = @AnchorLength, [Anchorage Force] = @AnchorageForce, [Anchorage Yield Force] = @AnchorageYeildForce "
                    + " WHERE Id_Anchor = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Parameters.Add("@AnchorName", SqlDbType.NVarChar).Value = TxtBx_AnchorName.Text.Trim();
                Query.Parameters.Add("@HeightinFace", SqlDbType.Decimal).Value = TxtBx_AnchorHeight.Text.Trim();
                Query.Parameters.Add("@AnchorAngle", SqlDbType.Decimal).Value = TxtBx_AnchorAngle.Text.Trim();
                Query.Parameters.Add("@AnchorLength", SqlDbType.Decimal).Value = TxtBx_AnchorLength.Text.Trim();
                Query.Parameters.Add("@AnchorageForce", SqlDbType.Decimal).Value = TxtBx_AnchorForce.Text.Trim();
                Query.Parameters.Add("@AnchorageYeildForce", SqlDbType.Decimal).Value = TxtBx_AnchorYeild.Text.Trim();
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_UniformLoad()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Force Edited Successfully";
            SqlCommand Query = new SqlCommand();

            ERROR_UniformLoad_DB();

            if (Error == false)
            {

                Query.CommandText = "UPDATE [dbo].[Tbl_Force] SET [Force Name] = @ForceName, [Force Type] = @ForceType"
                    + ", Model_Id = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '"
                    + ComBx_Model_UniFormLoad.Text + "'), Slope_Id = (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '"
                    + ComBx_Slope_UniFormLoad.Text + "'), [From Height In Face] = @FromHeightInFace, [To Height In Face] = @ToHeightInFace, Force = @Force"
                    + " WHERE Id_Force = '" + System.Convert.ToString(DB_Id) + "'";

                Query.Parameters.Add("@ForceName", SqlDbType.NVarChar).Value = TxtBx_ForceName_UniFormLoad.Text.Trim();
                Query.Parameters.Add("@ForceType", SqlDbType.NVarChar).Value = "Uniform";
                Query.Parameters.Add("@FromHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FromHeighinFace_UniFormLoad.Text.Trim());
                Query.Parameters.Add("@ToHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_ToHeighinFace_UniFormLoad.Text.Trim());
                Query.Parameters.Add("@Force", SqlDbType.Decimal).Value = TxtBx_Force_UniFormLoad.Text.Trim();
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_PointLoad()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Force Edited Seccessfully";
            SqlCommand Query = new SqlCommand();

            ERROR_PointLoad_DB();

            if (Error == false)
            {

                Query.CommandText = "UPDATE [dbo].[Tbl_Force] SET [Force Name] = @ForceName, [Force Type] = @ForceType"
                    + ", Model_Id = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name] WHERE [Model Name] = '"
                    + ComBx_Model_PointLoad.Text + "'), Slope_Id = (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '"
                    + ComBx_Slope_PointLoad.Text + "'), [From Height In Face] = @FromHeightInFace, [To Height In Face] = @ToHeightInFace, Force = @Force"
                    + " WHERE Id_Force = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Parameters.Add("@ForceName", SqlDbType.NVarChar).Value = TxtBx_ForceName_PointLoad.Text.Trim();
                Query.Parameters.Add("@ForceType", SqlDbType.NVarChar).Value = "Point";
                Query.Parameters.Add("@FromHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim());
                Query.Parameters.Add("@ToHeightInFace", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_HeighinFace_PointLoad.Text.Trim());
                Query.Parameters.Add("@Force", SqlDbType.Decimal).Value = TxtBx_Force_PointLoad.Text.Trim();

                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_Joint()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Joint Edited Successfully";
            SqlCommand Query = new SqlCommand();

            ERROR_Joint_DB();


            if (Error == false)
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Joint] SET [Joint Name] = @JointName, [Cohesive Strength] = @CohesiveStrengt, [Cohesive Strength Tolerance] = @CohesiveStrengtTolerance"
                    + ", [Friction Angle] = @FrictionAngle, [Friction Angle Tolerance] = @FrictionAngleTolerance, [Cohesive Strength Disrtibution] = @CohesiveStrengthDisrtibution, [Friction Angle Distribution] = @FrictionAngleDistribution"
                    + " WHERE Id_Joint = '" + System.Convert.ToString(DB_Id) + "'";

                Query.Parameters.Add("@JointName", SqlDbType.NVarChar).Value = TxtBx_JointName.Text.Trim();
                Query.Parameters.Add("@CohesiveStrengt", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointCohesiveStrength.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengtTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointCohesiveStrength_Dev.Text.Trim());
                Query.Parameters.Add("@FrictionAngle", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointFrictionAngle.Text.Trim());
                Query.Parameters.Add("@FrictionAngleTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_JointFrictionAngle_Dev.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthDisrtibution", SqlDbType.NVarChar).Value = ComBx_JointCohesiveStrength_Dist.SelectedItem;
                Query.Parameters.Add("@FrictionAngleDistribution", SqlDbType.NVarChar).Value = ComBx_JointFrictionAngle_Dist.SelectedItem;

                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshJointComboboxes();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_Material()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Material Edited Successfully";
            SqlCommand Query = new SqlCommand();

            ERROR_Material_DB();

            if (Error == false)
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Material] SET [Material Name] = @MaterialName, [Material Type] = @MaterialType"
                    + ", [Cohesive Strength] = @CohesiveStrength, [Cohesive StrengthTolerance] = @CohesiveStrengthTolerance, [Friction Angle] = @FrictionAngle"
                    + ", [Friction Angle_Tolerance] = @FrictionAngleTolerance, [Unit Weight] = @UnitWeight, [Unit Weight Tolerance] = @UnitWeightTolerance"
                    + ", [Tensile Strength] = @TensileStrength, [Tensile Strength Tolerance] = @TensileStrengthTolerance, [Young Modulus] = @YoungModulus"
                    + ", [Young Modulus Tolerance] = @YoungModulusTolerance, [Poisson Ratio] = @PoissonRatio, [Poisson Ratio Tolerance] = @PoissonRatioTolerance"
                    + ", [Cohesive Strength Disrtibution] = @CohesiveStrengthDisrtibution, [Friction Angle Distribution] = @FrictionAngleDistribution"
                    + ", [Unit Weight Distribution] = @UnitWeightDistribution, [Tensile Strength Distribution] = @TensileStrengthDistribution"
                    + " WHERE Id_Material = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Parameters.Add("@MaterialName", SqlDbType.NVarChar).Value = TxtBx_MaterialName.Text.Trim();
                Query.Parameters.Add("@MaterialType", SqlDbType.NVarChar).Value = CmbBx_MaterialType.SelectedItem;
                Query.Parameters.Add("@CohesiveStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_CohesiveStrength.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_CohesiveStrength_Dev.Text.Trim());
                Query.Parameters.Add("@FrictionAngle", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FrictionAngle.Text.Trim());
                Query.Parameters.Add("@FrictionAngleTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_FrictionAngle_Dev.Text.Trim());
                Query.Parameters.Add("@UnitWeight", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_UnitWeight.Text.Trim());
                Query.Parameters.Add("@UnitWeightTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_UnitWeight_Dev.Text.Trim());
                Query.Parameters.Add("@TensileStrength", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_TensileStrength.Text.Trim());
                Query.Parameters.Add("@TensileStrengthTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_TensileStrength_Dev.Text.Trim());
                Query.Parameters.Add("@YoungModulus", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_YoungModulus.Text.Trim());
                Query.Parameters.Add("@YoungModulusTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_YoungModulus_Dev.Text.Trim());
                Query.Parameters.Add("@PoissonRatio", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_PoissonRatio.Text.Trim());
                Query.Parameters.Add("@PoissonRatioTolerance", SqlDbType.Decimal).Value = Convert.ToDecimal(TxtBx_PoissonRatio_Dev.Text.Trim());
                Query.Parameters.Add("@CohesiveStrengthDisrtibution", SqlDbType.NVarChar).Value = ComBx_CohesiveStrength_Dist.SelectedItem;
                Query.Parameters.Add("@FrictionAngleDistribution", SqlDbType.NVarChar).Value = ComBx_FrictionAngle_Dist.SelectedItem;
                Query.Parameters.Add("@UnitWeightDistribution", SqlDbType.NVarChar).Value = ComBx_UnitWeight_Dist.SelectedItem;
                Query.Parameters.Add("@TensileStrengthDistribution", SqlDbType.NVarChar).Value = ComBx_TensileStrength_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshMaterial();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_Model()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Model Edited Successfully \n";
            SqlCommand Query = new SqlCommand();

            ERROR_Model_DB();

            if (Error == false)
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Model_Name] SET [Model Name] = @ModelName, [Horizontal Acceleration] = @HorizontalAcceleration"
                    + ", [Horizontal Acceleration Tolerance] = @HorizontalAccelerationTolerance, [Vertical Acceleration] = @VerticalAcceleration"
                    + ", [Vertical Acceleration Tolerance] = @VerticalAccelerationTolerance, [Horizontal Acceleration Distribusion] = @HorizontalAccelerationDistribusion"
                    + ", [Vertical Acceleration Distribusion] = @VerticalAccelerationDistribusion WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";

                Query.Parameters.Add("@ModelName", SqlDbType.NVarChar).Value = TxtBx_NewModelName.Text;
                Query.Parameters.Add("@HorizontalAcceleration", SqlDbType.NVarChar).Value = TxtBx_HorizontalAcceleration.Text;
                Query.Parameters.Add("@HorizontalAccelerationTolerance", SqlDbType.NVarChar).Value = TxtBx_HorizontalAcceleration_Dev.Text;
                Query.Parameters.Add("@VerticalAcceleration", SqlDbType.NVarChar).Value = TxtBx_VerticalAcceleration.Text;
                Query.Parameters.Add("@VerticalAccelerationTolerance", SqlDbType.NVarChar).Value = TxtBx_VerticalAcceleration_Dev.Text;
                Query.Parameters.Add("@HorizontalAccelerationDistribusion", SqlDbType.NVarChar).Value = ComBx_HorizontalAcceleration_Dist.SelectedItem;
                Query.Parameters.Add("@VerticalAccelerationDistribusion", SqlDbType.NVarChar).Value = ComBx_VerticalAcceleration_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshModelName();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Edit_DB_Sequence()
        {

            Error = false;
            ErrorString = "";
            WarningString = "Sequence No. " + NumUpDwn_SeqNo.Value + " in '" + TxtBx_MdlNam.Text + "' Model Edited Successfully \n";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Sequences = new DataTable();
            DataTable dt_Slope = new DataTable();
            int Slope_Material_Type_NO = 0;
            string Slop_Mat_Typ = "";
            string thisSeqMaterialType = "";

            Query.CommandText = "SELECT * FROM Tbl_Slope_Sequence Where Id_Model = '" + System.Convert.ToString(DB_Id) + "'";//read all data fo all sequences of the model and copy all the information to datatable
            dt_Sequences.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Sequences);
            Connection.Close();

            for (int i = 0; i < dt_Sequences.Rows.Count; i++)
            {
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] Where Id_Slope = '"
                + System.Convert.ToString(dt_Sequences.Rows[i].ItemArray[2]) + "'";//read all data of Slopes that created sequenses
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();
                if (i == 0)
                {
                    Slope_Material_Type_NO++;
                    Slop_Mat_Typ = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[19]);
                }
                else
                {
                    if (Slop_Mat_Typ != System.Convert.ToString(dt_Slope.Rows[0].ItemArray[19]))
                    {
                        Slope_Material_Type_NO++;
                        Slop_Mat_Typ = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[19]);
                    }
                }
                if (System.Convert.ToInt32(dt_Sequences.Rows[i].ItemArray[4]) == NumUpDwn_SeqNo.Value)
                    thisSeqMaterialType = System.Convert.ToString(dt_Slope.Rows[0].ItemArray[19]);

            }


            if (Slope_Material_Type_NO > 2)
            {
                Error = true;
                ErrorString = "New Slope Material Type Must be " + thisSeqMaterialType;
            }

            if (Error == false)
            {
                Query.CommandText = "UPDATE [dbo].[Tbl_Slope_Sequence] Set Id_Slope = (SELECT Id_Slope FROM [dbo].[Tbl_Slope] WHERE [Slope Name] = '"
                    + ComBx_SelectSlope_Sequence.Text + "'), Id_Side_joint = (SELECT Id_Joint FROM [dbo].[Tbl_Joint] WHERE [Joint Name] = '"
                    + ComBx_SelectJoint_Sequence.Text + "')"
                    + "WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "' AND [Sequence No] = '" + NumUpDwn_SeqNo.Value + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                /*                Refresh_ComBx_SequenceNo();
                                if (TxtBx_SequenceNo.Text == "1")
                                {
                                    Query.CommandText = "INSERT INTO [dbo].[Tbl_Model_Name] ([Model Type]) Values (@ModelType)";
                                    Query.Parameters.Add("@ModelType", SqlDbType.NVarChar).Value = "";
                                    Query.Connection = Connection;
                                    Connection.Open();
                                    Query.ExecuteNonQuery();
                                    Connection.Close();
                                }
                */
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
            SetModelType();
        }

        private void Edit_DB_Slope()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Slope Definition Succeed\n";
            SqlCommand Query = new SqlCommand();

            ERROR_Slope_DB();

            if (Error == false)
            {
                Query.CommandText = "SELECT * FROM[dbo].[Tbl_Material] WHERE [Material Name] ='" + ComBx_SelectMaterial.Text + "'";
                DataTable dt_Material = new DataTable();
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();
                string Selected_Material_Type = System.Convert.ToString(dt_Material.Rows[0].ItemArray[2]);//Material Type

                Query.CommandText = "UPDATE [dbo].[Tbl_Slope] SET [Slope Name] = @SlopeName,"
                    + " Id_Material = (SELECT Id_Material FROM [dbo].[Tbl_Material] WHERE [Material Name] = '" + ComBx_SelectMaterial.Text
                    + "'), [Face Angle] = @FaceAngle, [Face Height] = @FaceHeight, [Face Column No] = @FaceColumnNo"
                    + ", [Face Column No Tolerance] = @FaceColumnNoTolerance, [Column Angle] = @ColumnAngle, [Column Angle Tolerance] = @ColumnAngleTolerance"
                    + ", Id_Column_Joint = (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '" + ComBx_SelectColumnJoint.Text
                    + "'), [Basal Plane Angle] = @BasalPlaneAngle, [Basal Plane Angle Tolerance] = @BasalPlaneAngleTolerance"
                    + ", Id_Basal_Joint = (SELECT Id_Joint FROM Tbl_Joint WHERE [Joint Name] = '" + ComBx_SelectBasalPlaneJoint.Text
                    + "'), [Top Water Level] = @TopWaterLevel, [Top Water Level Tolerance] = @TopWaterLevelTolerance, [Water Level Angle] = @WaterLevelAngle"
                    + ", [Water Level Angle Tolerance] = @WaterLevelAngleTolerance, Blockiness = @Blockiness, [Blockiness Tolerance] = @BlockinessTolerance"
                    + ", [Material Type] = @MaterialType, [Face Column No Distribution] = @FaceColumnNoDistribution"
                    + ", [Column Angle Distribution] = @ColumnAngleDistribution, [Basal Plane Angle Distribution] = @BasalPlaneAngleDistribution"
                    + ", [Top Water Level Distribution] = @TopWaterLevelDistribution, [Water Level Angle Distribution] = @WaterLevelAngleDistribution"
                    + ", [Blockiness Distribution] = @BlockinessDistribution "
                    + " WHERE Id_Slope = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Parameters.Add("@SlopeName", SqlDbType.NVarChar).Value = TxtBx_SlopeName.Text.Trim();
                Query.Parameters.Add("@FaceAngle", SqlDbType.Decimal).Value = TxtBx_FaceAngle.Text.Trim();
                Query.Parameters.Add("@FaceHeight", SqlDbType.Decimal).Value = TxtBx_FaceHeight.Text.Trim();
                Query.Parameters.Add("@FaceColumnNo", SqlDbType.Int).Value = System.Convert.ToInt32(TxtBx_FaceColumnNo.Text.Trim());
                Query.Parameters.Add("@FaceColumnNoTolerance", SqlDbType.Int).Value = System.Convert.ToInt32(TxtBx_FaceColumnNo_Dev.Text.Trim());
                Query.Parameters.Add("@ColumnAngle", SqlDbType.Decimal).Value = TxtBx_ColumnAngle.Text.Trim();
                Query.Parameters.Add("@ColumnAngleTolerance", SqlDbType.Decimal).Value = TxtBx_ColumnAngle_Dev.Text.Trim();
                Query.Parameters.Add("@BasalPlaneAngle", SqlDbType.Decimal).Value = TxtBx_BasalPlaneAngle.Text.Trim();
                Query.Parameters.Add("@BasalPlaneAngleTolerance", SqlDbType.Decimal).Value = TxtBx_BasalPlaneAngle_Dev.Text.Trim();
                Query.Parameters.Add("@TopWaterLevel", SqlDbType.Decimal).Value = TxtBx_TopWaterLevel.Text.Trim();
                Query.Parameters.Add("@TopWaterLevelTolerance", SqlDbType.Decimal).Value = TxtBx_TopWaterLevel_Dev.Text.Trim();
                Query.Parameters.Add("@WaterLevelAngle", SqlDbType.Decimal).Value = TxtBx_WaterLevelAngle.Text.Trim();
                Query.Parameters.Add("@WaterLevelAngleTolerance", SqlDbType.Decimal).Value = TxtBx_WaterLevelAngle_Dev.Text.Trim();
                Query.Parameters.Add("@Blockiness", SqlDbType.Decimal).Value = TxtBx_ColumnBlockyness.Text.Trim();
                Query.Parameters.Add("@BlockinessTolerance", SqlDbType.Decimal).Value = TxtBx_ColumnBlockyness_Dev.Text.Trim();
                Query.Parameters.Add("@MaterialType", SqlDbType.NVarChar).Value = Selected_Material_Type;
                Query.Parameters.Add("@FaceColumnNoDistribution", SqlDbType.NVarChar).Value = ComBx_FaceColumnNo_Dist.SelectedItem;
                Query.Parameters.Add("@ColumnAngleDistribution", SqlDbType.NVarChar).Value = ComBx_ColumnAngle_Dist.SelectedItem;
                Query.Parameters.Add("@BasalPlaneAngleDistribution", SqlDbType.NVarChar).Value = ComBx_BasalPlaneAngle_Dist.SelectedItem;
                Query.Parameters.Add("@TopWaterLevelDistribution", SqlDbType.NVarChar).Value = ComBx_TopWaterLevel_Dist.SelectedItem;
                Query.Parameters.Add("@WaterLevelAngleDistribution", SqlDbType.NVarChar).Value = ComBx_WaterLevelAngle_Dist.SelectedItem;
                Query.Parameters.Add("@BlockinessDistribution", SqlDbType.NVarChar).Value = ComBx_ColumnBlockyness_Dist.SelectedItem;
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                MessageBox.Show(WarningString);
                RefreshSlope();
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Btn_Delete_Click(object sender, EventArgs e)
        {
            DialogResult dr = MessageBox.Show("Are you sure yo want to permanently delete ?",
          "Delete", MessageBoxButtons.YesNo);
            if (dr == DialogResult.Yes)
            {
                if (Rad_Btn_DB_Anchors.Checked == true)
                {
                    Delete_DB_Anchor();
                }
                if (Rad_Btn_DB_Forces.Checked == true)
                {
                    Delete_DB_Load();
                }
                if (Rad_Btn_DB_Joints.Checked == true)
                {
                    Delete_DB_Joint();
                }
                if (Rad_Btn_DB_Material.Checked == true)
                {
                    Delete_DB_Material();
                }
                if (Rad_Btn_DB_Models.Checked == true)
                {
                    Delete_DB_Model();
                }
                if (Rad_Btn_DB_Sequences.Checked == true)
                {
                    Delete_DB_Sequence();
                }
                if (Rad_Btn_DB_Slope.Checked == true)
                {
                    Delete_DB_Slope();
                }
            }
        }

        private void Delete_DB_Anchor()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Anchor Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Anchors = new DataTable();

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Anchor] WHERE Id_Anchor = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                ComBx_EditDeleteSelect.DataBindings.Clear();
                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Anchor]";
                dt_Anchors.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Anchors);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Anchors;
                ComBx_EditDeleteSelect.ValueMember = "Id_Anchor";
                ComBx_EditDeleteSelect.DisplayMember = "Anchor Name";

                Retrieve_Anchors_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Delete_DB_Load()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Force Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Force = new DataTable();

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Force] WHERE Id_Force = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                ComBx_EditDeleteSelect.DataBindings.Clear();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Force]";
                dt_Force.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Force);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Force;
                ComBx_EditDeleteSelect.ValueMember = "Id_Force";
                ComBx_EditDeleteSelect.DisplayMember = "Force Name";

                Retrieve_Forces_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Delete_DB_Joint()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Joint Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Sequence = new DataTable();
            DataTable dt_Slope = new DataTable();
            DataTable dt_Joint = new DataTable();

            Query.CommandText = "SELECT * FROM Tbl_Slope_Sequence Where Id_Side_joint = '" + System.Convert.ToString(DB_Id) + "'";//read all data fo all sequences of the model and copy all the information to datatable
            dt_Sequence.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Sequence);
            Connection.Close();
            SequencesNo = dt_Sequence.Rows.Count;// Extract No of sequences in the model definition

            if (dt_Sequence.Rows.Count > 0)
            {
                Error = true;
                ErrorString = "Used Material are not Deletable!";
            }
            else
            {
                Query.CommandText = "SELECT * FROM Tbl_Slope Where Id_Column_Joint = '" + System.Convert.ToString(DB_Id)
                    + "' OR Id_Basal_Joint = '" + System.Convert.ToString(DB_Id) + "'";//read all data fo all sequences of the model and copy all the information to datatable
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();
                SequencesNo = dt_Slope.Rows.Count;// Extract No of sequences in the model definition

                if (dt_Slope.Rows.Count > 0)
                {
                    Error = true;
                    ErrorString = "Used Material are not Deletable!";
                }
            }

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Joint] WHERE Id_Joint = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                ComBx_EditDeleteSelect.DataBindings.Clear();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Joint]";
                dt_Joint.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Joint);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Joint;
                ComBx_EditDeleteSelect.ValueMember = "Id_Joint";
                ComBx_EditDeleteSelect.DisplayMember = "Joint Name";

                Retrieve_Joints_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Delete_DB_Material()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Material Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            DataTable dt_Material = new DataTable();

            Query.CommandText = "SELECT * FROM Tbl_Slope Where Id_Material = '" + System.Convert.ToString(DB_Id) + "'";//read all data fo all sequences of the model and copy all the information to datatable
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();
            SequencesNo = dt_Slope.Rows.Count;// Extract No of sequences in the model definition

            if (dt_Slope.Rows.Count > 0)
            {
                Error = true;
                ErrorString = "Used Material are not Deletable!";
            }

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Material] WHERE Id_Material = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                ComBx_EditDeleteSelect.DataBindings.Clear();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material]";
                dt_Material.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Material);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Material;
                ComBx_EditDeleteSelect.ValueMember = "Id_Material";
                ComBx_EditDeleteSelect.DisplayMember = "Material Name";

                Retrieve_Material_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void ComBx_Model_PointLoad_SelectedIndexChanged(object sender, EventArgs e)
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM "
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name]"
                + "WHERE [Model Name] = '" + ComBx_Model_PointLoad.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_Slope_PointLoad.BindingContext = new BindingContext();
            ComBx_Slope_PointLoad.DataSource = dt_Slope;
            ComBx_Slope_PointLoad.ValueMember = "Id_Slope";
            ComBx_Slope_PointLoad.DisplayMember = "Slope Name";

        }

        private void ComBx_Model_UniFormLoad_SelectedIndexChanged(object sender, EventArgs e)
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM "
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name]"
                + "WHERE [Model Name] = '" + ComBx_Model_UniFormLoad.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_Slope_UniFormLoad.BindingContext = new BindingContext();
            ComBx_Slope_UniFormLoad.DataSource = dt_Slope;
            ComBx_Slope_UniFormLoad.ValueMember = "Id_Slope";
            ComBx_Slope_UniFormLoad.DisplayMember = "Slope Name";
        }

        private void ComBx_SelectModel_SelectedIndexChanged(object sender, EventArgs e)
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope] WHERE Id_Slope IN (SELECT Id_Slope FROM "
                + "[dbo].[Tbl_Slope_Sequence] WHERE Id_Model = (SELECT Id_Model FROM [dbo].[Tbl_Model_Name]"
                + " WHERE [Model Name] = '" + ComBx_SelectModel.Text + "'))";
            dt_Slope.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Slope);
            Connection.Close();

            ComBx_SelectSlope.BindingContext = new BindingContext();
            ComBx_SelectSlope.DataSource = dt_Slope;
            ComBx_SelectSlope.ValueMember = "Id_Slope";
            ComBx_SelectSlope.DisplayMember = "Slope Name";

        }

        private void ComBx_WhichModel_Prob_SelectedIndexChanged(object sender, EventArgs e)
        {

            if(ComBx_WhichModel_Prob.Text != "System.Data.DataRowView")
            {
                ComBx_WhichModel.Text = ComBx_WhichModel_Prob.Text;
                ComBx_WhichModel.Text = ComBx_WhichModel_Prob.Text;
                DGVAnalytical_Output.Rows.Clear();//reset master output grid
                DGVAnalytical_Output.DataSource = null;
                DGVAnalytical_Report.Rows.Clear();// reset report grid
                DGVAnalytical_Report.DataSource = null;
                DGVAnalytical_Report.Rows.Add();
                Num_UpDwn_CriticalNo.Enabled = false;
                Num_UpDwn_CriticalNo.Minimum = 0;
                Num_UpDwn_CriticalNo.Value = 0;
                Num_UpDwn_CriticalNo.Maximum = 0;

                if (ExtractDataFromDataBase() == false)//extract data from data base
                    return;//Exit Method if Slope Slope Sequence is not defined properly
                           //                else
                           //                    Draw_Model();

                SliceNo = 0;
                for (int i = 1; i <= SequencesNo; i++)
                {
                    SliceNo += System.Convert.ToInt32(SequenceList[i - 1, 21]);
                }

                RadBtnAnalyticalSolution.Enabled = true;
                RadBtnKinematicAnalysis.Enabled = true;
                RadBtnProbabilisticAnalysis.Enabled = true;

                Chk_Bx_Arcs.Checked = false;
                Chk_Bx_Arcs.Enabled = false;
                Chk_Bx_Arcs.Visible = false;
                Submit_Flag = true;
            }

            if(ComBx_WhichModel_Prob.Text != ComBx_WhichModel.Text)
            ComBx_WhichModel.Text = ComBx_WhichModel_Prob.Text;

        }

        private void Delete_DB_Model()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Model Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Force = new DataTable();
            DataTable dt_Models = new DataTable();

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Anchor] WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Force] WHERE Model_Id = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Model_Name] WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();



                ComBx_EditDeleteSelect.DataBindings.Clear();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Model_Name]";
                dt_Models.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Models);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Models;
                ComBx_EditDeleteSelect.ValueMember = "Id_Model";
                ComBx_EditDeleteSelect.DisplayMember = "Model Name";

                Retrieve_Models_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Chk_Bx_Basal_Phi_Probabilistic_Click(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Mat_Phi_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Joints_Phi_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Int_Phi_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Basal_c_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Mat_c_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Joints_c_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Int_c_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Tensile_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_UnitWeight_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Kh_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Kv_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_ClmnNo_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_ClmnAng_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_BasalAng_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_Blockiness_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_WaterLevel_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void Chk_Bx_WaterAng_Probabilistic_CheckedChanged(object sender, EventArgs e)
        {
            Select_Deselect();
        }

        private void ComBx_SelectMaterial_SelectedIndexChanged(object sender, EventArgs e)
        {
            SqlCommand Query = new SqlCommand();
            DataTable dt_Material = new DataTable();
            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Material] Where [Material Name] = '"
                + ComBx_SelectMaterial.Text + "'";//read material information of slope
            dt_Material.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Material);
            Connection.Close();

            if (dt_Material.Rows.Count > 0 && RadBtnDatabaseView.Checked == false)
            {
                if(System.Convert.ToString(dt_Material.Rows[0].ItemArray[2]) == "Rock")
                {
                    Lbl_FaceColumnNo.Text = "Face Column No";
                    Lbl_ColumnAngle.Text = "Column Angle";
                    TxtBx_FaceColumnNo_Dev.Text = "0";
                    TxtBx_ColumnAngle_Dev.Text = "0";
                    TxtBx_BasalPlaneAngle.Text = "";
                    TxtBx_BasalPlaneAngle_Dev.Text = "0";
                    TxtBx_ColumnBlockyness.Text = "";
                    TxtBx_ColumnBlockyness_Dev.Text = "0";


                    ComBx_FaceColumnNo_Dist.Visible = true;
                    ComBx_ColumnAngle_Dist.Visible = true;
                    ComBx_SelectColumnJoint.Visible = true;
                    TxtBx_BasalPlaneAngle.Visible = true;
                    ComBx_BasalPlaneAngle_Dist.Visible = true;
                    TxtBx_ColumnBlockyness.Visible = true;
                    ComBx_ColumnBlockyness_Dist.Visible = true;
                    Lbl_SelectColumnJoint.Visible = true;
                    Lbl_ColumnBlockyness.Visible = true;
                    Lbl_BasalPlaneAngle.Visible = true;
                    TxtBx_ColumnBlockyness_Dev.Visible = true;

                    Lbl_FaceColumnNo_Dist.Visible = true;
                    Lbl_ColumnAngle_Dist.Visible = true;
                    Lbl_BasalPlaneAngle_Dist.Visible = true;
                    Lbl_ColumnBlockyness_Dist.Visible = true;
                    
                    ComBx_FaceColumnNo_Dist.Text= "Exact Value";
                    ComBx_ColumnAngle_Dist.Text = "Exact Value";
                    ComBx_BasalPlaneAngle_Dist.Text = "Exact Value";
                    ComBx_ColumnBlockyness_Dist.Text = "Exact Value";
                }
                else
                {
                    Lbl_FaceColumnNo.Text = "Face Slice No";
                    Lbl_ColumnAngle.Text = "Slice Angle";
                    TxtBx_FaceColumnNo_Dev.Text = "0";
                    TxtBx_ColumnAngle_Dev.Text = "0";
                    TxtBx_BasalPlaneAngle.Text = "0";
                    TxtBx_BasalPlaneAngle_Dev.Text = "0";
                    TxtBx_ColumnBlockyness.Text = "0";
                    TxtBx_ColumnBlockyness_Dev.Text = "0";


                    ComBx_FaceColumnNo_Dist.Visible = false;
                    TxtBx_FaceColumnNo_Dev.Visible = false;
                    ComBx_ColumnAngle_Dist.Visible = false;
                    TxtBx_ColumnAngle_Dev.Visible = false;
                    ComBx_SelectColumnJoint.Visible = false;
                    TxtBx_BasalPlaneAngle.Visible = false;
                    ComBx_BasalPlaneAngle_Dist.Visible = false;
                    TxtBx_BasalPlaneAngle_Dev.Visible = false;
                    TxtBx_ColumnBlockyness.Visible = false;
                    ComBx_ColumnBlockyness_Dist.Visible = false;
                    TxtBx_ColumnBlockyness_Dev.Visible = false;
                    Lbl_SelectColumnJoint.Visible = false;
                    Lbl_ColumnBlockyness.Visible = false;
                    Lbl_BasalPlaneAngle.Visible = false;

                    Lbl_FaceColumnNo_Dist.Visible = false;
                    Lbl_FaceColumnNo_Dev.Visible = false;
                    Lbl_ColumnAngle_Dist.Visible = false;
                    Lbl_ColumnAngle_Dev.Visible = false;
                    Lbl_BasalPlaneAngle_Dist.Visible = false;
                    Lbl_BasalPlaneAngle_Dev.Visible = false;
                    Lbl_ColumnBlockyness_Dist.Visible = false;
                    Lbl_ColumnBlockyness_Dev.Visible = false;

                    Pnl_SlopeDefinitionInput.Refresh();

                }
            }
        }

        private void Btn_ActivationCode_Confirm_Click(object sender, EventArgs e)
        {
            int Com_Name_lngth = _De_Code_(_Code_(Com_Nam)).Length;

            if (TXT_Bx_ActivationCode.Text.Trim().Length < Com_Name_lngth)
            {
                MessageBox.Show("Wrong code");
            }
            else
            {
                SqlCommand Query = new SqlCommand();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Activation]";//read Activation information
                DataTable dt_Activation = new DataTable();
                dt_Activation.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Activation);
                Connection.Close();




                Query.CommandText = "UPDATE [dbo].[Tbl_Activation] SET AC = '" + TXT_Bx_ActivationCode.Text.Trim() + "' WHERE Id_Code = '"
                    + System.Convert.ToString(dt_Activation.Rows[0].ItemArray[0]) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Query.CommandText = "UPDATE [dbo].[Tbl_Activation] SET MD = '"+_Code_("Activating")+"' WHERE Id_Code = '"
                    + System.Convert.ToString(dt_Activation.Rows[0].ItemArray[0]) + "'";
                Query.Connection = Connection;
                Query.ExecuteNonQuery();
                Connection.Close();


                Activation_Request(
                    System.Convert.ToString(_Code_("Activating")),
                    System.Convert.ToString(TXT_Bx_ActivationCode.Text.Trim()),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[3]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[4]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[5]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[6]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[7]),
                    System.Convert.ToString(dt_Activation.Rows[0].ItemArray[8]));

            }
        }

        private void Delete_DB_Sequence()
        {
            int Seq_No = 1;
            Error = false;
            ErrorString = "";
            WarningString = "Sequence No. " + NumUpDwn_SeqNo.Value + " in '" + TxtBx_MdlNam.Text + "' Model Deleted Successfully \n";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Sequences = new DataTable();

            Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";
            dt_Sequences.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Sequences);
            Connection.Close();

            if (dt_Sequences.Rows.Count == 0)
            {
                Error = true;
                dt_Sequences.Clear();
                ErrorString = "No Sequence Found";
            }

            if (Error == false)
            {

                Query.CommandText = "DELETE FROM [dbo].[Tbl_Force] WHERE Model_Id = '" + System.Convert.ToString(DB_Id)
                    + "' AND Slope_Id = (SELECT Id_Slope FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '" + System.Convert.ToString(DB_Id)
                    + "' AND [Sequence No] = '" + NumUpDwn_SeqNo.Value + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();


                Query.CommandText = "DELETE FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '" + System.Convert.ToString(DB_Id)
                    + "' AND [Sequence No] = '" + NumUpDwn_SeqNo.Value + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope_Sequence] WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "'";
                dt_Sequences.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Sequences);
                Connection.Close();

                for (int i = 0; i < dt_Sequences.Rows.Count; i++)
                {
                    if (System.Convert.ToInt32(dt_Sequences.Rows[i].ItemArray[4]) > Seq_No)
                    {
                        Query.CommandText = "UPDATE [dbo].[Tbl_Slope_Sequence] SET [Sequence No] = '" + System.Convert.ToString(Seq_No)
                            + "' WHERE Id_Model = '" + System.Convert.ToString(DB_Id) + "' AND [Sequence No] = '"
                            + System.Convert.ToString(dt_Sequences.Rows[i].ItemArray[4]) + "'";
                        Query.Connection = Connection;
                        Connection.Open();
                        Query.ExecuteNonQuery();
                        Connection.Close();
                    }
                    Seq_No++;
                }
                if (NumUpDwn_SeqNo.Value > 1)
                    NumUpDwn_SeqNo.Value--;
                if (NumUpDwn_SeqNo.Maximum > 1)
                    NumUpDwn_SeqNo.Maximum--;

                Retrieve_Sequence_Data(1);

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }

        private void Delete_DB_Slope()
        {
            Error = false;
            ErrorString = "";
            WarningString = "Slope Deleted Successfully";
            SqlCommand Query = new SqlCommand();
            DataTable dt_Slope = new DataTable();
            DataTable dt_Sequences = new DataTable();

            Query.CommandText = "SELECT * FROM Tbl_Slope_Sequence Where Id_Slope = '" + System.Convert.ToString(DB_Id) + "'";//read all data fo all sequences of the model and copy all the information to datatable
            dt_Sequences.Clear();
            Query.Connection = Connection;
            Connection.Open();
            DataAdapter.SelectCommand = Query;
            DataAdapter.SelectCommand.Connection = Connection;
            DataAdapter.Fill(dt_Sequences);
            Connection.Close();
            SequencesNo = dt_Sequences.Rows.Count;// Extract No of sequences in the model definition

            if (dt_Sequences.Rows.Count > 0)
            {
                Error = true;
                ErrorString = "Used slopes are not Deletable!";
            }

            if (Error == false)
            {
                Query.CommandText = "DELETE FROM [dbo].[Tbl_Slope] WHERE Id_Slope = '" + System.Convert.ToString(DB_Id) + "'";
                Query.Connection = Connection;
                Connection.Open();
                Query.ExecuteNonQuery();
                Connection.Close();

                ComBx_EditDeleteSelect.DataBindings.Clear();

                Query.CommandText = "SELECT * FROM [dbo].[Tbl_Slope]";
                dt_Slope.Clear();
                Query.Connection = Connection;
                Connection.Open();
                DataAdapter.SelectCommand = Query;
                DataAdapter.SelectCommand.Connection = Connection;
                DataAdapter.Fill(dt_Slope);
                Connection.Close();

                ComBx_EditDeleteSelect.BindingContext = new BindingContext();
                ComBx_EditDeleteSelect.DataSource = dt_Slope;
                ComBx_EditDeleteSelect.ValueMember = "Id_Slope";
                ComBx_EditDeleteSelect.DisplayMember = "Slope Name";

                Retrieve_Slopes_Data();

                MessageBox.Show(WarningString);
            }
            else
            {
                MessageBox.Show(ErrorString);
            }
        }
    }
}